//主程序
#include "vgribbonwindow.h"
#include "ui_vgribbonwindow.h"

#include<QTreeWidgetItem>
//快捷键
#include <QShortcut>
//正则表达式
#include<QRegularExpression>
//菜单栏
#include "QRibbon.h"
#include<QAction>
#include <QActionGroup>
//消息框
#include<QMessageBox>
//2d图像
#include<QPixmap>
#include <qimagereader.h>
//graphicsimage库
#include <QGraphicsScene>
#include "graphics/graphicsimageitem.h"
#include<graphics/originitem.h>
#include"graphics/rectitem.h"
#include<graphics/circleitem.h>
//文件存取
#include<QFile>
#include <QFileInfo>
#include <QFileDialog>
#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonParseError>
#include <QJsonValue>
//3d线面
#include <vtkCylinderSource.h>
//图标
#include <QIcon>
//计时器
#include <QTimer>
#include <QTime>
#include <QDateTime>
#include<QElapsedTimer>
//计算
#include<QtMath>
#define _USE_MATH_DEFINES
#pragma execution_character_set("utf-8")
//初始化全局变量
bool VGRibbonWindow::Copied=false,VGRibbonWindow::isshow=false,VGRibbonWindow::click=false;
bool VGRibbonWindow::fixed=false,VGRibbonWindow::changed=false,VGRibbonWindow::_3D=false;
bool VGRibbonWindow::pattern_changed=true;
int VGRibbonWindow::c_row=0,VGRibbonWindow::c_column=-1,VGRibbonWindow::roi=0;
double VGRibbonWindow::z_max=-1100,VGRibbonWindow::z_min=6635,VGRibbonWindow::sc=1;//缩放比
double VGRibbonWindow::x_max=-1100,VGRibbonWindow::x_min=6635;
double VGRibbonWindow::y_max=-1100,VGRibbonWindow::y_min=6635;
VGRibbonWindow::VGRibbonWindow(QWidget *parent)
	: QMainWindow(parent)
{
	ui = new Ui::VGRibbonWindow();
    ui->setupUi(this);
    //初始化窗口
    //关闭输出框中详细数据表
    ui->variable_list->close();
    //关闭输出框
    ui->outwidget->close();
    //设置输出框悬浮
    ui->outwidget->setFloating(true);
    //加载菜单栏
    QRibbon::install(this);
    //设置标题
    this->setWindowTitle("AI-VISION-v0.7.2");
    this->show();
    //扩大控件停靠范围
    setCorner(Qt::BottomLeftCorner, Qt::LeftDockWidgetArea);
    setCorner(Qt::BottomRightCorner, Qt::RightDockWidgetArea);
    //关联窗口最大值事件
	this->addAction(ui->actionFullScreen);
    connect(ui->actionFullScreen, &QAction::triggered, [&]() {

		auto full = ui->actionFullScreen->isChecked();
		menuBar()->setVisible(!full);
		ui->actionFullScreen->setShortcut(  full ? QKeySequence("Esc") : QKeySequence("Ctrl+F"));
		
		static bool maximized = false;// 记录当前状态
		if ( full )
		{
			maximized = isMaximized();
		}
		else if ( maximized && isMaximized() )
		{
			return;
		}
        if ( (full && !isMaximized()) || (!full && isMaximized()) )
		{
			if (isMaximized())
            {
				showNormal();
			}
			else
				showMaximized();
		}
    });
    //最大化界面
    showMaximized();
    //控件输入格式
    Input_format();
//    image[0]=QPixmap(":/Resources/circletest.png");
    //image[1]=QPixmap(":/Resources/Sample Pattern Find - 01 Fail.png");
    //初始化变量
    openfilepath="";
    cloudarrary.resize(1000);
    res.resize(1000);
    //初始化控件
    ui->view_reset->close();
    ui->view_back->close();
    ui->view_backlso->close();
    ui->view_bottom->close();
    ui->view_front->close();
    ui->view_frontlso->close();
    ui->view_left->close();
    ui->view_right->close();
    ui->view_up->close();
    ui->position->close();
    ui->color->close();
    ui->settingWidget->close();
    ui->CROP_move->close();
    ui->CROP_move_l->close();
    //关联菜单栏事件
    connect(ui->ordertable,SIGNAL(customContextMenuRequested(QPoint)),this,SLOT(show_menu(QPoint)));
    connect(ui->actionNew,SIGNAL(triggered()),this,SLOT(newfile()));
    connect(ui->actionSave,SIGNAL(triggered()),this,SLOT(savefile()));
    connect(ui->actionOpen,SIGNAL(triggered()),this,SLOT(openfile()));
    connect(ui->actionQuit,SIGNAL(triggered()),this,SLOT(quit()));
    connect(ui->actionorder,QOverload<bool>::of(&QAction::triggered),[=](bool){ui->toolsWidget->show();});
    connect(ui->actiontable,QOverload<bool>::of(&QAction::triggered),[=](bool){ui->orderWidget->show();});
    connect(ui->actionrun,QOverload<bool>::of(&QAction::triggered),[=](bool){ui->runWidget->show();});
    //关联窗体事件
    connect(ui->ordertable,SIGNAL(changed()),this,SLOT(settingchanged()));
    connect(ui->graphicsView,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    //设置状态栏
    currentTimeLabel = new QLabel; // 创建QLabel控件
    currentUserLabel = new QLabel("当前操作用户：Administrator");
    QStatusBar* status = statusBar();
    status->addPermanentWidget(currentUserLabel);
    status->addPermanentWidget(currentTimeLabel); //在状态栏添加此控件
    QTimer *timer = new QTimer(this);
    timer->start(1000); //每隔1000ms发送timeout的信号
    connect(timer, SIGNAL(timeout()),this,SLOT(time_update()));
    //设置视角栏图标
    QIcon myicon;
    myicon.addFile(":/Resources/image/reset.png");
    ui->view_reset->setIcon(myicon);
    myicon.addFile(":/Resources/image/up.png");
    ui->view_up->setIcon(myicon);
    myicon.addFile(":/Resources/image/front.png");
    ui->view_front->setIcon(myicon);
    myicon.addFile(":/Resources/image/left.png");
    ui->view_left->setIcon(myicon);
    myicon.addFile(":/Resources/image/back.png");
    ui->view_back->setIcon(myicon);
    myicon.addFile(":/Resources/image/right.png");
    ui->view_right->setIcon(myicon);
    myicon.addFile(":/Resources/image/bottom.png");
    ui->view_bottom->setIcon(myicon);
    myicon.addFile(":/Resources/image/frontlso.png");
    ui->view_frontlso->setIcon(myicon);
    myicon.addFile(":/Resources/image/backlso.png");
    ui->view_backlso->setIcon(myicon);
    //初始化颜色
    color_r=0.1;
    color_g=0.6;
    color_b=0.9;
    //初始化qvtkWidget
    qvtkWidget = new QVTKWidget(ui->cameraWidget);
}

QImage cvMat2Image(const cv::Mat& mat, bool clone = true, bool rb_swap = true)
{
    const uchar *pSrc = (const uchar*)mat.data;
    // 8-bits unsigned, NO. OF CHANNELS = 1
    if(mat.type() == CV_8UC1)
    {
        //QImage image(mat.cols, mat.rows, QImage::Format_Grayscale8);
        QImage image(pSrc, mat.cols, mat.rows, mat.step, QImage::Format_Grayscale8);
        if(clone) return image.copy();
        return image;
    }
    // 8-bits unsigned, NO. OF CHANNELS = 3
    else if(mat.type() == CV_8UC3)
    {
        // Create QImage with same dimensions as input Mat
        QImage image(pSrc, mat.cols, mat.rows, mat.step, QImage::Format_RGB888);
        if(clone)
        {
            if(rb_swap) return image.rgbSwapped();
            return image.copy();
        }
        else
        {
            if(rb_swap)
            {
                cv::cvtColor(mat, mat, CV_BGR2RGB);
            }
            return image;
        }

    }
    else if(mat.type() == CV_8UC4)
    {
//        qDebug() << "CV_8UC4";
        QImage image(pSrc, mat.cols, mat.rows, mat.step, QImage::Format_ARGB32);
        if(clone) return image.copy();
        return image;
    }
    else
    {
//        qDebug() << "ERROR: Mat could not be converted to QImage.";
        return QImage();
    }
}

Mat Image2cvMat(QImage image, bool clone = true, bool rb_swap = false)
{
    cv::Mat mat;
    //qDebug() << image.format();
    switch(image.format())
    {
    case QImage::Format_ARGB32:
    case QImage::Format_RGB32:
    case QImage::Format_ARGB32_Premultiplied:
        mat = cv::Mat(image.height(), image.width(), CV_8UC4, (void *)image.constBits(), image.bytesPerLine());
        cvtColor(mat , mat , cv::COLOR_RGBA2RGB);
        if(clone)  mat = mat.clone();
        break;
    case QImage::Format_RGB888:
        mat = cv::Mat(image.height(), image.width(), CV_8UC3, (void *)image.constBits(), image.bytesPerLine());
        if(clone)  mat = mat.clone();
        if(rb_swap) cv::cvtColor(mat, mat, CV_BGR2RGB);
        break;
    case QImage::Format_Indexed8:
    case QImage::Format_Grayscale8:
        mat = cv::Mat(image.height(), image.width(), CV_8UC1, (void *)image.bits(), image.bytesPerLine());
        if(clone)  mat = mat.clone();
        break;
    default:break;
    }
    return mat;
}
//更新状态栏时间
void VGRibbonWindow::time_update()
{
    QDateTime current_time = QDateTime::currentDateTime();
    QString timestr = current_time.toString( "          yyyy年MM月dd日 hh:mm:ss "); //设置显示的格式
    currentTimeLabel->setText(timestr); //设置label的文本内容为时间
}
//显示2d坐标
void VGRibbonWindow::showinfo(qreal scale,QPointF p)
{
    QPixmap tempPix= n_image.copy(p.x(),p.y(),1,1);
    QImage imageBits = tempPix.toImage();
    if(scale!=-1)
        sc=scale;
    if(imageBits.isNull() == false)
    {
        if(imageBits.allGray() == true){    //  判断是否为灰度图
            uchar * grayValue = imageBits.bits(); //  获取灰度值
            QColor color;
            color = imageBits.pixel(0,0);
            int gray=color.red();
            ui->color->setStyleSheet(QString("background-color: rgb(%1,%2,%3)").arg(gray).arg(gray).arg(gray));
            ui->position->setText("放大倍率"+QString::number(sc)+",("+QString::number(p.x()-ui->ordertable->item(c_row,5)->text().toDouble())+","+QString::number(p.y()-ui->ordertable->item(c_row,6)->text().toDouble())+")"+QString("Gray : %1").arg(*grayValue));
        }else{
            int R,G,B;
            QColor color;
            color = imageBits.pixel(0,0);    //  获取颜色
            R = color.red();
            G = color.green();
            B = color.blue();
            ui->color->setStyleSheet(QString("background-color: rgb(%1,%2,%3)").arg(R).arg(G).arg(B));
            ui->position->setText("放大倍率"+QString::number(sc)+",("+QString::number(p.x()-ui->ordertable->item(c_row,5)->text().toDouble())+","+QString::number(p.y()-ui->ordertable->item(c_row,6)->text().toDouble())+")"+QString("Rgb : %1,%2,%3").arg(R).arg(G).arg(B));
        }
    }else{
        ui->position->setText("");
        ui->color->setStyleSheet("background-color: rgb(255,255,255)");
    }
}
//显示3D坐标
void VGRibbonWindow::show3Dinfo(double x, double y,double z){
    ui->position->setText("("+QString::number(x)+","+QString::number(y)+","+QString::number(z)+")");
}
//右键菜单
void VGRibbonWindow::show_menu(const QPoint pos)
{
    //设置菜单选项
    QMenu *menu = new QMenu(ui->ordertable);
    QAction *copy = new QAction(ui->ordertable);
    copy->setText("复制");
    QAction *cut = new QAction(ui->ordertable);
    cut->setText("剪切");
    QAction *remove = new QAction(ui->ordertable);
    remove->setText("删除");

    connect (copy,SIGNAL(triggered()),this,SLOT(copy()));
    connect (cut,SIGNAL(triggered()),this,SLOT(cut()));
    connect (remove,SIGNAL(triggered()),this,SLOT(remove()));

    menu->addAction(copy);
    menu->addAction(cut);
    if(Copied){
        QAction *paste = new QAction(ui->ordertable);
        paste->setText("黏贴");
        connect (paste,SIGNAL(triggered()),this,SLOT(paste()));
        menu->addAction(paste);
    }
    menu->addAction(remove);

    menu->move (cursor ().pos ());

    //获得鼠标点击的x，y坐标点
    int x = pos.x ();
    int y = pos.y ();
    QModelIndex index = ui->ordertable->indexAt (QPoint(x,y));
    int row = index.row ();//获得QTableWidget列表点击的行数
    if(row>=0){
        menu->show ();
    }
}

//复制
void VGRibbonWindow::copy(){
    order_table_c_0=ui->ordertable->item(ui->ordertable->currentRow(),0)->text();
    order_table_c_1=ui->ordertable->item(ui->ordertable->currentRow(),1)->text();
    order_table_c_2=ui->ordertable->item(ui->ordertable->currentRow(),2)->text();
    order_table_c_3=ui->ordertable->item(ui->ordertable->currentRow(),3)->text();
    order_table_c_4=ui->ordertable->item(ui->ordertable->currentRow(),4)->text();
    order_table_c_5=ui->ordertable->item(ui->ordertable->currentRow(),5)->text();
    order_table_c_6=ui->ordertable->item(ui->ordertable->currentRow(),6)->text();
    order_table_c_7=ui->ordertable->item(ui->ordertable->currentRow(),7)->text();
    order_table_c_8=ui->ordertable->item(ui->ordertable->currentRow(),8)->text();
    order_table_c_9=ui->ordertable->item(ui->ordertable->currentRow(),9)->text();
    order_table_c_10=ui->ordertable->item(ui->ordertable->currentRow(),10)->text();
    if(order_table_c_1=="选择图像"){
        c_image=image[ui->ordertable->currentRow()];
    }
    Copied=true;
}

//剪切
void VGRibbonWindow::cut(){
    order_table_c_0=ui->ordertable->item(ui->ordertable->currentRow(),0)->text();
    order_table_c_1=ui->ordertable->item(ui->ordertable->currentRow(),1)->text();
    order_table_c_2=ui->ordertable->item(ui->ordertable->currentRow(),2)->text();
    order_table_c_3=ui->ordertable->item(ui->ordertable->currentRow(),3)->text();
    order_table_c_4=ui->ordertable->item(ui->ordertable->currentRow(),4)->text();
    order_table_c_5=ui->ordertable->item(ui->ordertable->currentRow(),5)->text();
    order_table_c_6=ui->ordertable->item(ui->ordertable->currentRow(),6)->text();
    order_table_c_7=ui->ordertable->item(ui->ordertable->currentRow(),7)->text();
    order_table_c_8=ui->ordertable->item(ui->ordertable->currentRow(),8)->text();
    order_table_c_9=ui->ordertable->item(ui->ordertable->currentRow(),9)->text();
    order_table_c_10=ui->ordertable->item(ui->ordertable->currentRow(),10)->text();
    ui->ordertable->removeRow(ui->ordertable->currentRow());
    Copied=true;
    changed=true;
}

//黏贴
void VGRibbonWindow::paste(){
    int row=ui->ordertable->currentRow();
    if(order_table_c_1=="选择图像"){
        image[row]=c_image;
    }
    ui->ordertable->insertRow(row);
    QTableWidgetItem *item=new QTableWidgetItem;
    item->setText(order_table_c_0);
    ui->ordertable->setItem(row,0,item->clone());
    item->setText(order_table_c_1);
    ui->ordertable->setItem(row,1,item->clone());
    item->setText(order_table_c_2);
    ui->ordertable->setItem(row,2,item->clone());
    item->setText(order_table_c_3);
    ui->ordertable->setItem(row,3,item->clone());
    item->setText(order_table_c_4);
    ui->ordertable->setItem(row,4,item->clone());
    item->setText(order_table_c_5);
    ui->ordertable->setItem(row,5,item->clone());
    item->setText(order_table_c_6);
    ui->ordertable->setItem(row,6,item->clone());
    item->setText(order_table_c_7);
    ui->ordertable->setItem(row,7,item->clone());
    item->setText(order_table_c_8);
    ui->ordertable->setItem(row,8,item->clone());
    item->setText(order_table_c_9);
    ui->ordertable->setItem(row,9,item->clone());
    item->setText(order_table_c_10);
    ui->ordertable->setItem(row,10,item->clone());
    changed=true;
}

//移除
void VGRibbonWindow::remove(){
    for(int i=ui->ordertable->currentRow();i<ui->ordertable->rowCount()-1;i++){
        cloudarrary[i]=cloudarrary[i+1];
        image[i]=image[i+1];
        res[i]=res[i+1];
    }
    ui->ordertable->removeRow(ui->ordertable->currentRow());

    ui->cameraWidget->close();
    ui->settingWidget->close();
    ui->position->close();
    ui->color->close();
    changed=true;
}

//新建文件
void VGRibbonWindow::newfile()
{
    for(int i=0;i<ui->ordertable->rowCount();i++){
        image[i]=empty_image;
        cloudarrary[i].resize(0);
        res[i].resize(0);
    }
    openfilepath="";
    ui->ordertable->clearContents();
    ui->ordertable->setRowCount(0);
    changed=false;
    this->setWindowTitle("AI-VISION-v0.7.2|*");
    ui->settingWidget->close();
//    ui->cameraWidget->close();
    ui->view_reset->close();
    ui->view_back->close();
    ui->view_backlso->close();
    ui->view_bottom->close();
    ui->view_front->close();
    ui->view_frontlso->close();
    ui->view_left->close();
    ui->view_right->close();
    ui->view_up->close();
    ui->position->close();
    ui->color->close();
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    ui->outwidget->close();
    c_row=0;
}

//保存文件
void VGRibbonWindow::savefile()
{
    if(openfilepath==""){
        openfilepath = QFileDialog::getSaveFileName(this,
                tr("Open Config"),
                "",
                tr("(*.json)"));

    }
    //打开文件
    QFile file(openfilepath);
    this->setWindowTitle("AI-VISION-v0.7.2|"+file.fileName());
    file.open(QIODevice::ReadWrite);
    //清空原文件
    file.resize(0);
    QJsonArray jsonArray;
    for (int i = 0; i < ui->ordertable->rowCount(); i++)
    {
        jsonArray.append("启用#"+ui->ordertable->item(i,0)->text());
        jsonArray.append("名称#"+ui->ordertable->item(i,1)->text());
        jsonArray.append("用时#"+ui->ordertable->item(i,2)->text());
        jsonArray.append("功能#"+ui->ordertable->item(i,3)->text());
        jsonArray.append("参数#"+ui->ordertable->item(i,4)->text());
        jsonArray.append("工具原点x#"+ui->ordertable->item(i,5)->text());
        jsonArray.append("工具原点y#"+ui->ordertable->item(i,6)->text());
        jsonArray.append("工具原点a#"+ui->ordertable->item(i,7)->text());
        jsonArray.append("ROI类型#"+ui->ordertable->item(i,8)->text());
        jsonArray.append("ROI#"+ui->ordertable->item(i,9)->text());
        jsonArray.append("3Dor2D#"+ui->ordertable->item(i,10)->text());
        jsonArray.append("#");

    }
    QJsonDocument jsonDoc;
    jsonDoc.setArray(jsonArray);
    file.write(jsonDoc.toJson());
    file.close();
    changed=false;
}

//读取文件
void VGRibbonWindow::openfile()
{
    openfilepath = QFileDialog::getOpenFileName(this,
        "please choose an file",
        "",
        "(*.json)");
    if(openfilepath=="")
        return;
    QString f=openfilepath;
    newfile();

    openfilepath=f;
    QString data;
    QFile file(openfilepath);    
    if(!file.open(QIODevice::ReadOnly))
    {
        QMessageBox::critical(0,QObject::tr("打开失败"),"无法打开该文件");
        return;
    }
    QByteArray allData = file.readAll();
    file.close();

    QJsonParseError jsonError;
    QJsonDocument jsonDoc(QJsonDocument::fromJson(allData, &jsonError));
    if(jsonError.error != QJsonParseError::NoError)
    {
        QMessageBox::critical(0,QObject::tr("打开失败"),"文件读取失败");
        return;
    }
    QTableWidgetItem *fileitem = new QTableWidgetItem();
    data=jsonDoc.array().at(11).toString();
    if(data!="#"){
        QMessageBox::critical(0,QObject::tr("打开失败"),"该文件并非本程序生成");
        newfile();
        return;
    }
    for(int i=0;i<jsonDoc.array().size()/12;i++){
        ui->ordertable->insertRow(ui->ordertable->rowCount());
        for(int j=0;j<11;j++){
            data=jsonDoc.array().at(i*12+j).toString();
            QStringList order_s=data.split("#");
            fileitem->setText(order_s.at(1));
            ui->ordertable->setItem(i,j,fileitem->clone());
        }
        data=jsonDoc.array().at(i*12+3).toString();
        if(data=="功能#选择图像"){
            c_row=i;
            data=jsonDoc.array().at(i*12+4).toString();
            QStringList image_a=data.split("#");
            openimagepath=image_a.at(1);
            data=jsonDoc.array().at(i*12+7).toString();
            QStringList image_r=data.split("#");
            ui->image_rotate->setText(image_r.at(1));
            qDebug()<<1;
            on_image_rotate_editingFinished();
        }else if(data=="功能#选择点云"){
            data=jsonDoc.array().at(i*12+4).toString();
            QStringList order_f=data.split("#");
            data=order_f.at(1);
            if(data!=""){
                opencloudpath=data;
                QFileInfo file;
                file=QFileInfo(opencloudpath);
                QString path1=qApp->applicationDirPath()+"/1.txt";
                QString path=qApp->applicationDirPath()+"/1.pcd";
                if(file.suffix()=="txt"){
                    qDebug()<<QFile::remove(path);
                    qDebug()<<QFile::remove(path1);
                    QFile::copy(opencloudpath,path1);
                }else{
                    qDebug()<<QFile::remove(path);
                    QFile::copy(opencloudpath,path);
                    path1=path;
                }
                YZVision::Readcloud_3D read;
                YZVision::Readcloud_3D::InputParam input= YZVision::Readcloud_3D::InputParam();
                YZVision::Readcloud_3D::OutputParam output= YZVision::Readcloud_3D::OutputParam();
                input.read=path1.toStdString();
                input.save=path.toStdString();

                read.readcloud(input,&output);
                cloudarrary[i]=output.outputcloud;
                qDebug()<<QFile::remove(path);
                qDebug()<<QFile::remove(path1);
            }
        }

    }
    changed=false;
    this->setWindowTitle("AI-VISION-v0.7.2|"+file.fileName());
}

//设置更改显示
void VGRibbonWindow::settingchanged()
{
    changed=true;
    this->setWindowTitle("AI-VISION-v0.7.2|"+openfilepath+"*");
}

//退出
void VGRibbonWindow::quit()
{
    if(changed){
        if(QMessageBox::warning(0,QObject::tr("关闭"),"是否保存当前设置",QMessageBox::Yes|QMessageBox::No)==QMessageBox::Yes)
            savefile();
    }
    close();
}

VGRibbonWindow::~VGRibbonWindow()
{
    delete ui;
}

//输入格式
void VGRibbonWindow::Input_format()
{
    //正整数输入
    QRegularExpression Non_negative_integer("[1-9]{1}+\\d{1,4}||\\d");
    //整数输入
    QRegularExpression negative_integer("[1-9]{1}+\\d{1,4}||\\d||-[1]+\\d{1,3}||-\\d||-");
    //小数输入
    QRegularExpression Non_negative_floating_point("[1-9]{1}+\\d{0,2}+\\.{1}+\\d{1,3}||[0]{1}+\\.{1}+\\d{1,3}");
    //选择图像中控件输入格式
    ui->choose_image_height->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->choose_image_width->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->image_rotate->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->origin_x->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->origin_y->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    //二值化中控件输入格式
    ui->binary_image_upper_threshold->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->binary_image_lower_threshold->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->binary_image_forecolor->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->binary_image_backcolor->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->binary_image_x->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->binary_image_y->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->binary_image_height->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->binary_image_width->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->binary_image_a->setValidator(new QRegularExpressionValidator(negative_integer, this));
    //膨胀腐蚀中控件输入格式
    ui->Expansion_corrosion_Iteration_time->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Expansion_corrosion_x->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Expansion_corrosion_y->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Expansion_corrosion_height->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Expansion_corrosion_width->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Expansion_corrosion_a->setValidator(new QRegularExpressionValidator(negative_integer, this));
    //图像运算中控件输入格式
    ui->image_math_add_1->setValidator(new QRegularExpressionValidator(Non_negative_floating_point, this));
    ui->image_math_add_2->setValidator(new QRegularExpressionValidator(Non_negative_floating_point, this));
    ui->image_math_x->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->image_math_y->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->image_math_height->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->image_math_width->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->image_math_a->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->image_math_2_x->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->image_math_2_y->setValidator(new QRegularExpressionValidator(negative_integer, this));
    //斑点查找中控件输入格式
    ui->blob_threshold_lower->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_threshold_upper->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_ROI_x->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->blob_ROI_y->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->blob_ROI_width->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_ROI_width->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_ROI_a->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->blob_width_min->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_width_max->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_height_min->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_height_max->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_area_min->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_area_max->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_number_min->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->blob_number_max->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    //线查找中控件输入格式
    ui->line_find_ratio->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->line_find_Subpixel->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->line_find_threshold_lower->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->line_find_threshold_upper->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->line_find_x->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->line_find_y->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->line_find_width->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->line_find_height->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->line_find_a->setValidator(new QRegularExpressionValidator(negative_integer, this));
    //圆查找中控件输入格式
    ui->Circle_find_ratio->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Circle_find_threshold_lower->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Circle_find_threshold_upper->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Circle_find_x->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Circle_find_y->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Circle_find_height->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Circle_find_width->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Circle_find_radius_min->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Circle_find_radius_max->setValidator(new QRegularExpressionValidator(negative_integer, this));
    //模板匹配中控件输入格式
    ui->Pattern_find_rotate_min->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Pattern_find_rotate_max->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Pattern_find_zoom_min->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Pattern_find_zoom_max->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Pattern_find_ROI_x->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Pattern_find_ROI_y->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Pattern_find_ROI_width->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Pattern_find_ROI_height->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Pattern_find_ROI_a->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Pattern_find_ROI_2_x->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Pattern_find_ROI_2_y->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Pattern_find_ROI_2_width->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Pattern_find_ROI_2_height->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Pattern_find_ROI_2_a->setValidator(new QRegularExpressionValidator(negative_integer, this));
    ui->Pattern_find_min_search->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
    ui->Pattern_find_max_number->setValidator(new QRegularExpressionValidator(Non_negative_integer, this));
}

//命令集中点击事件
void VGRibbonWindow::on_command_set_currentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *previous)
{
    Q_UNUSED(previous);
    ui->ordertable->defaultDropAction();
    if(current->childCount()==0)
    {
        ui->command_set->setDragDropMode(QAbstractItemView::DragOnly);
    }else{
        ui->command_set->setDragDropMode(QAbstractItemView::NoDragDrop);
        if(ui->command_set->currentItem()->isExpanded())
            ui->command_set->collapseItem(current);
        else
            ui->command_set->expandItem(current);
    }
}

//添加roi
void VGRibbonWindow::ROI_add(int type,qreal x,qreal y,qreal width,qreal height,qreal a)
{
    if(roi==2)
        fixed=true;
    else
        fixed=false;
    QGraphicsScene *pScene = ui->graphicsView->scene();
    if(type==1){
        rectItem *rect=new rectItem;
        rect->SetRotate(a);
        rect->setRectSize(QRectF(0,0,width,height),fixed);
        rect->setPos(x+ui->ordertable->item(c_row,5)->text().toDouble(),y+ui->ordertable->item(c_row,6)->text().toDouble());
        pScene->addItem(rect);
        connect(rect,&rectItem::mysignals,this,&VGRibbonWindow::updateItemPos);
    }else{
        CircleItem *item =new CircleItem;
        item->setSize(QRectF(0,0,height,width),fixed);
        item->setPos(x+ui->ordertable->item(c_row,5)->text().toDouble()-100,y+ui->ordertable->item(c_row,6)->text().toDouble()-100);
        pScene->addItem(item);
        connect(item,&CircleItem::mysignals,this,&VGRibbonWindow::updateItemPos);
    }
}

//更新roi坐标
void VGRibbonWindow::updateItemPos(int type,QPointF pos,QPointF lt,QPointF rt,QPointF rb,QPointF lb,int Rotate){
    //QTransform transform;
    Q_UNUSED(rb);
    qreal x,y,height,width;
    x=pos.toPoint().x();
    y=pos.toPoint().y();
    if(type==1){
        height=sqrt((lt.x()-lb.x())*(lt.x()-lb.x())+(lt.y()-lb.y())*(lt.y()-lb.y()));
        width=sqrt((lt.x()-rt.x())*(lt.x()-rt.x())+(lt.y()-rt.y())*(lt.y()-rt.y()));
    }else{
        height=pos.x()-lt.x();
        width=pos.x()-rt.x();
        height=height*2;
        width=width*2;
    }
    int x1=pos.toPoint().x()-ui->ordertable->item(c_row,5)->text().toDouble(),y1=pos.toPoint().y()-ui->ordertable->item(c_row,6)->text().toDouble(),height1=height,width1=width;
    if(ui->ordertable->item(c_row,3)->text()=="二值化图像"){
        if(type==1){
            boundary_position(type,x,y,width,height,Rotate);
            qreal y_max,y_min,x_max,x_min;
            y_max=y_min=boundary[0].y;
            x_max=x_min=boundary[0].x;
            for(int j=1;j<4;j++){
                if(boundary[j].x>x_max)
                    x_max=boundary[j].x;
                else if(boundary[j].x<x_min)
                    x_min=boundary[j].x;
                if(boundary[j].y>y_max)
                    y_max=boundary[j].y;
                else if(boundary[j].y<y_min)
                    y_min=boundary[j].y;
            }
            if(x_min>=0
             &&x_max<=image[ui->binary_image_raw_image->currentText().toInt()-1].width()
             &&y_min>=0
             &&y_max<=image[ui->binary_image_raw_image->currentText().toInt()-1].height()){
                ui->binary_image_x->setText(QString::number(x1));
                ui->binary_image_y->setText(QString::number(y1));
                ui->binary_image_height->setText(QString::number(height1));
                ui->binary_image_width->setText(QString::number(width1));
                if(Rotate!=-1)
                    ui->binary_image_a->setText(QString::number(Rotate%360));
            }else{
                QGraphicsScene *scene = new QGraphicsScene;
                graphicsimageitem* raw = new graphicsimageitem(image[ui->binary_image_raw_image->currentText().toInt()-1]);
                n_image=image[ui->binary_image_raw_image->currentText().toInt()-1];
                connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                scene->addItem(raw);
                ui->graphicsView->setScene(scene);
                ROI_add(1,ui->binary_image_x->text().toInt(),ui->binary_image_y->text().toInt(),ui->binary_image_width->text().toInt(),ui->binary_image_height->text().toInt(),ui->binary_image_a->text().toInt());
           }
        }else{
            if(x-height/2>=0
             &&x+height/2<=image[ui->binary_image_raw_image->currentText().toInt()-1].width()
             &&y-height/2>=0
             &&y+height/2<=image[ui->binary_image_raw_image->currentText().toInt()-1].height()){
                ui->binary_image_x->setText(QString::number(x1));
                ui->binary_image_y->setText(QString::number(y1));
                ui->binary_image_height->setText(QString::number(height1));
                ui->binary_image_width->setText(QString::number(width1));
            }else{
                QGraphicsScene *scene = new QGraphicsScene;
                graphicsimageitem* raw = new graphicsimageitem(image[ui->binary_image_raw_image->currentText().toInt()-1]);
                n_image=image[ui->binary_image_raw_image->currentText().toInt()-1];
                connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                scene->addItem(raw);
                ui->graphicsView->setScene(scene);
                ROI_add(2,ui->binary_image_x->text().toInt(),ui->binary_image_y->text().toInt(),ui->binary_image_width->text().toInt(),ui->binary_image_height->text().toInt(),0);
            }
        }
    }else if(ui->ordertable->item(c_row,3)->text()=="膨胀/腐蚀"){
        if(type==1){
            boundary_position(type,x,y,width,height,Rotate);
            qreal y_max,y_min,x_max,x_min;
            y_max=y_min=boundary[0].y;
            x_max=x_min=boundary[0].x;
            for(int j=1;j<4;j++){
                if(boundary[j].x>x_max)
                    x_max=boundary[j].x;
                else if(boundary[j].x<x_min)
                    x_min=boundary[j].x;
                if(boundary[j].y>y_max)
                    y_max=boundary[j].y;
                else if(boundary[j].y<y_min)
                    y_min=boundary[j].y;
            }

            if(x_min>=0
             &&x_max<=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width()
             &&y_min>=0
             &&y_max<=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height()){
                ui->Expansion_corrosion_x->setText(QString::number(x1));
                ui->Expansion_corrosion_y->setText(QString::number(y1));
                ui->Expansion_corrosion_height->setText(QString::number(height1));
                ui->Expansion_corrosion_width->setText(QString::number(width1));
                if(Rotate!=-1)
                    ui->Expansion_corrosion_a->setText(QString::number(Rotate%360));
            }else{
                QGraphicsScene *scene = new QGraphicsScene;
                graphicsimageitem* raw = new graphicsimageitem(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1]);
                n_image=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1];
                connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                scene->addItem(raw);
                ui->graphicsView->setScene(scene);
                ROI_add(1,ui->Expansion_corrosion_x->text().toInt(),ui->Expansion_corrosion_y->text().toInt(),ui->Expansion_corrosion_width->text().toInt(),ui->Expansion_corrosion_height->text().toInt(),ui->Expansion_corrosion_a->text().toInt());
                }
        }else{
            if(x-height/2>=0
             &&x+height/2<=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width()
             &&y-height/2>=0
             &&y+height/2<=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height()){
                ui->Expansion_corrosion_x->setText(QString::number(x1));
                ui->Expansion_corrosion_y->setText(QString::number(y1));
                ui->Expansion_corrosion_height->setText(QString::number(height1));
                ui->Expansion_corrosion_width->setText(QString::number(width1));
            }else{
                QGraphicsScene *scene = new QGraphicsScene;
                graphicsimageitem* raw = new graphicsimageitem(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1]);
                n_image=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1];
                connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                scene->addItem(raw);
                ui->graphicsView->setScene(scene);
                ROI_add(2,ui->Expansion_corrosion_x->text().toInt(),ui->Expansion_corrosion_y->text().toInt(),ui->Expansion_corrosion_width->text().toInt(),ui->Expansion_corrosion_height->text().toInt(),0);
            }
        }
    }else if(ui->ordertable->item(c_row,3)->text()=="图像运算"){
        if(roi==1){
            if(type==1){
                boundary_position(type,x,y,width,height,Rotate);
                qreal y_max,y_min,x_max,x_min;
                y_max=y_min=boundary[0].y;
                x_max=x_min=boundary[0].x;
                for(int j=1;j<4;j++){
                    if(boundary[j].x>x_max)
                        x_max=boundary[j].x;
                    else if(boundary[j].x<x_min)
                        x_min=boundary[j].x;
                    if(boundary[j].y>y_max)
                        y_max=boundary[j].y;
                    else if(boundary[j].y<y_min)
                        y_min=boundary[j].y;
                }

                if(x_min>=0
                 &&x_max<=image[ui->image_math_raw_image_1->currentText().toInt()-1].width()
                 &&y_min>=0
                 &&y_max<=image[ui->image_math_raw_image_1->currentText().toInt()-1].height()){
                    ui->image_math_x->setText(QString::number(x1));
                    ui->image_math_y->setText(QString::number(y1));
                    ui->image_math_height->setText(QString::number(height1));
                    ui->image_math_width->setText(QString::number(width1));
                    if(Rotate!=-1)
                        ui->image_math_a->setText(QString::number(Rotate%360));
                }else{
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem* raw = new graphicsimageitem(image[ui->image_math_raw_image_1->currentText().toInt()-1]);
                    n_image=image[ui->image_math_raw_image_1->currentText().toInt()-1];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    ROI_add(1,ui->image_math_x->text().toInt(),ui->image_math_y->text().toInt(),ui->image_math_width->text().toInt(),ui->image_math_height->text().toInt(),ui->image_math_a->text().toInt());
                    }
            }else{
                if(x-height/2>=0
                 &&x+height/2<=image[ui->image_math_raw_image_1->currentText().toInt()-1].width()
                 &&y-height/2>=0
                 &&y+height/2<=image[ui->image_math_raw_image_1->currentText().toInt()-1].height()){
                    ui->image_math_x->setText(QString::number(x1));
                    ui->image_math_y->setText(QString::number(y1));
                    ui->image_math_height->setText(QString::number(height1));
                    ui->image_math_width->setText(QString::number(width1));
                }else{
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem* raw = new graphicsimageitem(image[ui->image_math_raw_image_1->currentText().toInt()-1]);
                    n_image=image[ui->image_math_raw_image_1->currentText().toInt()-1];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    ROI_add(2,ui->image_math_x->text().toInt(),ui->image_math_y->text().toInt(),ui->image_math_width->text().toInt(),ui->image_math_height->text().toInt(),0);
                }
            }
        }else{
            if(type==1){
                boundary_position(type,x,y,width,height,Rotate);
                qreal y_max,y_min,x_max,x_min;
                y_max=y_min=boundary[0].y;
                x_max=x_min=boundary[0].x;
                for(int j=1;j<4;j++){
                    if(boundary[j].x>x_max)
                        x_max=boundary[j].x;
                    else if(boundary[j].x<x_min)
                        x_min=boundary[j].x;
                    if(boundary[j].y>y_max)
                        y_max=boundary[j].y;
                    else if(boundary[j].y<y_min)
                        y_min=boundary[j].y;
                }

                if(x_min>=0
                 &&x_max<=image[ui->image_math_raw_image_2->currentText().toInt()-1].width()
                 &&y_min>=0
                 &&y_max<=image[ui->image_math_raw_image_2->currentText().toInt()-1].height()){
                    ui->image_math_2_x->setText(QString::number(x1));
                    ui->image_math_2_y->setText(QString::number(y1));
                }else{
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem* raw = new graphicsimageitem(image[ui->image_math_raw_image_2->currentText().toInt()-1]);
                    n_image=image[ui->image_math_raw_image_2->currentText().toInt()-1];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    ROI_add(1,ui->image_math_2_x->text().toInt(),ui->image_math_2_y->text().toInt(),ui->image_math_width->text().toInt(),ui->image_math_height->text().toInt(),ui->image_math_a->text().toInt());
                    }
            }else{
                if(x-height/2>=0
                 &&x+height/2<=image[ui->image_math_raw_image_2->currentText().toInt()-1].width()
                 &&y-height/2>=0
                 &&y+height/2<=image[ui->image_math_raw_image_2->currentText().toInt()-1].height()){
                    ui->image_math_2_x->setText(QString::number(x1));
                    ui->image_math_2_y->setText(QString::number(y1));
                }else{
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem* raw = new graphicsimageitem(image[ui->image_math_raw_image_2->currentText().toInt()-1]);
                    n_image=image[ui->image_math_raw_image_2->currentText().toInt()-1];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    ROI_add(2,ui->image_math_2_x->text().toInt(),ui->image_math_2_y->text().toInt(),ui->image_math_width->text().toInt(),ui->image_math_height->text().toInt(),0);
                }
            }
        }
    }else if(ui->ordertable->item(c_row,3)->text()=="斑点查找"){
        if(type==1){
            boundary_position(type,x,y,width,height,Rotate);
            qreal y_max,y_min,x_max,x_min;
            y_max=y_min=boundary[0].y;
            x_max=x_min=boundary[0].x;
            for(int j=1;j<4;j++){
                if(boundary[j].x>x_max)
                    x_max=boundary[j].x;
                else if(boundary[j].x<x_min)
                    x_min=boundary[j].x;
                if(boundary[j].y>y_max)
                    y_max=boundary[j].y;
                else if(boundary[j].y<y_min)
                    y_min=boundary[j].y;
            }

            if(x_min>=0
             &&x_max<=image[ui->blob_raw_image->currentText().toInt()-1].width()
             &&y_min>=0
             &&y_max<=image[ui->blob_raw_image->currentText().toInt()-1].height()){
                ui->blob_ROI_x->setText(QString::number(x1));
                ui->blob_ROI_y->setText(QString::number(y1));
                ui->blob_ROI_height->setText(QString::number(height1));
                ui->blob_ROI_width->setText(QString::number(width1));
                if(Rotate!=-1)
                    ui->blob_ROI_a->setText(QString::number(Rotate%360));
            }else{
                QGraphicsScene *scene = new QGraphicsScene;
                graphicsimageitem* raw = new graphicsimageitem(image[ui->blob_raw_image->currentText().toInt()-1]);
                n_image=image[ui->blob_raw_image->currentText().toInt()-1];
                connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                scene->addItem(raw);
                ui->graphicsView->setScene(scene);
                ROI_add(1,ui->blob_ROI_x->text().toInt(),ui->blob_ROI_y->text().toInt(),ui->blob_ROI_width->text().toInt(),ui->blob_ROI_height->text().toInt(),ui->blob_ROI_a->text().toInt());
                }
        }else{
            if(x-height/2>=0
             &&x+height/2<=image[ui->blob_raw_image->currentText().toInt()-1].width()
             &&y-height/2>=0
             &&y+height/2<=image[ui->blob_raw_image->currentText().toInt()-1].height()){
                ui->blob_ROI_x->setText(QString::number(x1));
                ui->blob_ROI_y->setText(QString::number(y1));
                ui->blob_ROI_height->setText(QString::number(height1));
                ui->blob_ROI_width->setText(QString::number(width1));
            }else{
                QGraphicsScene *scene = new QGraphicsScene;
                graphicsimageitem* raw = new graphicsimageitem(image[ui->blob_raw_image->currentText().toInt()-1]);
                n_image=image[ui->blob_raw_image->currentText().toInt()-1];
                connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                scene->addItem(raw);
                ui->graphicsView->setScene(scene);
                ROI_add(2,ui->blob_ROI_x->text().toInt(),ui->blob_ROI_y->text().toInt(),ui->blob_ROI_width->text().toInt(),ui->blob_ROI_height->text().toInt(),0);
            }
        }
    }else if(ui->ordertable->item(c_row,3)->text()=="线查找"){
        boundary_position(type,x,y,width,height,Rotate);
        qreal y_max,y_min,x_max,x_min;
        y_max=y_min=boundary[0].y;
        x_max=x_min=boundary[0].x;
        for(int j=1;j<4;j++){
            if(boundary[j].x>x_max)
                x_max=boundary[j].x;
            else if(boundary[j].x<x_min)
                x_min=boundary[j].x;
            if(boundary[j].y>y_max)
                y_max=boundary[j].y;
            else if(boundary[j].y<y_min)
                y_min=boundary[j].y;
        }

        if(x_min>=0
         &&x_max<=image[ui->line_find_raw_image->currentText().toInt()-1].width()
         &&y_min>=0
         &&y_max<=image[ui->line_find_raw_image->currentText().toInt()-1].height()){
            ui->line_find_x->setText(QString::number(x1));
            ui->line_find_y->setText(QString::number(y1));
            ui->line_find_height->setText(QString::number(height1));
            ui->line_find_width->setText(QString::number(width1));
            if(Rotate!=-1)
                ui->line_find_a->setText(QString::number(Rotate%360));
        }else{
            QGraphicsScene *scene = new QGraphicsScene;
            graphicsimageitem* raw = new graphicsimageitem(image[ui->line_find_raw_image->currentText().toInt()-1]);
            n_image=image[ui->line_find_raw_image->currentText().toInt()-1];
            scene->addItem(raw);
            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
            ui->graphicsView->setScene(scene);
            ROI_add(1,ui->line_find_x->text().toInt(),ui->line_find_y->text().toInt(),ui->line_find_width->text().toInt(),ui->line_find_height->text().toInt(),ui->line_find_a->text().toInt());
            }
    }else if(ui->ordertable->item(c_row,3)->text()=="圆查找"){
        if(x-height/2>=0
         &&x+height/2<=image[ui->Circle_find_raw_image->currentText().toInt()-1].width()
         &&y-height/2>=0
         &&y+height/2<=image[ui->Circle_find_raw_image->currentText().toInt()-1].height()){
            ui->Circle_find_x->setText(QString::number(x1));
            ui->Circle_find_y->setText(QString::number(y1));
            ui->Circle_find_height->setText(QString::number(height1));
            ui->Circle_find_width->setText(QString::number(width1));
        }else{
            QGraphicsScene *scene = new QGraphicsScene;
            graphicsimageitem* raw = new graphicsimageitem(image[ui->Circle_find_raw_image->currentText().toInt()-1]);
            n_image=image[ui->Circle_find_raw_image->currentText().toInt()-1];
            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
            scene->addItem(raw);
            ui->graphicsView->setScene(scene);
            ROI_add(2,ui->Circle_find_x->text().toInt(),ui->Circle_find_y->text().toInt(),ui->Circle_find_width->text().toInt(),ui->Circle_find_height->text().toInt(),0);
        }
    }else if(ui->ordertable->item(c_row,3)->text()=="模板匹配"){
        if(roi==1){
            pattern_changed=true;
            if(type==1){
                boundary_position(type,x,y,width,height,Rotate);
                qreal y_max,y_min,x_max,x_min;
                y_max=y_min=boundary[0].y;
                x_max=x_min=boundary[0].x;
                for(int j=1;j<4;j++){
                    if(boundary[j].x>x_max)
                        x_max=boundary[j].x;
                    else if(boundary[j].x<x_min)
                        x_min=boundary[j].x;
                    if(boundary[j].y>y_max)
                        y_max=boundary[j].y;
                    else if(boundary[j].y<y_min)
                        y_min=boundary[j].y;
                }

                if(x_min>=0
                 &&x_max<=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].width()
                 &&y_min>=0
                 &&y_max<=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].height()){
                    ui->Pattern_find_ROI_x->setText(QString::number(x1));
                    ui->Pattern_find_ROI_y->setText(QString::number(y1));
                    ui->Pattern_find_ROI_height->setText(QString::number(height1));
                    ui->Pattern_find_ROI_width->setText(QString::number(width1));
                    if(Rotate!=-1)
                        ui->Pattern_find_ROI_a->setText(QString::number(Rotate%360));
                }else{
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem* raw = new graphicsimageitem(image[ui->Pattern_find_train_raw_image->currentText().toInt()-1]);
                    n_image=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    ROI_add(1,ui->Pattern_find_ROI_x->text().toInt(),ui->Pattern_find_ROI_y->text().toInt(),ui->Pattern_find_ROI_width->text().toInt(),ui->Pattern_find_ROI_height->text().toInt(),ui->Pattern_find_ROI_a->text().toInt());
                    }
            }else{
                if(x-height/2>=0
                 &&x+height/2<=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].width()
                 &&y-height/2>=0
                 &&y+height/2<=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].height()){
                    ui->Pattern_find_ROI_x->setText(QString::number(x1));
                    ui->Pattern_find_ROI_y->setText(QString::number(y1));
                    ui->Pattern_find_ROI_height->setText(QString::number(height1));
                    ui->Pattern_find_ROI_width->setText(QString::number(width1));
                }else{
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem* raw = new graphicsimageitem(image[ui->Pattern_find_train_raw_image->currentText().toInt()-1]);
                    n_image=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    ROI_add(2,ui->Pattern_find_ROI_x->text().toInt(),ui->Pattern_find_ROI_y->text().toInt(),ui->Pattern_find_ROI_width->text().toInt(),ui->Pattern_find_ROI_height->text().toInt(),0);
                }
            }
        }else{
            if(type==1){
                boundary_position(type,x,y,width,height,Rotate);
                qreal y_max,y_min,x_max,x_min;
                y_max=y_min=boundary[0].y;
                x_max=x_min=boundary[0].x;
                for(int j=1;j<4;j++){
                    if(boundary[j].x>x_max)
                        x_max=boundary[j].x;
                    else if(boundary[j].x<x_min)
                        x_min=boundary[j].x;
                    if(boundary[j].y>y_max)
                        y_max=boundary[j].y;
                    else if(boundary[j].y<y_min)
                        y_min=boundary[j].y;
                }

                if(x_min>=0
                 &&x_max<=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].width()
                 &&y_min>=0
                 &&y_max<=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].height()){
                    ui->Pattern_find_ROI_2_x->setText(QString::number(x1));
                    ui->Pattern_find_ROI_2_y->setText(QString::number(y1));
                    ui->Pattern_find_ROI_2_height->setText(QString::number(height1));
                    ui->Pattern_find_ROI_2_width->setText(QString::number(width1));
                    if(Rotate!=-1)
                        ui->Pattern_find_ROI_2_a->setText(QString::number(Rotate%360));
                }else{
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem* raw = new graphicsimageitem(image[ui->Pattern_find_search_raw_image->currentText().toInt()-1]);
                    n_image=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    ROI_add(1,ui->Pattern_find_ROI_2_x->text().toInt(),ui->Pattern_find_ROI_2_y->text().toInt(),ui->Pattern_find_ROI_2_width->text().toInt(),ui->Pattern_find_ROI_2_height->text().toInt(),ui->Pattern_find_ROI_2_a->text().toInt());
                    }
            }else{
                if(x-height/2>=0
                 &&x+height/2<=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].width()
                 &&y-height/2>=0
                 &&y+height/2<=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].height()){
                    ui->Pattern_find_ROI_2_x->setText(QString::number(x1));
                    ui->Pattern_find_ROI_2_y->setText(QString::number(y1));
                    ui->Pattern_find_ROI_2_height->setText(QString::number(height1));
                    ui->Pattern_find_ROI_2_width->setText(QString::number(width1));
                }else{
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem* raw = new graphicsimageitem(image[ui->Pattern_find_search_raw_image->currentText().toInt()-1]);
                    n_image=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    ROI_add(2,ui->Pattern_find_ROI_2_x->text().toInt(),ui->Pattern_find_ROI_2_y->text().toInt(),ui->Pattern_find_ROI_2_width->text().toInt(),ui->Pattern_find_ROI_2_height->text().toInt(),0);
                }
            }
        }
    }
    changed=true;
    settingchanged();
}


//添加工具原点
void VGRibbonWindow::origin_add(int n,int x,int y)
{
    QGraphicsScene *scene =ui->graphicsView->scene();
    originitem *item=new originitem;
    item->setPos(x,y);
    item->setnumber(n);
    scene->addItem(item);
    connect(item,&originitem::originsignals,this,&VGRibbonWindow::updateOriginPos);
}

//更新工具原点坐标
void VGRibbonWindow::updateOriginPos(QPointF pos,int n)
{
    settingchanged();
    if(n==0){
        ui->origin_x->setText(QString::number(pos.x()));
        ui->origin_y->setText(QString::number(pos.y()));
        QTableWidgetItem *item = new QTableWidgetItem;
        item->setText(ui->origin_x->text());
        ui->ordertable->setItem(c_row,5,item->clone());
        item->setText(ui->origin_y->text());
        ui->ordertable->setItem(c_row,6,item->clone());
    }
}


void VGRibbonWindow::ROI_add_3D(qreal p_x,qreal p_y,qreal p_z,qreal length,qreal width,qreal height)
{
    double l=length/20,w=width/20,h=height/20;
    int i;
    static float x[8][3]={{0,0,0}, {20,0,0}, {20,20,0}, {0,20,0},
                          {0,0,20}, {20,0,20}, {20,20,20}, {0,20,20}};
    static vtkIdType pts[6][4]={{0,1,2,3}, {4,5,6,7}, {0,1,5,4},
                                {1,2,6,5}, {2,3,7,6}, {3,0,4,7}};
    vtkPolyData *cube = vtkPolyData::New();
    //实例化一个点对象points
    vtkPoints *cubePoints = vtkPoints::New();
    //单元对象
    vtkCellArray *polys = vtkCellArray::New();
    // 2021.11.23
    cube->Initialize();
    polys->Initialize();

    // Load the point, cell, and data attributes.
    for (i=0; i<8; i++) cubePoints->InsertPoint(i,x[i]);
    for (i=0; i<6; i++) polys->InsertNextCell(4,pts[i]);//加载每个面由4个点组成的六个面
    cube->SetPoints(cubePoints);//进行点关联
    cube->SetPolys(polys);//进行面关联
//     vtkPolyDataMapper *cubeMapper = vtkPolyDataMapper::New();
    vtkSmartPointer<vtkPolyDataMapper> cubeMapper =vtkSmartPointer<vtkPolyDataMapper>::New();
    cubeMapper->SetInputData(cube);//vtkPolyData数据输出给映射器输入
    vtkSmartPointer<vtkActor>  cubeActor =vtkSmartPointer<vtkActor>::New();
    cubeActor->SetMapper(cubeMapper);
    cubeActor->GetProperty()->SetColor(0.46, 0.46, 0.93);
    cubeActor->GetProperty()->SetOpacity(0.6);
    cubeActor->GetProperty()->SetRepresentationToSurface();
    renderer->AddActor(cubeActor);
    mouseStyle = customMouseInteractorStyle::New();
    mouseStyle->a = cubeActor;
    mouseStyle->rw = renderer;
    mouseStyle->rwi = renderWindowInteractor;
    mouseStyle->a->SetPosition(p_x,p_y,p_z);
    mouseStyle->a->SetScale(l,w,h);
    renderWindowInteractor->SetInteractorStyle(mouseStyle);
//    cubeActor->SetScale(mouseStyle->roiScale);
    connect(mouseStyle,&customMouseInteractorStyle::moveSignal,this,&VGRibbonWindow::update3DItemPos);
    qvtkWidget->update();
//    double* obj_center;
//    obj_center=mouseStyle->a->GetScale();
//    qDebug()<<obj_center[2]*20;

    connect(mouseStyle,&customMouseInteractorStyle::mouseMoveSignal,this,&VGRibbonWindow::show3Dinfo);

}
//更新3d ROI坐标
void VGRibbonWindow::update3DItemPos(double x,double y,double z,double Scalex,double Scaley,double Scalez)
{
    double l=Scalex*20,w=Scaley*20,h=Scalez*20;
    if(ui->ordertable->item(c_row,3)->text()=="找边缘点"){
        ui->point_x->setText(QString::number(x));
        ui->point_y->setText(QString::number(y));
        ui->point_z->setText(QString::number(z));
        ui->point_w->setText(QString::number(w));
        ui->point_l->setText(QString::number(l));
        ui->point_h->setText(QString::number(h));
        point_ROI_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="找拐点"){
        ui->turning_x->setText(QString::number(x));
        ui->turning_y->setText(QString::number(y));
        ui->turning_z->setText(QString::number(z));
        ui->turning_w->setText(QString::number(w));
        ui->turning_l->setText(QString::number(l));
        ui->turning_h->setText(QString::number(h));
        turning_ROI_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="找线"){
        ui->line_x->setText(QString::number(x));
        ui->line_y->setText(QString::number(y));
        ui->line_z->setText(QString::number(z));
        ui->line_w->setText(QString::number(w));
        ui->line_l->setText(QString::number(l));
        ui->line_h->setText(QString::number(h));
        line_ROI_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="找面"){
        ui->plane_x->setText(QString::number(x));
        ui->plane_y->setText(QString::number(y));
        ui->plane_z->setText(QString::number(z));
        ui->plane_w->setText(QString::number(w));
        ui->plane_l->setText(QString::number(l));
        ui->plane_h->setText(QString::number(h));
        plane_ROI_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="找质心"){
        ui->Centroid_x->setText(QString::number(x));
        ui->Centroid_y->setText(QString::number(y));
        ui->Centroid_z->setText(QString::number(z));
        ui->Centroid_w->setText(QString::number(w));
        ui->Centroid_l->setText(QString::number(l));
        ui->Centroid_h->setText(QString::number(h));
        Centroid_ROI_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="裁切"){
        ui->getcloud_x->setText(QString::number(x));
        ui->getcloud_y->setText(QString::number(y));
        ui->getcloud_z->setText(QString::number(z));
        ui->getcloud_w->setText(QString::number(w));
        ui->getcloud_l->setText(QString::number(l));
        ui->getcloud_h->setText(QString::number(h));
        getcloud_ROI_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="拟合圆柱"){
        ui->cylinderSegment_x->setText(QString::number(x));
        ui->cylinderSegment_y->setText(QString::number(y));
        ui->cylinderSegment_z->setText(QString::number(z));
        ui->cylinderSegment_w->setText(QString::number(w));
        ui->cylinderSegment_l->setText(QString::number(l));
        ui->cylinderSegment_h->setText(QString::number(h));
        cylinderSegment_ROI_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="平整度"){
        ui->planeness_x->setText(QString::number(x));
        ui->planeness_y->setText(QString::number(y));
        ui->planeness_z->setText(QString::number(z));
        ui->planeness_w->setText(QString::number(w));
        ui->planeness_l->setText(QString::number(l));
        ui->planeness_h->setText(QString::number(h));
        planeness_ROI_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="截面积"){
        ui->outline_x->setText(QString::number(x));
        ui->outline_y->setText(QString::number(y));
        ui->outline_z->setText(QString::number(z));
        ui->outline_w->setText(QString::number(w));
        ui->outline_l->setText(QString::number(l));
        ui->outline_h->setText(QString::number(h));
        outline_ROI_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="锚定"){
        ui->Anchor_x->setText(QString::number(x));
        ui->Anchor_y->setText(QString::number(y));
        ui->Anchor_z->setText(QString::number(z));
        Anchor_setting_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="线到面"){
        ui->line_plane_x->setText(QString::number(x));
        ui->line_plane_y->setText(QString::number(y));
        ui->line_plane_z->setText(QString::number(z));
        line_plane_setting_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="面到面"){
        ui->plane_plane_x->setText(QString::number(x));
        ui->plane_plane_y->setText(QString::number(y));
        ui->plane_plane_z->setText(QString::number(z));
        plane_plane_setting_change();
    }else if(ui->ordertable->item(c_row,3)->text()=="3d斑点高度"){
        ui->Blob_3d_x->setText(QString::number(x));
        ui->Blob_3d_y->setText(QString::number(y));
        ui->Blob_3d_z->setText(QString::number(z));
        ui->Blob_3d_w->setText(QString::number(w));
        ui->Blob_3d_l->setText(QString::number(l));
        ui->Blob_3d_h->setText(QString::number(h));
        Blob_3d_ROI_change();
    }
}

//添加3D锚点
void VGRibbonWindow::origin_add_3D(qreal p_x,qreal p_y,qreal p_z)
{
    vtkSmartPointer<vtkSphereSource> sphereSourceA = vtkSmartPointer<vtkSphereSource>::New();
    sphereSourceA->SetCenter(0,0,0);
    sphereSourceA->SetRadius(0.4);
    sphereSourceA->Update();
    vtkSmartPointer<vtkPolyDataMapper> sphereMapperA = vtkSmartPointer<vtkPolyDataMapper>::New();
    sphereMapperA->SetInputConnection(sphereSourceA->GetOutputPort());
    // create an actor
    vtkSmartPointer<vtkLODActor> sphereActorA = vtkSmartPointer<vtkLODActor>::New();
    sphereActorA->SetMapper(sphereMapperA);
    sphereActorA->GetProperty()->SetColor(1, 0, 0);
//    sphereActor->SetScale(1.0, 1, 1);
    renderer->AddActor(sphereActorA);
    mouseStyle = customMouseInteractorStyle::New();
    mouseStyle->a = sphereActorA;
    mouseStyle->rw = renderer;
    mouseStyle->changesize = false;
    mouseStyle->rwi = renderWindowInteractor;
    mouseStyle->a->SetPosition(p_x,p_y,p_z);
    renderWindowInteractor->SetInteractorStyle(mouseStyle);
    connect(mouseStyle,&customMouseInteractorStyle::moveSignal,this,&VGRibbonWindow::update3DItemPos);
    connect(mouseStyle,&customMouseInteractorStyle::mouseMoveSignal,this,&VGRibbonWindow::show3Dinfo);
}

//计算边界坐标
void VGRibbonWindow::boundary_position(int type,qreal x,qreal y,qreal width,qreal height,qreal a){
    qreal mid_x=x+width/2,mid_y=y+height/2;
    double rotate=a;
    rotate=(rotate)/180*M_PI;
    qreal s = qSin(rotate) * 0.5;
    qreal c = qCos(rotate) * 0.5;
    qreal W=width,H=height;
    if(type==1){
        boundary[0].setPoint(mid_x + s * H- c * W, mid_y - c * H- s * W);
        boundary[2].setPoint(2 * mid_x - boundary[0].x, 2*mid_y - boundary[0].y);
        boundary[3].setPoint(mid_x - s * H- c * W, mid_y + c * H- s * W);
        boundary[1].setPoint(2*mid_x - boundary[3].x, 2*mid_y - boundary[3].y);
        boundary[1].setPoint(boundary[1].x-1, boundary[1].y);
        boundary[2].setPoint(boundary[2].x-1, boundary[2].y-1);
        boundary[3].setPoint(boundary[3].x, boundary[3].y-1);
    }else{
        boundary[0].setPoint(x,y);
        boundary[1].setPoint(x-height/2,y-height/2);
        boundary[2].setPoint(x-width/2,y-width/2);
    }
    //qDebug()<<boundary[0]<<boundary[1]<<boundary[2]<<boundary[3];
}

//运行
void VGRibbonWindow::on_pushButton_clicked()
{
    //清空输出栏
    ui->out_list->clear();
    ui->variable_list->clear();
    ui->variable_list->close();
    ui->expansion->setText("⮝");
    //若步骤栏为空结束
    if(ui->ordertable->rowCount()==0)
        return;
    pattern_changed=true;
//    QTreeWidgetItem *item=new QTreeWidgetItem;
//    item->setText(0,"result");
//    ui->out_list->addTopLevelItem(item);
    QTreeWidgetItem *itemi=new QTreeWidgetItem;
    //按步骤栏逐行运行
    for(int i =0;i<ui->ordertable->rowCount();i++){
        //跳过不启用项
        if(ui->ordertable->item(i,0)->text()=="off")
            continue;
        c_row=i;
        //设置部分输出内容
        itemi->setText(0,QString::number(c_row+1));
        itemi->setText(1,ui->ordertable->item(c_row,3)->text());
        //判断当前步骤执行内容
        if(ui->ordertable->item(c_row,3)->text()=="选择图像"){
            openimagepath=ui->ordertable->item(c_row,4)->text();
            if(openimagepath!=""){
                ui->origin_x->setText(ui->ordertable->item(c_row,5)->text());
                ui->origin_y->setText(ui->ordertable->item(c_row,6)->text());
                ui->image_rotate->setText(ui->ordertable->item(c_row,7)->text());
                QElapsedTimer  mstimer;
                mstimer.start();
                image[c_row].load(openimagepath);
                if(image[c_row].isNull()){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图像读取失败");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }else{
                    on_image_rotate_editingFinished();
                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *timei = new QTableWidgetItem;
                    timei->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,timei);
                    itemi->setText(2,"尺寸:("+QString::number(image[c_row].width())+","+QString::number(image[c_row].height())+"),"+ui->image_rotate->text()+"°");
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="二值化图像"){
            image[c_row]=empty_image;
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_image;
                bool Adaptive;
                QString upper_threshold,lower_threshold,forecolor,backcolor;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QString order_type=ui->ordertable->item(c_row,8)->text();
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                int type;
                YZVision::Basic2D::PointXY bounary[4];
                  if(order_s.size()==6&&order_position.size()==5){
                    for(int i=0;i<order_s.size();i++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw_image"){
                            raw_image=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                            if(image[raw_image].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="Adaptive"){
                            if(s_data.at(1)=="true")
                                Adaptive=true;
                            else
                                Adaptive=false;
                        }else if(s_data.at(0)=="upper_threshold")
                            upper_threshold=s_data.at(1);
                        else if(s_data.at(0)=="lower_threshold")
                            lower_threshold=s_data.at(1);
                        else if(s_data.at(0)=="forecolor")
                            forecolor=s_data.at(1);
                        else if(s_data.at(0)=="backcolor")
                            backcolor=s_data.at(1);
                    }
                    if(raw_image!=-1){
                        if(order_type=="矩形")
                            type=1;
                        else
                            type=2;
                        int x,y,height,width,rotate;
                        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                        width=order_position.at(2).toInt();
                        if(width==0)
                            width=image[raw_image].width();
                        height=order_position.at(3).toInt();
                        if(height==0)
                            height=image[raw_image].height();
                        rotate=order_position.at(4).toInt();
                        boundary_position(type,x,y,width,height,rotate);
                        for(int j=0;j<4;j++){
                            bounary[j]=boundary[j];
                        }
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        int result;
                        Mat raw=Image2cvMat(image[raw_image].toImage());
                        YZVision::Binary_2D binary;
                        YZVision::Binary_2D::InputParam input= YZVision::Binary_2D::InputParam();
                        YZVision::Binary_2D::OutputParam output= YZVision::Binary_2D::OutputParam();
                        input.raw=raw;
                        input.Adaptive=Adaptive;
                        input.upper=upper_threshold.toInt();
                        input.lower=lower_threshold.toInt();
                        input.forecolor=forecolor.toInt();
                        input.backcolor=backcolor.toInt();
                        input.type=type;
                                      for(int j=0;j<4;j++){
                            input.position[j]=bounary[j];
                        }

                        result=binary.Binary(input,&output);
                        image[c_row]=QPixmap::fromImage(cvMat2Image(output.res));
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        if(type==1)
                            itemi->setText(2,"矩形ROI坐标("+QString::number(x)+","+QString::number(y)+"),角度"+QString::number(rotate)+"°"+",尺寸["+QString::number(width)+","+QString::number(height)+"]");
                        else
                            itemi->setText(2,"ROI圆心("+QString::number(x)+","+QString::number(y)+")"+",直径"+QString::number(height));
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="膨胀/腐蚀"){
            image[c_row]=empty_image;
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_image;
                bool expansion;
                QString Iteration_time;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QString order_type=ui->ordertable->item(c_row,8)->text();
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                int type;
                YZVision::Basic2D::PointXY bounary[4];
                if(order_s.size()==3&&order_position.size()==5){
                    for(int i=0;i<order_s.size();i++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw_image"){
                            raw_image=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                            if(image[raw_image].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="Expansion"){
                            if(s_data.at(1)=="true")
                                expansion=true;
                            else
                                expansion=false;
                        }else if(s_data.at(0)=="Iteration_time")
                           Iteration_time=s_data.at(1);
                    }
                    if(raw_image!=-1){
                        if(order_type=="矩形")
                            type=1;
                        else
                            type=2;
                        int x,y,height,width,rotate;
                        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                        width=order_position.at(2).toInt();
                        if(width==0)
                            width=image[raw_image].width();
                        height=order_position.at(3).toInt();
                        if(height==0)
                            height=image[raw_image].height();
                        rotate=order_position.at(4).toInt();
                        boundary_position(type,x,y,width,height,rotate);
                        for(int j=0;j<4;j++){
                            bounary[j]=boundary[j];
                        }
                        int result;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        Mat raw=Image2cvMat(image[raw_image].toImage());
                        YZVision::Morphology_2D Expansion;
                        YZVision::Morphology_2D::InputParam input= YZVision::Morphology_2D::InputParam();
                        YZVision::Morphology_2D::OutputParam output= YZVision::Morphology_2D::OutputParam();
                        input.raw=raw;
                        input.Iteration_time=Iteration_time.toInt();
                        input.type=type;
                        for(int j=0;j<4;j++){
                            input.position[j]=bounary[j];
                        }

                        if(expansion){
                            result=Expansion.Expansion(input,&output);
                        }else{
                            result=Expansion.Corrosion(input,&output);
                        }
                        image[c_row]=QPixmap::fromImage(cvMat2Image(output.res));
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        if(type==1)
                            itemi->setText(2,"矩形ROI坐标("+QString::number(x)+","+QString::number(y)+"),角度"+QString::number(rotate)+"°"+",尺寸["+QString::number(width)+","+QString::number(height)+"]");
                        else
                            itemi->setText(2,"ROI圆心("+QString::number(x)+","+QString::number(y)+")"+",直径"+QString::number(height));
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="图像运算"){
            image[c_row]=empty_image;
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_image_1,raw_image_2;
                QString add_1,add_2,operation;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QString order_type=ui->ordertable->item(c_row,8)->text();
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                int type;
                YZVision::Basic2D::PointXY bounary[8];
                if(order_s.size()==5&&order_position.size()==8){
                    for(int i=0;i<order_s.size();i++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw_image_1"){
                            raw_image_1=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image_1,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源1已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image_1=-1;
                                break;
                            }
                            if(image[raw_image_1].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image_1=-1;
                                break;
                            }
                        }if(s_data.at(0)=="raw_image_2"){
                            raw_image_2=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image_2,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image_2=-1;
                                break;
                            }
                            if(image[raw_image_2].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image_2=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="operation"){
                            operation=s_data.at(1);;
                        }else if(s_data.at(0)=="add_1")
                           add_1=s_data.at(1);
                        else if(s_data.at(0)=="add_2")
                           add_2=s_data.at(1);
                    }
                    if(raw_image_1!=-1&&raw_image_2!=-1){
                        if(order_type=="矩形")
                            type=1;
                        else
                            type=2;
                        int x,y,height,width,rotate,x2,y2,a;
                        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                        width=order_position.at(2).toInt();
                        if(width==0)
                            width=image[raw_image_1].width();
                        height=order_position.at(3).toInt();
                        if(height==0)
                            height=image[raw_image_1].height();
                        rotate=order_position.at(4).toInt();
                        boundary_position(type,x,y,width,height,rotate);
                        x2=order_position.at(5).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                        y2=order_position.at(6).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                        a=order_position.at(7).toInt();
                        for(int j=0;j<4;j++){
                            bounary[j]=boundary[j];
                        }
                        boundary_position(type,x2,y2,width,height,a);
                        for(int j=0;j<4;j++){
                            bounary[4+j]=boundary[j];
                        }
                        int result;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        Mat raw1=Image2cvMat(image[raw_image_1].toImage());
                        Mat raw2=Image2cvMat(image[raw_image_2].toImage());
                        YZVision::Math_2D image_math;
                        YZVision::Math_2D::InputParam input= YZVision::Math_2D::InputParam();
                        YZVision::Math_2D::OutputParam output= YZVision::Math_2D::OutputParam();
                        input.Operands=raw1;
                        input.Operand=raw2;
                        input.add_1=add_1.toFloat();
                        input.add_2=add_2.toFloat();
                        input.operation=operation.toStdString();
                        input.type=type;
                        for(int j=0;j<8;j++){
                            input.position[j]=bounary[j];
                        }

                        result=image_math.imageMath(input,&output);
                        image[c_row]=QPixmap::fromImage(cvMat2Image(output.res));

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        if(type==1)
                            itemi->setText(2,"矩形ROI坐标("+QString::number(x)+","+QString::number(y)+"),角度"+QString::number(rotate)+"°"+",尺寸["+QString::number(width)+","+QString::number(height)+"]#"+
                                           "矩形ROI坐标("+QString::number(x2)+","+QString::number(y2)+"),角度"+QString::number(rotate)+"°"+",尺寸["+QString::number(width)+","+QString::number(height)+"]");
                        else
                            itemi->setText(2,"ROI圆心("+QString::number(x)+","+QString::number(y)+")"+",直径"+QString::number(height)+"#"+
                                           "ROI圆心("+QString::number(x2)+","+QString::number(y2)+"),直径"+QString::number(height));
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="斑点查找"){
            image[c_row]=empty_image;
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_image;
                bool border,fill,width_f,height_f,area,number;
                int type,threshold_lower,threshold_upper,width_f_min,width_f_max,height_f_min,height_f_max,area_min,area_max,number_min,number_max;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QString order_type=ui->ordertable->item(c_row,8)->text();
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                int type_p;
                YZVision::Basic2D::PointXY bounary[4];
                if(order_s.size()==18&&order_position.size()==5){
                    for(int i=0;i<order_s.size();i++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw_image"){
                            raw_image=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                            if(image[raw_image].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                        }if(s_data.at(0)=="type"){
                            type=s_data.at(1).toInt();
                        }else if(s_data.at(0)=="threshold_lower"){
                            threshold_lower=s_data.at(1).toInt();
                        }else if(s_data.at(0)=="threshold_upper")
                           threshold_upper=s_data.at(1).toInt();
                        else if(s_data.at(0)=="border")
                           if(s_data.at(1)=="true"){
                               border=true;
                           }else{
                               border=false;
                           }
                        else if(s_data.at(0)=="fill")
                           if(s_data.at(1)=="true"){
                               fill=true;
                           }else{
                               fill=false;
                           }
                        else if(s_data.at(0)=="width_f")
                           if(s_data.at(1)=="true"){
                               width_f=true;
                           }else{
                               width_f=false;
                           }
                        else if(s_data.at(0)=="width_f_min")
                            width_f_min=s_data.at(1).toInt();
                        else if(s_data.at(0)=="width_f_max")
                            width_f_max=s_data.at(1).toInt();
                        else if(s_data.at(0)=="height_f")
                           if(s_data.at(1)=="true"){
                               height_f=true;
                           }else{
                               height_f=false;
                           }
                        else if(s_data.at(0)=="height_f_min")
                            height_f_min=s_data.at(1).toInt();
                        else if(s_data.at(0)=="height_f_max")
                            height_f_max=s_data.at(1).toInt();
                        else if(s_data.at(0)=="area")
                           if(s_data.at(1)=="true"){
                               area=true;
                           }else{
                               area=false;
                           }
                        else if(s_data.at(0)=="area_min")
                            area_min=s_data.at(1).toInt();
                        else if(s_data.at(0)=="area_max")
                            area_max=s_data.at(1).toInt();
                        else if(s_data.at(0)=="number")
                           if(s_data.at(1)=="true"){
                               number=true;
                           }else{
                               number=false;
                           }
                        else if(s_data.at(0)=="number_min")
                            number_min=s_data.at(1).toInt();
                        else if(s_data.at(0)=="number_max")
                            number_max=s_data.at(1).toInt();
                    }
                    if(raw_image!=-1){
                        if(order_type=="矩形")
                            type_p=1;
                        else
                            type_p=2;
                        int x,y,height,width,rotate;
                        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                        width=order_position.at(2).toInt();
                        if(width==0)
                            width=image[raw_image].width();
                        height=order_position.at(3).toInt();
                        if(height==0)
                            height=image[raw_image].height();
                        rotate=order_position.at(4).toInt();
                        boundary_position(type_p,x,y,width,height,rotate);
                        for(int j=0;j<4;j++){
                            bounary[j]=boundary[j];
                        }
                        int resu;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        Mat raw=Image2cvMat(image[raw_image].toImage());
                        YZVision::FindBlob_2D blob;
                        YZVision::FindBlob_2D::InputParam input= YZVision::FindBlob_2D::InputParam();
                        YZVision::FindBlob_2D::OutputParam result= YZVision::FindBlob_2D::OutputParam();
                        input.raw=raw;
                        input.threshold_lower=threshold_lower;
                        input.threshold_upper=threshold_upper;
                        input.type=type;
                        input.border=border;
                        input.fill=fill;
                        input.type_p=type_p;
                        for(int j=0;j<4;j++){
                            input.position[j]=bounary[j];
                        }
                        input.width_f=width_f;
                        input.width_f_min=width_f_min;
                        input.width_f_max=width_f_max;
                        input.height_f=height_f;
                        input.height_f_min=height_f_min;
                        input.height_f_max=height_f_max;
                        input.area=area;
                        input.area_min=area_min;
                        input.area_max=area_max;
                        input.number=number;
                        input.number_min=number_min;
                        input.number_max=number_max;

                        resu=blob.FindBlob(input,&result);
                        image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        QString c="",n;
                        std::vector<std::vector <float>> temp;
                        if(result.areas.size()>0){
                            for(unsigned long long z=0;z<result.areas.size()-1;z++){
                                c+="宽度"+QString::number(result.widths[z])+" ";
                                c+="高度"+QString::number(result.heights[z])+" ";
                                c+="面积"+QString::number(result.areas[z])+" ";
                                for(unsigned long long x=0;x<result.resContours[z].size()-1;x++ )
                                    c+="("+QString::number(result.resContours[z][x].x)+","+QString::number(result.resContours[z][x].y)+")|";
                                c+="("+QString::number(result.resContours[z][result.resContours[z].size()-1].x)+","+QString::number(result.resContours[z][result.resContours[z].size()-1].y)+")";
                                c+="#";
                                std::vector <float> temp_widths;
                                temp_widths.push_back(result.widths[z]);
                                temp_widths.push_back(result.heights[z]);
                                temp_widths.push_back(result.areas[z]);
                                temp.push_back(temp_widths);
                                std::vector <float> temp_points;
                                for(unsigned long long x=0;x<result.resContours[z].size();x++){
                                    temp_points.push_back(result.resContours[z][x].x);
                                    temp_points.push_back(result.resContours[z][x].y);
                                }
                                temp.push_back(temp_points);
                            }
                            unsigned long long z=result.areas.size()-1;
                            c+="宽度"+QString::number(result.widths[z])+" ";
                            c+="高度"+QString::number(result.heights[z])+" ";
                            c+="面积"+QString::number(result.areas[z])+" ";
                            for(unsigned long long x=0;x<result.resContours[z].size()-1;x++ )
                                c+="("+QString::number(result.resContours[z][x].x)+","+QString::number(result.resContours[z][x].y)+")|";
                            c+="("+QString::number(result.resContours[z][result.resContours[z].size()-1].x)+","+QString::number(result.resContours[z][result.resContours[z].size()-1].y)+")";
                            std::vector <float> temp_widths;
                            temp_widths.push_back(result.widths[z]);
                            temp_widths.push_back(result.heights[z]);
                            temp_widths.push_back(result.areas[z]);
                            temp.push_back(temp_widths);
                            std::vector <float> temp_points;
                            for(unsigned long long x=0;x<result.resContours[z].size();x++){
                                temp_points.push_back(result.resContours[z][x].x);
                                temp_points.push_back(result.resContours[z][x].y);
                            }
                            temp.push_back(temp_points);
                        }else{
                            c="未找到匹配项";
                        }
                        res[c_row]=temp;
                        itemi->setText(2,c);
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="线查找"){
            image[c_row]=empty_image;
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_image;
                int threshold_lower,threshold_upper,type,border,ratio,Subpixel;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                YZVision::Basic2D::PointXY bounary[4];
                if(order_s.size()==7&&order_position.size()==5){
                    for(int i=0;i<order_s.size();i++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw_image"){
                            raw_image=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                            if(image[raw_image].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="threshold_lower"){
                            threshold_lower=s_data.at(1).toInt();
                        }else if(s_data.at(0)=="threshold_upper")
                           threshold_upper=s_data.at(1).toInt();
                        else if(s_data.at(0)=="type")
                            type=s_data.at(1).toInt();
                        else if(s_data.at(0)=="border")
                            border=s_data.at(1).toInt();
                        else if(s_data.at(0)=="ratio")
                            ratio=s_data.at(1).toInt();
                        else if(s_data.at(0)=="Subpixel")
                            Subpixel=s_data.at(1).toInt();
                    }
                    if(raw_image!=-1){
                        int x,y,height,width,rotate;
                        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                        width=order_position.at(2).toInt();
                        if(width==0)
                            width=image[raw_image].width();
                        height=order_position.at(3).toInt();
                        if(height==0)
                            height=image[raw_image].height();
                        rotate=order_position.at(4).toInt();
                        boundary_position(1,x,y,width,height,rotate);
                        for(int j=0;j<4;j++){
                            bounary[j]=boundary[j];
                        }
                        int resu;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        Mat raw=Image2cvMat(image[raw_image].toImage());
                        YZVision::FindLine_2D line_find;
                        YZVision::FindLine_2D::InputParam input= YZVision::FindLine_2D::InputParam();
                        YZVision::FindLine_2D::OutputParam result= YZVision::FindLine_2D::OutputParam();
                        input.raw=raw;
                        input.threshold_lower=threshold_lower;
                        input.threshold_upper=threshold_upper;
                        input.type=type;
                        input.border=border;
                        input.ratio=ratio;
                        input.subpixel=Subpixel;
                        for(int j=0;j<4;j++){
                            input.position[j]=bounary[j];
                        }
                        resu=line_find.FindLine(input,&result);
                        image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        QString c="",n;
                        if(result.code==0){
                            double x1,x2,y1,y2,t,a;
                            x1=result.l.a.x;
                            y1=result.l.a.y;
                            x2=result.l.b.x;
                            y2=result.l.b.y;
                            t=sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
                            a=atan2((y1-y2),(x2-x1));
                            a=a*180/M_PI;
                            c+="长度"+QString::number(t)+",角度"+QString::number(a)+"° (";
                            c+="起始点"+QString::number(x1)+","+QString::number(y1)+"),终点("+QString::number(x2)+","+QString::number(y2)+")";
                            std::vector<std::vector <float>> temp;
                            std::vector <float> temp_start;
                            temp_start.push_back(result.l.a.x);
                            temp_start.push_back(result.l.a.y);
                            temp.push_back(temp_start);
                            std::vector <float> temp_end;
                            temp_end.push_back(result.l.b.x);
                            temp_end.push_back(result.l.b.y);
                            temp.push_back(temp_end);
                            std::vector <float> samplePts;
                            for(unsigned long long z=0;z<result.samplePts.size();z++){
                                samplePts.push_back(result.samplePts[z].x);
                                samplePts.push_back(result.samplePts[z].y);
                            }
                            temp.push_back(samplePts);
                            res[c_row]=temp;
                        }else{
                            c="未找到匹配项";
                        }
                        itemi->setText(2,c);
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="圆查找"){
            image[c_row]=empty_image;
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_image;
                int threshold_lower,threshold_upper,type,border,ratio,ratio_min,ratio_max;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                YZVision::Basic2D::PointXY bounary[4];
                if(order_s.size()==8&&order_position.size()==5){
                    for(int i=0;i<order_s.size();i++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw_image"){
                            raw_image=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                            if(image[raw_image].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="threshold_lower"){
                            threshold_lower=s_data.at(1).toInt();
                        }else if(s_data.at(0)=="threshold_upper")
                           threshold_upper=s_data.at(1).toInt();
                        else if(s_data.at(0)=="type")
                            type=s_data.at(1).toInt();
                        else if(s_data.at(0)=="border")
                            border=s_data.at(1).toInt();
                        else if(s_data.at(0)=="ratio")
                            ratio=s_data.at(1).toInt();
                        else if(s_data.at(0)=="ratio_min")
                            ratio_min=s_data.at(1).toInt();
                        else if(s_data.at(0)=="ratio_max")
                            ratio_max=s_data.at(1).toInt();
                    }
                    if(raw_image!=-1){
                        int x,y,height,width;
                        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                        width=order_position.at(2).toInt();
                        if(width==0)
                            width=image[raw_image].width();
                        height=order_position.at(3).toInt();
                        if(height==0)
                            height=image[raw_image].height();
                        boundary_position(2,x,y,width,height,0);
                        for(int j=0;j<4;j++){
                            bounary[j]=boundary[j];
                        }
                        int resu;
                        float c1,c2;
                        c1=bounary[0].x-bounary[2].x;
                        c2=bounary[0].x-bounary[1].x;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        Mat raw=Image2cvMat(image[raw_image].toImage());
                        YZVision::FindCircle_2D Circle_find;
                        YZVision::FindCircle_2D::InputParam input= YZVision::FindCircle_2D::InputParam();
                        YZVision::FindCircle_2D::OutputParam result= YZVision::FindCircle_2D::OutputParam();
                        input.raw=raw;
                        input.threshold_lower=threshold_lower;
                        input.threshold_upper=threshold_upper;
                        input.type=type;
                        input.border=border;
                        input.ratio=ratio;
                        input.radius_min=ratio_min;
                        input.radius_max=ratio_max;
                        input.circleCenter=bounary[0];
                        input.innerRadius=c1;
                        input.outerRadius=c2;

                        resu=Circle_find.FindCircle(input,&result);
                        image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        QString c="",n;
                        if(result.code==0){
                            std::vector<std::vector <float>> temp;
                            std::vector <float> temp_cir1;
                            temp_cir1.push_back(result.circle1.x);
                            temp_cir1.push_back(result.circle1.y);
                            temp_cir1.push_back(result.circle1.r);
                            temp.push_back(temp_cir1);
                            std::vector <float> temp_samplePts;
                            for(long long z=0;z<result.samplePts.size();z++){
                                temp_samplePts.push_back(result.samplePts[z].x());
                                temp_samplePts.push_back(result.samplePts[z].y());
                            }
                            temp.push_back(temp_samplePts);
                            c+="圆心("+QString::number(result.circle1.x)+","+QString::number(result.circle1.y)+")半径"+QString::number(result.circle1.r);
                            if(type>3){
                                c+="#内圆心("+QString::number(result.circle2.x)+","+QString::number(result.circle2.y)+")半径"+QString::number(result.circle2.r);
                                std::vector <float> temp_cir2;
                                temp_cir2.push_back(result.circle2.x);
                                temp_cir2.push_back(result.circle2.y);
                                temp_cir2.push_back(result.circle2.r);
                                temp.push_back(temp_cir2);
                                std::vector <float> temp_samplePts2;
                                for(long long z=0;z<result.samplePts2.size();z++){
                                    temp_samplePts2.push_back(result.samplePts2[z].x());
                                    temp_samplePts2.push_back(result.samplePts2[z].y());
                                }
                                temp.push_back(temp_samplePts2);
                            }
                            res[c_row]=temp;
                        }else{
                            c="未找到匹配项";
                        }
                        itemi->setText(2,c);
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="模板匹配"){
            image[c_row]=empty_image;
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_type=ui->ordertable->item(c_row,8)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                int raw_image,raw_image2;
                int rotate,rotate_min,rotate_max,zoom;
                qreal zoom_min,zoom_max;
                int type,type1,type2;
                int score,number;
                int x,y,width,height,roi_a,x2,y2,width2,height2,roi_a2;
                YZVision::Basic2D::PointXY bounary[8];
                if(order_s.size()==11&&order_position.size()==10){
                    for(int i=0;i<order_s.size();i++){
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw_image_1"){
                            raw_image=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源1已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                            if(image[raw_image].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源1为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                        }if(s_data.at(0)=="raw_image_2"){
                            raw_image2=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image2,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                            if(image[raw_image2].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_image=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="rotate")
                            rotate=s_data.at(1).toInt();
                        else if(s_data.at(0)=="rotate_min")
                            rotate_min=s_data.at(1).toInt();
                        else if(s_data.at(0)=="rotate_max")
                            rotate_max=s_data.at(1).toInt();
                        else if(s_data.at(0)=="zoom")
                            zoom=s_data.at(1).toInt();
                        else if(s_data.at(0)=="zoom_min")
                            zoom_min=s_data.at(1).toDouble();
                        else if(s_data.at(0)=="zoom_max")
                            zoom_max=s_data.at(1).toDouble();
                        else if(s_data.at(0)=="type")
                            type=s_data.at(1).toInt();
                        else if(s_data.at(0)=="search")
                            score=s_data.at(1).toInt();
                        else if(s_data.at(0)=="number")
                            number=s_data.at(1).toInt();
                    }
                    if(raw_image!=-1){
                        if(order_type.at(0)=="矩形")
                            type1=1;
                        else
                            type1=2;
                        if(order_type.at(1)=="矩形")
                            type2=1;
                        else
                            type2=2;
                        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                        width=order_position.at(2).toInt();
                        if(width==0)
                            width=image[raw_image].width();

                        height=order_position.at(3).toInt();
                        if(height==0)
                            height=image[raw_image].height();
                        roi_a=order_position.at(4).toInt();

                        x2=order_position.at(5).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                        y2=order_position.at(6).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                        width2=order_position.at(7).toInt();
                        if(width2==0)
                            width2=image[raw_image2].width();
                        height2=order_position.at(8).toInt();
                        if(height2==0)
                            height2=image[raw_image2].height();
                        roi_a2=order_position.at(9).toInt();
                        boundary_position(type1,x,y,width,height,roi_a);
                        for(int j=0;j<4;j++){
                            bounary[j]=boundary[j];
                        }
                        boundary_position(type2,x2,y2,width2,height2,roi_a2);
                        for(int j=0;j<4;j++){
                            bounary[4+j]=boundary[j];
                        }
                        int resu;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        Mat raw1=Image2cvMat(image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].toImage());
                        Mat raw2=Image2cvMat(image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].toImage());
                        YZVision::MatchTemplate_2D Pattern;
                        YZVision::MatchTemplate_2D::InputParam input= YZVision::MatchTemplate_2D::InputParam();
                        YZVision::MatchTemplate_2D::OutputParam result= YZVision::MatchTemplate_2D::OutputParam();
                        input.train_changed=pattern_changed;
                        input.train=raw1;
                        input.search=raw2;
                        input.rotate=ui->Pattern_find_rotate->currentIndex();
                        input.rotate_min=ui->Pattern_find_rotate_min->text().toInt();
                        input.rotate_max=ui->Pattern_find_rotate_max->text().toInt();
                        input.zoom=ui->Pattern_find_zoom->currentIndex();
                        input.zoom_min=ui->Pattern_find_zoom_min->text().toDouble();
                        input.zoom_max=ui->Pattern_find_zoom_max->text().toInt();
                        input.type=ui->Pattern_find_type->currentIndex();
                        input.scores=ui->Pattern_find_min_search->text().toInt();
                        input.number=number;
                        input.type1=type1;
                        input.type2=type2;
                        for(int j=0;j<8;j++){
                            input.position[j]=bounary[j];
                        }
                        resu=Pattern.MatchTemplate(input,&result);

                        image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;

                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        QString c="";
                        std::vector<std::vector <float>> temp;
                        if(!result.code){
                            if(result.tems.size()>1){
                                for(int z=0;z<result.tems.size()-1;z++){
                                    c+="坐标("+QString::number(result.tems[z].x)+","+QString::number(result.tems[z].y)+") ";
                                    c+="相似性"+QString::number(result.tems[z].similarity)+" ";
//                                    c+="尺寸"+QString::number(result.tems[z].w)+"X"+QString::number(result.tems[z].h)+" ";
                                    c+="角度"+QString::number(result.tems[z].angle)+" ";
                                    c+="缩放比"+QString::number(result.tems[z].scale)+"#";
                                    std::vector <float> temp_size;
                                    temp_size.push_back(result.tems[z].x);
                                    temp_size.push_back(result.tems[z].y);
                                    temp_size.push_back(result.tems[z].similarity);
                                    temp_size.push_back(result.tems[z].w);
                                    temp_size.push_back(result.tems[z].h);
                                    temp_size.push_back(result.tems[z].angle);
                                    temp_size.push_back(result.tems[z].scale);
                                    temp.push_back(temp_size);
                                    std::vector <float> features;
                                    for(long long x=0;x<result.tems[z].features.size();x++){
                                        features.push_back(result.tems[z].features[x].x);
                                        features.push_back(result.tems[z].features[x].y);
                                        features.push_back(result.tems[z].features[x].lbl);
                                    }
                                    temp.push_back(features);
                                }
                            }
                            int z=result.tems.size()-1;
                            c+="坐标("+QString::number(result.tems[z].x)+","+QString::number(result.tems[z].y)+") ";
                            c+="相似性"+QString::number(result.tems[z].similarity)+" ";
                            c+="尺寸"+QString::number(result.tems[z].w)+"X"+QString::number(result.tems[z].h)+" ";
                            c+="角度"+QString::number(result.tems[z].angle)+" ";
                            c+="缩放比"+QString::number(result.tems[z].scale);
                            std::vector <float> temp_size;
                            temp_size.push_back(result.tems[z].x);
                            temp_size.push_back(result.tems[z].y);
                            temp_size.push_back(result.tems[z].similarity);
                            temp_size.push_back(result.tems[z].w);
                            temp_size.push_back(result.tems[z].h);
                            temp_size.push_back(result.tems[z].angle);
                            temp_size.push_back(result.tems[z].scale);
                            temp.push_back(temp_size);
                            std::vector <float> features;
                            for(long long x=0;x<result.tems[z].features.size();x++){
                                features.push_back(result.tems[z].features[x].x);
                                features.push_back(result.tems[z].features[x].y);
                                features.push_back(result.tems[z].features[x].lbl);
                            }
                            temp.push_back(features);
                            res[c_row]=temp;
                        }else{
                            c="未找到匹配项";
                        }
                        itemi->setText(2,c);
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="测距"){
            image[c_row]=empty_image;
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_image,raw_image_2;
                double startx,starty,endx,endy;
                QStringList order_a=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_a.size()==2){
                    QStringList order_s=order_a.at(0).split("=");
                    if(order_s.at(0)=="raw_image"){
                        raw_image=order_s.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                        }else if(image[raw_image].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                        }else if(ui->ordertable->item(raw_image,3)->text()!="圆查找"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源不是圆查找结果");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                        }
                    }
                    QStringList order_s2=order_a.at(1).split("=");
                    if(order_s2.at(0)=="raw_image_2"){
                        raw_image_2=order_s2.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image_2,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image_2=-1;
                        }else if(image[raw_image_2].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image_2=-1;
                        }else if(ui->ordertable->item(raw_image_2,3)->text()!="圆查找"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源不是圆查找结果");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image_2=-1;
                        }
                    }
                    if(raw_image!=-1&&raw_image_2!=-1){
                        startx=res[raw_image][0][0];
                        starty=res[raw_image][0][1];
                        endx=res[raw_image_2][0][0];
                        endy=res[raw_image_2][0][1];
                        YZVision::Basic2D::PointXY start(startx,starty),end(endx,endy);
                        int resu;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        Mat raw=Image2cvMat(image[raw_image ].toImage());
                        YZVision::CalcDistance_2D length;
                        YZVision::CalcDistance_2D::InputParam input= YZVision::CalcDistance_2D::InputParam();
                        YZVision::CalcDistance_2D::OutputParam result= YZVision::CalcDistance_2D::OutputParam();
                        input.raw=raw;
                        input.startpoint=start;
                        input.endpoint=end;
                        resu=length.calc_distance(input,&result);
                        image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        std::vector<std::vector <float>> temp;
                        std::vector <float> temp_size;
                        QString c="",n;
                        if(result.code==0){
                            c+="起点("+QString::number(startx)+","+QString::number(starty)+"),终点("+
                                    QString::number(endx)+","+QString::number(endy)+") 长度="+QString::number(result.l);
                            temp_size.push_back(result.l);
                            temp.push_back(temp_size);
                            res[c_row]=temp;
                        }else{
                            c="未找到匹配项";
                        }
                        itemi->setText(2,c);
                    }
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="面积计算"){
            image[c_row]=empty_image;
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_image;
                QStringList order=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_s=order.at(0).split("=");
                 if(order_s.at(0)=="raw_image"){
                    raw_image=order_s.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_image,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_image=-1;
                    }else if(image[raw_image].isNull()){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_image=-1;
                    }else if(ui->ordertable->item(raw_image,3)->text()!="斑点查找"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源并不是斑点查找");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_image=-1;
                    }
                }
                if(raw_image!=-1){
                    QStringList order_a=order.at(1).split("=");
                    int raw_blob=order_a.at(1).toInt()-1;
                    YZVision::Pts blob;
                    for(long long z=0;z<res[raw_image][raw_blob*2+1].size()/2;z++){
                        YZVision::pt a(res[raw_image][raw_blob*2+1][z*2],res[raw_image][raw_blob*2+1][z*2+1]);
                        blob.push_back(a);
                    }
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    int resu;
                    YZVision::CalcArea_2D area;
                    YZVision::CalcArea_2D::InputParam input= YZVision::CalcArea_2D::InputParam();
                    YZVision::CalcArea_2D::OutputParam output= YZVision::CalcArea_2D::OutputParam();
                    input.contour=blob;
                    resu=area.calc_area(input,&output);
                    double result=output.area;
                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *timei = new QTableWidgetItem;
                    timei->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,timei);
                    image[c_row]=image[raw_image];
                    std::vector<std::vector <float>> temp;
                    std::vector <float> temp_size;
                    QString c="",n;
                    if(resu!=0){
                        c+="面积="+QString::number(result);
                        temp_size.push_back(result);
                        temp.push_back(temp_size);
                        res[c_row]=temp;
                    }else{
                        c="未确定斑点区域";
                    }
                    itemi->setText(2,c);
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="图片拼接"){
            image[c_row]=empty_image;
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_image_1,raw_image_2;
                int up,low,number;
                bool black;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==6){
                    for(int i=0;i<order_s.size();i++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw"){
                            raw_image_1=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image_1,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源1已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"图源1已被停用");
                                raw_image_1=-1;
                                break;
                            }
                            if(image[raw_image_1].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源1已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"图源1已被停用");
                                raw_image_1=-1;
                                break;
                            }
                        }if(s_data.at(0)=="raw_2"){
                            raw_image_2=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_image_2,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"图源2已被停用");
                                raw_image_2=-1;
                                break;
                            }
                            if(image[raw_image_2].isNull()){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"图源2已被停用");
                                raw_image_2=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="upper_threshold")
                           up=s_data.at(1).toInt();
                        else if(s_data.at(0)=="lower_threshold")
                           low=s_data.at(1).toInt();
                        else if(s_data.at(0)=="number")
                           number=s_data.at(1).toInt();
                        else if(s_data.at(0)=="black"){
                           if(s_data.at(1)=="1")
                               black=true;
                           else
                               black=false;
                        }
                    }
                    if(raw_image_1!=-1&&raw_image_2!=-1){
                        Mat raw1,raw2;
                        raw1=Image2cvMat(image[raw_image_1].toImage());
                        raw2=Image2cvMat(image[raw_image_2].toImage());
                        int result;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        YZVision::Imagesplicing_2D Imagesplicing;
                        YZVision::Imagesplicing_2D::InputParam input= YZVision::Imagesplicing_2D::InputParam();
                        YZVision::Imagesplicing_2D::OutputParam output= YZVision::Imagesplicing_2D::OutputParam();
                        input.srcImage1=raw1;
                        input.srcImage2=raw2;
                        input.min_0=number;
                        input.x_0=black;
                        input.down=low;
                        input.up=up;
                        result =Imagesplicing.imagesplicing(input,&output);
                        image[c_row]=QPixmap::fromImage(cvMat2Image(output.outImage));

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);

                        if(result==1){

                            itemi->setText(2,"无输出参数");
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图片拼接失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"图片拼接失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="选择点云"){
            cloudarrary[c_row].resize(0);
            opencloudpath=ui->ordertable->item(c_row,4)->text();
            if(opencloudpath==""){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QFileInfo file;
                file=QFileInfo(opencloudpath);
                QString path1=qApp->applicationDirPath()+"/1.txt";
                QString path=qApp->applicationDirPath()+"/1.pcd";
                if(file.suffix()=="txt"){
                    qDebug()<<QFile::remove(path);
                    qDebug()<<QFile::remove(path1);
                    QFile::copy(opencloudpath,path1);
                }else{
                    qDebug()<<QFile::remove(path);
                    QFile::copy(opencloudpath,path);
                    path1=path;
                }

                QElapsedTimer  mstimer;
                mstimer.start();
                YZVision::Readcloud_3D read;
                YZVision::Readcloud_3D::InputParam input= YZVision::Readcloud_3D::InputParam();
                YZVision::Readcloud_3D::OutputParam output= YZVision::Readcloud_3D::OutputParam();
                input.read=path1.toStdString();
                input.save=path.toStdString();

                read.readcloud(input,&output);
                cloudarrary[c_row]=output.outputcloud;
                qDebug()<<QFile::remove(path);
                qDebug()<<QFile::remove(path1);

                float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                QTableWidgetItem *timei = new QTableWidgetItem;
                timei->setText(QString::number(time));
                ui->ordertable->setItem(c_row,2,timei);
                if(cloudarrary[c_row].size()==0){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无法读取点云");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无法读取点云");
                }else{
                    itemi->setText(2,"点云读取成功");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="找边缘点"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==2&&order_position.size()==12){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            QStringList a=order_s.at(1).split("=");
                            int direction=a.at(1).toInt();
                            YZVision::ROIProbeDirection d;
                            if(direction==0)
                                d=YZVision::ROIProbeDirection::RIGHT;
                            else if (direction==1)
                                d=YZVision::ROIProbeDirection::LEFT;
                            else if (direction==2)
                                d=YZVision::ROIProbeDirection::UP;
                            else if (direction==3)
                                d=YZVision::ROIProbeDirection::DOWN;
                            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                            int result;
                            QElapsedTimer  mstimer;
                            mstimer.start();
                            YZVision::vPointsXYZ edgePointCloud;
                            YZVision::Feature* feature = NULL;
                            YZVision::EdgePoint_3D* p_edgePoint = new YZVision::EdgePoint_3D();
                            feature = p_edgePoint;
                            YZVision::Feature::InputParam input= YZVision::Feature::InputParam();
                            YZVision::Feature::OutputParam output= YZVision::Feature::OutputParam();
                            input.inputCloud=&cloudarrary[raw_cloud];
                            input.serachDir=d;
                            input.m_StartPoint=start;
                            input.m_EndPoint=end;
                            result=feature->findFeature(input,&output);
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            edgePointCloud=output.outputPoints;

                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *timei = new QTableWidgetItem;
                            timei->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,timei);
                            if(result==1){
                                cloudarrary[c_row]=cloudarrary[raw_cloud];
                                itemi->setText(2,"找边缘点成功");
                                std::vector<std::vector <float>> t;
                                for(long z=0;z<edgePointCloud.size();z++){
                                    std::vector <float> t_a;
                                    t_a.push_back(edgePointCloud[z].x);
                                    t_a.push_back(edgePointCloud[z].y);
                                    t_a.push_back(edgePointCloud[z].z);
                                    t.push_back(t_a);
                                }
                                res[c_row]=t;
                            }else if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"查找失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"找边缘点失败");
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="找拐点"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==3&&order_position.size()==12){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            QStringList a=order_s.at(1).split("=");
                            int direction=a.at(1).toInt();
                            YZVision::ROIProbeDirection d;
                            if(direction==0)
                                d=YZVision::ROIProbeDirection::RIGHT;
                            else if (direction==1)
                                d=YZVision::ROIProbeDirection::LEFT;
                            else if (direction==2)
                                d=YZVision::ROIProbeDirection::UP;
                            else if (direction==3)
                                d=YZVision::ROIProbeDirection::DOWN;
                            QStringList b=order_s.at(2).split("=");
                            double threshold=b.at(1).toDouble();
                            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                            int result;
                            QElapsedTimer  mstimer;
                            mstimer.start();
                            YZVision::vPointsXYZ turningPointCloud;
                            YZVision::Feature* feature = NULL;
                            YZVision::TurningPoint_3D* p_turnPoint = new YZVision::TurningPoint_3D();
                            feature = p_turnPoint;
                            YZVision::Feature::InputParam input= YZVision::Feature::InputParam();
                            YZVision::Feature::OutputParam output= YZVision::Feature::OutputParam();
                            input.inputCloud=&cloudarrary[raw_cloud];
                            input.serachDir=d;
                            input.m_StartPoint=start;
                            input.m_EndPoint=end;
                            input.z_thres=threshold;
                            result=feature->findFeature(input,&output);
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            turningPointCloud=output.outputPoints;

                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *timei = new QTableWidgetItem;
                            timei->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,timei);

                            if(result==1){
                                cloudarrary[c_row]=cloudarrary[raw_cloud];
                                itemi->setText(2,"找拐点成功");
                                std::vector<std::vector <float>> t;
                                for(long z=0;z<turningPointCloud.size();z++){
                                    std::vector<float> t_a;
                                    t_a.push_back(turningPointCloud[z].x);
                                    t_a.push_back(turningPointCloud[z].y);
                                    t_a.push_back(turningPointCloud[z].z);
                                    t.push_back(t_a);
                                }
                                res[c_row]=t;
                            }else if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"查找失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"找拐点失败");
                            }

                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="找线"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==3&&order_position.size()==12){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            QStringList a=order_s.at(1).split("=");
                            int direction=a.at(1).toInt();
                            QStringList b=order_s.at(2).split("=");
                            int type=b.at(1).toInt();
                            YZVision::ROIProbeDirection d;
                            if(direction==0)
                                d=YZVision::ROIProbeDirection::RIGHT;
                            else if (direction==1)
                                d=YZVision::ROIProbeDirection::LEFT;
                            else if (direction==2)
                                d=YZVision::ROIProbeDirection::UP;
                            else if (direction==3)
                                d=YZVision::ROIProbeDirection::DOWN;
                            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());

                            int result;
                            std::vector<int> index;
                            std::vector<float> Coeffients;
                            QElapsedTimer  mstimer;
                            mstimer.start();

                            YZVision::Segmentation* segmentation = NULL;
                            YZVision::LineSegment* p_lineSeg = new YZVision::LineSegment();
                            segmentation = p_lineSeg;
                            YZVision::Segmentation::InputParam input_Param;
                            YZVision::Segmentation::OutputParam output_Param;
                            input_Param.inputCloud = &cloudarrary[raw_cloud];
                            input_Param.serachDir = d;
                            input_Param.m_StartPoint = start;
                            input_Param.m_EndPoint = end;
                            input_Param.distance_Threshold = 0.5;
                            input_Param.max_iteratios = 100;
                            input_Param.z_threshold=0.1;
                            if(type==1){
                                input_Param.line_seg_option=YZVision::Segmentation::LineSegOption::FIT_LINE_BASE_ON_TURNINGPOINTS;
                            }

                            result = segmentation->segment(input_Param, &output_Param);
                            index=output_Param.modelInliers;
                            Coeffients=output_Param.modelCoeffients;

                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *timei = new QTableWidgetItem;
                            timei->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,timei);
                            if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"找线失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"找线失败");
                            }else{
                                cloudarrary[c_row]=cloudarrary[raw_cloud];
                                std::vector<std::vector <float>> t;
                                std::vector <float> t_a;
                                for(int x=0;x<Coeffients.size();x++){
                                    t_a.push_back(Coeffients[x]);
                                    qDebug()<<Coeffients[x];
                                }
                                t.push_back(t_a);
                                std::vector <float> t_r;
                                t_r.push_back(output_Param.xyz_angles[0]);
                                t_r.push_back(output_Param.xyz_angles[1]);
                                t_r.push_back(output_Param.xyz_angles[2]);
                                t.push_back(t_r);
                                res[c_row]=t;
                                itemi->setText(2,"找线成功");
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="找面"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==2&&order_position.size()==12){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            QStringList a=order_s.at(1).split("=");
                            int direction=a.at(1).toInt();
                            YZVision::ROIProbeDirection d;
                            if(direction==0)
                                d=YZVision::ROIProbeDirection::FRONT;
                            else if (direction==1)
                                d=YZVision::ROIProbeDirection::BACK;
                            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                            int result;
                            std::vector<int> index;
                            std::vector<float> Coeffients;
                            QElapsedTimer  mstimer;
                            mstimer.start();
                            YZVision::Segmentation* segmentation = NULL;
                            YZVision::PlaneSegment* p_planeSeg = new YZVision::PlaneSegment();
                            segmentation = p_planeSeg;
                            YZVision::Segmentation::InputParam input_Param;
                            YZVision::Segmentation::OutputParam output_Param;
                            input_Param.inputCloud = &cloudarrary[raw_cloud];
                            input_Param.serachDir = d;
                            input_Param.m_StartPoint = start;
                            input_Param.m_EndPoint = end;
                            input_Param.distance_Threshold = 0.5;
                            input_Param.max_iteratios = 100;

                            result = segmentation->segment(input_Param, &output_Param);
                            index=output_Param.modelInliers;
                            Coeffients=output_Param.modelCoeffients;

                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *timei = new QTableWidgetItem;
                            timei->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,timei);
                            if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"查找失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"找面失败");
                            }else{
                                cloudarrary[c_row]=cloudarrary[raw_cloud];
                                std::vector<std::vector <float>> t;
                                std::vector <float> t_a;
                                for(int x=0;x<Coeffients.size();x++){
                                    t_a.push_back(Coeffients[x]);
                                    qDebug()<<Coeffients[x];
                                }
                                t.push_back(t_a);
                                res[c_row]=t;
                                itemi->setText(2,"找面成功");
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="找质心"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==1&&order_position.size()==12){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                            int result;
                            YZVision::vPointsXYZ CentroidPointCloud;
                            QElapsedTimer  mstimer;
                            mstimer.start();
                            YZVision::Feature* feature = NULL;
                            YZVision::Centroid_3D* p_Centroid = new YZVision::Centroid_3D();
                            feature = p_Centroid;
                            YZVision::Feature::InputParam input= YZVision::Feature::InputParam();
                            YZVision::Feature::OutputParam output= YZVision::Feature::OutputParam();
                            input.inputCloud=&cloudarrary[raw_cloud];
                            input.serachDir = YZVision::ROIProbeDirection::RIGHT;
                            input.m_StartPoint=start;
                            input.m_EndPoint=end;
                            result=feature->findFeature(input,&output);
                            CentroidPointCloud=output.outputPoints;

                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *timei = new QTableWidgetItem;
                            timei->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,timei);
                            if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"查找失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"找质心失败");
                            }else{
                                cloudarrary[c_row]=cloudarrary[raw_cloud];
                                std::vector<std::vector <float>> t;
                                std::vector <float> t_a;
                                t_a.push_back(CentroidPointCloud[0].x);
                                t_a.push_back(CentroidPointCloud[0].y);
                                t_a.push_back(CentroidPointCloud[0].z);
                                t.push_back(t_a);
                                res[c_row]=t;
                                itemi->setText(2,QString("(%1,%2,%3)").arg(CentroidPointCloud[0].x).arg(CentroidPointCloud[0].y).arg(CentroidPointCloud[0].z));
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="重采样"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud,type;
                double length,radius,step;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==5){
                    for(int i=0;i<order_s.size();i++){
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw_cloud"){
                            raw_cloud=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_cloud=-1;
                                break;
                            }else if(cloudarrary[raw_cloud].size()==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"无图像输入");
                                raw_cloud=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="type"){
                            type=s_data.at(1).toInt();
                        }else if(s_data.at(0)=="length"){
                            length=s_data.at(1).toDouble();
                        }else if(s_data.at(0)=="radius"){
                            radius=s_data.at(1).toDouble();
                        }else if(s_data.at(0)=="step"){
                            step=s_data.at(1).toDouble();
                        }
                    }
                    if(raw_cloud!=-1){
                        int result;
                        YZVision::vPointsXYZ cloud;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        if(type==0){
                            YZVision::Downresampling_3D Downresampling;
                            YZVision::Downresampling_3D::InputParam input= YZVision::Downresampling_3D::InputParam();
                            YZVision::Downresampling_3D::OutputParam output= YZVision::Downresampling_3D::OutputParam();
                            input.inputcloud=&cloudarrary[raw_cloud];
                            input.r_0=length;
                            result=Downresampling.downresampling(input,&output);
                            cloud=output.outputcloud;
                        }else if(type==1){
                            YZVision::Averageresampling_3D Averageresampling;
                            YZVision::Averageresampling_3D::InputParam input= YZVision::Averageresampling_3D::InputParam();
                            YZVision::Averageresampling_3D::OutputParam output= YZVision::Averageresampling_3D::OutputParam();
                            input.inputcloud=&cloudarrary[raw_cloud];
                            input.r_0=length;
                            result=Averageresampling.averageresampling(input,&output);
                            cloud=output.outputcloud;
                         }else if(type==2){
                            YZVision::Upresampling_3D Upresampling;
                            YZVision::Upresampling_3D::InputParam input= YZVision::Upresampling_3D::InputParam();
                            YZVision::Upresampling_3D::OutputParam output= YZVision::Upresampling_3D::OutputParam();
                            input.inputcloud=&cloudarrary[raw_cloud];
                            input.r_0=length;
                            input.r_1=radius;
                            input.s_0=step;
                            result=Upresampling.upresampling(input,&output);
                            cloud=output.outputcloud;
                        }
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==1){
                            cloudarrary[c_row]=cloud;
                            itemi->setText(2,"重采样成功");
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"重采样失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"重采样失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="裁切"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==2&&order_position.size()==12){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            QStringList a=order_s.at(1).split("=");
                            int ini=a.at(1).toInt();
                            bool in;
                            if(ini==1)
                                in=true;
                            else
                                in=false;
                            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                            QElapsedTimer  mstimer;
                            mstimer.start();
                            int result;
                            YZVision::Cutcloud_3D *Cutcloud=new YZVision::Cutcloud_3D();
                            YZVision::Cutcloud_3D::InputParam input= YZVision::Cutcloud_3D::InputParam();
                            YZVision::Cutcloud_3D::OutputParam output= YZVision::Cutcloud_3D::OutputParam();
                            input.inputcloud=&cloudarrary[raw_cloud];
                            input.x_0=in;
                            input.m_StartPoint=start;
                            input.m_EndPoint=end;
                            result=Cutcloud->cutcloud(input,&output);
                            cloudarrary[c_row]=output.outputcloud;
                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *item = new QTableWidgetItem;
                            item->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,item);
                            if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"裁切失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"裁切失败");
                            }else{
                                itemi->setText(2,"裁切成功");
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="拼接"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud,raw_cloud_2,crop;
                double move,low,high;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==6){
                    for(int i=0;i<order_s.size();i++){
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw_cloud_1"){
                            raw_cloud=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_cloud=-1;
                                break;
                            }else if(cloudarrary[raw_cloud].size()==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"无图像输入");
                                raw_cloud=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="raw_cloud_2"){
                            raw_cloud_2=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_cloud=-1;
                                break;
                            }else if(cloudarrary[raw_cloud].size()==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"无图像输入");
                                raw_cloud=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="CROP"){
                            crop=s_data.at(1).toInt();
                        }else if(s_data.at(0)=="move"){
                            move=s_data.at(1).toDouble();
                        }else if(s_data.at(0)=="low"){
                            low=s_data.at(1).toDouble();
                        }else if(s_data.at(0)=="high"){
                            high=s_data.at(1).toDouble();
                        }
                    }
                    if(raw_cloud!=-1&&raw_cloud_2!=-1){
                        int result;
                        bool cropd;
                        if(crop)
                            cropd=false;
                        else
                            cropd=true;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        YZVision::Cloudsplicing_3D Cloudsplicing;
                        YZVision::Cloudsplicing_3D::InputParam input= YZVision::Cloudsplicing_3D::InputParam();
                        YZVision::Cloudsplicing_3D::OutputParam output= YZVision::Cloudsplicing_3D::OutputParam();
                        input.inputcloud_90=&cloudarrary[raw_cloud];
                        input.inputcloud_91=&cloudarrary[raw_cloud_2];
                        input.Q=cropd;
                        input.x_0=move;
                        input.l_0=low;
                        input.l_1=high;
                        result=Cloudsplicing.cloudsplicing(input,&output);
                        cloudarrary[c_row]=output.outputcloud_90_91;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==1){
                            itemi->setText(2,"拼接成功");
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"拼接失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"拼接失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="3D转深度图"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud;
                double zoomx,zoomy,threshold;
                bool wave;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==5){
                    for(int i=0;i<order_s.size();i++){
                        QStringList s_data=order_s.at(i).split("=");
                        if(s_data.at(0)=="raw_cloud"){
                            raw_cloud=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_cloud=-1;
                                break;
                            }else if(cloudarrary[raw_cloud].size()==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"无图像输入");
                                raw_cloud=-1;
                                break;
                            }
                        }else if(s_data.at(0)=="zoom"){
                            zoomx=s_data.at(1).toDouble();
                        }else if(s_data.at(0)=="zoom_y"){
                            zoomy=s_data.at(1).toDouble();
                        }else if(s_data.at(0)=="wave"){
                            if(s_data.at(1)=="1"){
                                wave=true;
                            }else{
                                wave=false;
                            }
                        }else if(s_data.at(0)=="threshold"){
                            threshold=s_data.at(1).toDouble();
                        }
                    }
                    if(raw_cloud!=-1){
                        int result;
                        QImage resu;
                        QElapsedTimer  mstimer;
                        YZVision::vPointsXYZ cloud;
                        cloud=cloudarrary[raw_cloud];
                        mstimer.start();
                        YZVision::Deepcloud_3D deep;
                        YZVision::Deepcloud_3D::InputParam input= YZVision::Deepcloud_3D::InputParam();
                        YZVision::Deepcloud_3D::OutputParam output= YZVision::Deepcloud_3D::OutputParam();
                        input.inputcloud=&cloud;
                        input.x_0=zoomx;
                        input.y_0=zoomy;
                        input.Q=wave;
                        input.a_0=threshold;
                        result=deep.deepcloud(input,&output);
                        resu =cvMat2Image(output.outImage);
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==1){
                            image[c_row]=QPixmap::fromImage(resu);
                            itemi->setText(2,"转深度图成功");
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"转深度图失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"转深度图失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="拟合圆柱"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==1&&order_position.size()==12){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                            int result;
                            std::vector<int> index;
                            std::vector<float> Coeffients;
                            QElapsedTimer  mstimer;
                            mstimer.start();
                            YZVision::Segmentation* segmentation = NULL;
                            YZVision::CylinderSegment* p_cylinderSeg = new YZVision::CylinderSegment();
                            segmentation = p_cylinderSeg;
                            YZVision::Segmentation::InputParam input_Param;
                            YZVision::Segmentation::OutputParam output_Param;
                            input_Param.inputCloud = &cloudarrary[raw_cloud];
                            input_Param.m_StartPoint = start;
                            input_Param.m_EndPoint = end;
                            input_Param.distance_Threshold = 0.1;
                            input_Param.distance_weight = 0.1;
                            input_Param.k_nearest_neighbors = 10;
                            input_Param.max_iteratios = 20;

                            result = segmentation->segment(input_Param, &output_Param);
                            Coeffients=output_Param.modelCoeffients;
                            index=output_Param.modelInliers;
                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *item = new QTableWidgetItem;
                            item->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,item);
                            if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"拟合失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"拟合失败");
                            }else{
                                cloudarrary[c_row]=cloudarrary[raw_cloud];
                                std::vector<std::vector <float>> t;
                                std::vector <float> t_a;
                                for(int x=0;x<Coeffients.size();x++){
                                    t_a.push_back(Coeffients[x]);
                                    qDebug()<<Coeffients[x];
                                }
                                t.push_back(t_a);
                                res[c_row]=t;
                                itemi->setText(2,"拟合成功");
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="曲面展开"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==1){
                    QStringList s_data=order_s.at(0).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }else if(ui->ordertable->item(raw_cloud,3)->text()!="拟合圆柱"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源不是拟合圆柱结果");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源不符合要求");
                            raw_cloud=-1;
                        }

                    }
                    if(raw_cloud!=-1){
                        int result;
                        YZVision::vPointsXYZ out;
//                        YZ3DVision::GEO_CYLINDER para_cylinder;
//                        para_cylinder.R = res[raw_cloud][0][6];
//                        para_cylinder.Axial = YZ3DVision::AXIS::AXIS_Y;
//                        para_cylinder.RadialTran = YZ3DVision::AXIS::AXIS_X;
//                        para_cylinder.RadialLong = YZ3DVision::AXIS::AXIS_Z;
//                        para_cylinder.CenterTran = res[raw_cloud][0][0];
//                        para_cylinder.CenterLong = res[raw_cloud][0][2];
                        QElapsedTimer  mstimer;
                        mstimer.start();
//                        YZ3DVision::Algorithm* p_algorithm_plane = new YZ3DVision::Algorithm();
//                        result=p_algorithm_plane->cylinderToPlane(&cloudarrary[raw_cloud],para_cylinder,&out);
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==1){
                            cloudarrary[c_row]=out;
                            itemi->setText(2,"曲面展开成功");
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"曲面展开失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"曲面展开失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="平滑"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==2){
                    QStringList s_data=order_s.at(0).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }
                    }
                    if(raw_cloud!=-1){
                        QStringList a=order_s.at(1).split("=");
                        double radius=a.at(1).toDouble();
                        int result;
                        YZVision::vPointsXYZ cloud;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        YZVision::Fullupcloud_3D smooth;
                        YZVision::Fullupcloud_3D::InputParam input= YZVision::Fullupcloud_3D::InputParam();
                        YZVision::Fullupcloud_3D::OutputParam output= YZVision::Fullupcloud_3D::OutputParam();
                        input.inputcloud=&cloudarrary[raw_cloud];
                        input.r_0=radius;
                        result=smooth.fullupcloud(input,&output);
                        cloud=output.outputcloud;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==1){
                            cloudarrary[c_row]=cloud;
                            itemi->setText(2,"平滑成功");
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"平滑失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"平滑失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="滤波"){
                cloudarrary[c_row].resize(0);
                if(c_row==0){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }else{
                    int raw_cloud;
                    QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                    if(order_s.size()==8){
                        QStringList s_data=order_s.at(0).split("=");
                        if(s_data.at(0)=="raw_cloud"){
                            raw_cloud=s_data.at(1).toInt()-1;
                            if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"部分设置为空");
                                raw_cloud=-1;
                            }else if(cloudarrary[raw_cloud].size()==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"无图像输入");
                                raw_cloud=-1;
                            }
                        }
                        if(raw_cloud!=-1){
                            int type,direction;
                            double up,down,number,zoom;
                            bool saved;
                            for(int z=1;z<order_s.size();z++){
                                QStringList a=order_s.at(z).split("=");
                                if(a.at(0)=="direction"){
                                    direction=a.at(1).toInt();
                                }else if(a.at(0)=="up"){
                                    up=a.at(1).toDouble();
                                }else if(a.at(0)=="down"){
                                    down=a.at(1).toDouble();
                                }else if(a.at(0)=="number"){
                                    number=a.at(1).toDouble();
                                }else if(a.at(0)=="zoom"){
                                    zoom=a.at(1).toDouble();
                                }else if(a.at(0)=="save"){
                                    if(a.at(1)=="0")
                                        saved=false;
                                    else
                                        saved=true;
                                }else if(a.at(0)=="type"){
                                    type=a.at(1).toInt();
                                }

                            }
                            int result;
                            YZVision::vPointsXYZ cloud;
                            QElapsedTimer  mstimer;
                            mstimer.start();
                            if(type==0){
                                YZVision::PassthroughFilter_3D pass;
                                YZVision::PassthroughFilter_3D::InputParam input= YZVision::PassthroughFilter_3D::InputParam();
                                YZVision::PassthroughFilter_3D::OutputParam output= YZVision::PassthroughFilter_3D::OutputParam();
                                input.inputcloud=&cloudarrary[raw_cloud];
                                input.a=direction;
                                input.R_0=saved;
                                input.x_0=down;
                                input.x_1=up;
                                result=pass.passThroughFilter(input,&output);
                                cloud=output.outputcloud;
                            }else if(type==1){
                                YZVision::Statisticalcloud_3D Statis;
                                YZVision::Statisticalcloud_3D::InputParam input= YZVision::Statisticalcloud_3D::InputParam();
                                YZVision::Statisticalcloud_3D::OutputParam output= YZVision::Statisticalcloud_3D::OutputParam();
                                input.inputcloud=&cloudarrary[raw_cloud];
                                input.x_0=saved;
                                input.a_0=number;
                                input.s_0=zoom;
                                result=Statis.statisticalcloud(input,&output);
                                cloud=output.outputcloud;
                            }else if(type==2){
                                YZVision::Radiuscloud_3D Radius;
                                YZVision::Radiuscloud_3D::InputParam input= YZVision::Radiuscloud_3D::InputParam();
                                YZVision::Radiuscloud_3D::OutputParam output= YZVision::Radiuscloud_3D::OutputParam();
                                input.inputcloud=&cloudarrary[raw_cloud];
                                input.a_0=number;
                                input.r_0=zoom;
                                result=Radius.raduiscloud(input,&output);
                                cloud=output.outputcloud;
                            }
                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *item = new QTableWidgetItem;
                            item->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,item);
                            if(result==1){
                                cloudarrary[c_row]=cloud;
                                itemi->setText(2,"滤波成功");
                            }else{
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"滤波失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"滤波失败");
                            }
                        }
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }
                }
        }else if (ui->ordertable->item(c_row,3)->text()=="去重"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==5){
                    QStringList s_data=order_s.at(0).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }
                    }
                    if(raw_cloud!=-1){
                        int direction;
                        double low,high,move;

                        for(int z=1;z<order_s.size();z++){
                            QStringList a=order_s.at(z).split("=");
                            if(a.at(0)=="direction"){
                                direction=a.at(1).toInt();
                            }else if(a.at(0)=="low"){
                                low=a.at(1).toDouble();
                            }else if(a.at(0)=="high"){
                                high=a.at(1).toDouble();
                            }else if(a.at(0)=="move"){
                                move=a.at(1).toDouble();
                            }
                        }
                        int result;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        YZVision::CloudDeduplication_3D CROP;
                        YZVision::CloudDeduplication_3D::InputParam input= YZVision::CloudDeduplication_3D::InputParam();
                        YZVision::CloudDeduplication_3D::OutputParam output= YZVision::CloudDeduplication_3D::OutputParam();
                        input.inputcloud_90=&cloudarrary[raw_cloud];
                        input.a=direction;
                        input.l_0=low;
                        input.l_1=high;
                        result=CROP.clouddeduplication(input,&output);

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==1){
                            cloudarrary[c_row]=output.outputcloud;
                            itemi->setText(2,"去重成功");
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"去重失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"去重失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
    }else if (ui->ordertable->item(c_row,3)->text()=="点到点"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud,raw_cloud_2;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==2){
                    QStringList s_data=order_s.at(0).split("=");
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找边缘点"||
                                  ui->ordertable->item(raw_cloud,3)->text()=="找拐点"||
                                  ui->ordertable->item(raw_cloud,3)->text()=="找质心")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为点");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源1不为点");
                            raw_cloud=-1;
                        }
                    }
                    QStringList a=order_s.at(1).split("=");
                    if(a.at(0)=="raw_cloud2"){
                        raw_cloud_2=a.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud_2=-1;
                        }else if(cloudarrary[raw_cloud_2].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无点云输入");
                            raw_cloud_2=-1;
                        }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找边缘点"||
                                  ui->ordertable->item(raw_cloud_2,3)->text()=="找拐点"||
                                  ui->ordertable->item(raw_cloud_2,3)->text()=="找质心")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为点");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源2不为点");
                            raw_cloud_2=-1;
                        }
                    }
                    if(raw_cloud!=-1&&raw_cloud_2!=-1){
                        YZVision::PointXYZ a,b;
                        std::vector <float> ra,rb;
                        double cx=0,cy=0,cz=0;
                        for(long z=0;z<res[raw_cloud].size();z++){
                            cx+=res[raw_cloud][z][0];
                            cy+=res[raw_cloud][z][1];
                            cz+=res[raw_cloud][z][2];
                            ra.push_back(res[raw_cloud][z][0]);
                            ra.push_back(res[raw_cloud][z][1]);
                            ra.push_back(res[raw_cloud][z][2]);
                        }
                        cx=cx/res[raw_cloud].size();
                        cy=cy/res[raw_cloud].size();
                        cz=cz/res[raw_cloud].size();
                        a.setPoint(cx,cy,cz);

                        for(long x=0;x<res[raw_cloud_2].size();x++){
                            cx+=res[raw_cloud_2][x][0];
                            cy+=res[raw_cloud_2][x][1];
                            cz+=res[raw_cloud_2][x][2];
                            rb.push_back(res[raw_cloud_2][x][0]);
                            rb.push_back(res[raw_cloud_2][x][1]);
                            rb.push_back(res[raw_cloud_2][x][2]);
                        }
                        cx=cx/res[raw_cloud_2].size();
                        cy=cy/res[raw_cloud_2].size();
                        cz=cz/res[raw_cloud_2].size();

                        b.setPoint(cx,cy,cz);
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        double result=0;
                        int resu;
                        YZVision::Measurement* measurement = NULL;
                        YZVision::PointToPointDis_3D* p_p2pDis = new YZVision::PointToPointDis_3D();
                        measurement = p_p2pDis;
                        YZVision::Measurement::InputParam input_Param;
                        YZVision::Measurement::OutputParam output_Param;
                        input_Param.pt1=a;
                        input_Param.pt2=b;
                        resu=measurement->measure(input_Param, &output_Param);
                        result=output_Param.distance;
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(resu!=0){
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            itemi->setText(2,"距离为"+QString::number(result));

                            std::vector<std::vector <float>> t;

                            t.push_back(ra);

                            t.push_back(rb);

                            std::vector <float> t_a;
                            t_a.push_back(a.x);
                            t_a.push_back(a.y);
                            t_a.push_back(a.z);
                            t.push_back(t_a);

                            std::vector <float> t_b;
                            t_b.push_back(b.x);
                            t_b.push_back(b.y);
                            t_b.push_back(b.z);
                            t.push_back(t_b);

                            res[c_row]=t;
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测距失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"测距失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="点到线"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud,raw_cloud_2;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==2){
                    QStringList s_data=order_s.at(0).split("=");
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找边缘点"||
                                  ui->ordertable->item(raw_cloud,3)->text()=="找拐点"||
                                  ui->ordertable->item(raw_cloud,3)->text()=="找质心")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为点");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源不为点");
                            raw_cloud=-1;
                        }
                    }
                    QStringList a=order_s.at(1).split("=");
                    if(a.at(0)=="raw_cloud2"){
                        raw_cloud_2=a.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud_2=-1;
                        }else if(cloudarrary[raw_cloud_2].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无点云输入");
                            raw_cloud_2=-1;
                        }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找线")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为线");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源2不为线");
                            raw_cloud_2=-1;
                        }
                    }
                    if(raw_cloud!=-1&&raw_cloud_2!=-1){
                        YZVision::PointXYZ a;
                        std::vector<float> b;
                        std::vector <float> ra;
                        double cx=0,cy=0,cz=0;
                        for(long z=0;z<res[raw_cloud].size();z++){
                            cx+=res[raw_cloud][z][0];
                            cy+=res[raw_cloud][z][1];
                            cz+=res[raw_cloud][z][2];
                            ra.push_back(res[raw_cloud][z][0]);
                            ra.push_back(res[raw_cloud][z][1]);
                            ra.push_back(res[raw_cloud][z][2]);
                        }
                        cx=cx/res[raw_cloud].size();
                        cy=cy/res[raw_cloud].size();
                        cz=cz/res[raw_cloud].size();
                        a.setPoint(cx,cy,cz);

                        for(int i=0;i<res[raw_cloud_2][0].size();i++)
                            b.push_back(res[raw_cloud_2][0][i]);
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        double result=0;
                        int resu;
                        YZVision::Measurement* measurement = NULL;
                        YZVision::PointToLineDis_3D* p_p2lDis = new YZVision::PointToLineDis_3D();
                        measurement = p_p2lDis;
                        YZVision::Measurement::InputParam input_Param;
                        YZVision::Measurement::OutputParam output_Param;
                        input_Param.pt_out_line=a;
                        input_Param.modelCoeffients=b;
                        resu=measurement->measure(input_Param, &output_Param);
                        result=output_Param.distance;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(resu==1){
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            itemi->setText(2,"距离为"+QString::number(result));

                            std::vector<std::vector <float>> t;

                            t.push_back(ra);

                            std::vector <float> r_b;
                            r_b.push_back(raw_cloud_2);
                            t.push_back(r_b);

                            std::vector <float> t_a;
                            t_a.push_back(a.x);
                            t_a.push_back(a.y);
                            t_a.push_back(a.z);
                            t.push_back(t_a);

                        //    std::vector <float> t_b;
                        //    t_b.push_back(bp.x);
                        //    t_b.push_back(bp.y);
                        //    t_b.push_back(bp.z);
                        //    t.push_back(t_b);

                            res[c_row]=t;
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测距失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"测距失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="点到面"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud,raw_cloud_2;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==2){
                    QStringList s_data=order_s.at(0).split("=");
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找边缘点"||
                                  ui->ordertable->item(raw_cloud,3)->text()=="找拐点"||
                                  ui->ordertable->item(raw_cloud,3)->text()=="找质心")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为点");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源不为点");
                            raw_cloud=-1;
                        }
                    }
                    QStringList a=order_s.at(1).split("=");
                    if(a.at(0)=="raw_cloud2"){
                        raw_cloud_2=a.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud_2=-1;
                        }else if(cloudarrary[raw_cloud_2].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无点云输入");
                            raw_cloud_2=-1;
                        }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找面")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为面");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源2不为面");
                            raw_cloud_2=-1;
                        }
                    }
                    if(raw_cloud!=-1&&raw_cloud_2!=-1){
                        YZVision::PointXYZ a;
                        std::vector<float> b;
                        std::vector <float> ra;
                        double cx=0,cy=0,cz=0;
                        for(long z=0;z<res[raw_cloud].size();z++){
                            cx+=res[raw_cloud][z][0];
                            cy+=res[raw_cloud][z][1];
                            cz+=res[raw_cloud][z][2];
                            ra.push_back(res[raw_cloud][z][0]);
                            ra.push_back(res[raw_cloud][z][1]);
                            ra.push_back(res[raw_cloud][z][2]);
                        }
                        cx=cx/res[raw_cloud].size();
                        cy=cy/res[raw_cloud].size();
                        cz=cz/res[raw_cloud].size();
                        a.setPoint(cx,cy,cz);

                        for(int i=0;i<res[raw_cloud_2][0].size();i++)
                            b.push_back(res[raw_cloud_2][0][i]);
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        double result=0;
                        int resu;
                        YZVision::Measurement* measurement = NULL;
                        YZVision::PointToPlaneDis_3D* p_p2planeDis = new YZVision::PointToPlaneDis_3D();
                        measurement = p_p2planeDis;
                        YZVision::Measurement::InputParam input_Param;
                        YZVision::Measurement::OutputParam output_Param;
                        input_Param.pt_out_line=a;
                        input_Param.modelCoeffients=b;
                        resu=measurement->measure(input_Param, &output_Param);
                        result=output_Param.distance;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(resu==1){
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            itemi->setText(2,"距离为"+QString::number(result));

                            std::vector<std::vector <float>> t;

                            t.push_back(ra);

                            std::vector <float> r_b;
                            r_b.push_back(raw_cloud_2);
                            t.push_back(r_b);

                            std::vector <float> t_a;
                            t_a.push_back(a.x);
                            t_a.push_back(a.y);
                            t_a.push_back(a.z);
                            t.push_back(t_a);

                        //    std::vector <float> t_b;
                        //    t_b.push_back(bp.x);
                        //    t_b.push_back(bp.y);
                        //    t_b.push_back(bp.z);
                        //    t.push_back(t_b);

                            res[c_row]=t;
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测距失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"测距失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="线到线"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud,raw_cloud_2;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==2){
                    QStringList s_data=order_s.at(0).split("=");
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找线")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为线");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源不为线");
                            raw_cloud=-1;
                        }
                    }
                    QStringList a=order_s.at(1).split("=");
                    if(a.at(0)=="raw_cloud2"){
                        raw_cloud_2=a.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud_2=-1;
                        }else if(cloudarrary[raw_cloud_2].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无点云输入");
                            raw_cloud_2=-1;
                        }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找线")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为线");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源2不为线");
                            raw_cloud_2=-1;
                        }
                    }
                    if(raw_cloud!=-1&&raw_cloud_2!=-1){
                        std::vector<float> a,b;
                        for(int i=0;i<res[raw_cloud][0].size();i++)
                            a.push_back(res[raw_cloud][0][i]);

                        for(int i=0;i<res[raw_cloud_2][0].size();i++)
                            b.push_back(res[raw_cloud_2][0][i]);

                        YZVision::PointXYZ ap,bp;

                        QElapsedTimer  mstimer;
                        mstimer.start();

                        double result=0;
                        int resu;
                        YZVision::Measurement* measurement = NULL;
                        YZVision::LineToLineDis_3D* p_l2lDis = new YZVision::LineToLineDis_3D();
                        measurement = p_l2lDis;
                        YZVision::Measurement::InputParam input_Param;
                        YZVision::Measurement::OutputParam output_Param;
                        input_Param.line1Coeffients=a;
                        input_Param.line2Coeffients=b;
                        resu=measurement->measure(input_Param, &output_Param);
                        result=output_Param.distance;
                        ap=output_Param.pt1_on_line;
                        bp=output_Param.pt2_on_line;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(resu==1){
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            itemi->setText(2,"距离为"+QString::number(result));

                            std::vector<std::vector <float>> t;

                            std::vector <float> r_a;
                            r_a.push_back(raw_cloud);
                            t.push_back(r_a);

                            std::vector <float> r_b;
                            r_b.push_back(raw_cloud_2);
                            t.push_back(r_b);

                            std::vector <float> t_a;
                            t_a.push_back(ap.x);
                            t_a.push_back(ap.y);
                            t_a.push_back(ap.z);
                            t.push_back(t_a);

                            std::vector <float> t_b;
                            t_b.push_back(bp.x);
                            t_b.push_back(bp.y);
                            t_b.push_back(bp.z);
                            t.push_back(t_b);

                            res[c_row]=t;
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测距失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"测距失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="线到面"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==3&&order_position.size()==3){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=-1,raw_cloud_2=-1;
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找线")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为线");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源不为线");
                            raw_cloud=-1;
                        }
                    }

                    QStringList r2=order_s.at(1).split("=");
                    if(r2.at(0)=="raw_cloud2"){
                        raw_cloud_2=r2.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud_2=-1;
                        }else if(cloudarrary[raw_cloud_2].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无点云输入");
                            raw_cloud_2=-1;
                        }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找面")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为面");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源2不为面");
                            raw_cloud_2=-1;
                        }
                    }

                    if(raw_cloud!=-1&&raw_cloud_2!=-1){
                        int raw_cloud1=raw_cloud;
                        int raw_cloud2=raw_cloud_2;


                        YZVision::Measurement::MeasureDirection d;

                        for(int z=2;z<order_s.size();z++){
                            QStringList a=order_s.at(z).split("=");
                            if(a.at(0)=="direction"){
                                if(a.at(1).toInt()==0)
                                    d=YZVision::Measurement::MeasureDirection::PARALLEL_TO_Z_AXIS;

                            }
                        }

                        std::vector<float> a,b;
                        for(int i=0;i<res[raw_cloud1][0].size();i++)
                            a.push_back(res[raw_cloud1][0][i]);

                        for(int i=0;i<res[raw_cloud2][0].size();i++)
                            b.push_back(res[raw_cloud2][0][i]);

                        YZVision::PointXYZ point;
                        double x,y,z;
                        x=order_position.at(0).toDouble();
                        y=order_position.at(1).toDouble();
                        z=order_position.at(2).toDouble();
                        point.setPoint(x,y,z);

                        QElapsedTimer  mstimer;
                        mstimer.start();
                        YZVision::PointXYZ ap,bp;

                        double result=0;
                        int resu;
                        YZVision::Measurement* measurement = NULL;
                        YZVision::LineToPlaneDis_3D* p_l2planeDis = new YZVision::LineToPlaneDis_3D();
                        measurement = p_l2planeDis;
                        YZVision::Measurement::InputParam input_Param;
                        YZVision::Measurement::OutputParam output_Param;
                        input_Param.line_out_plane=a;
                        input_Param.plane1Coeffients=b;
                        input_Param.ref_pt=point;
                        input_Param.measure_dir=d;
                        resu=measurement->measure(input_Param, &output_Param);
                        result=output_Param.distance;
                        ap=output_Param.pt3_on_line;
                        bp=output_Param.pt4_on_plane;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(resu==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测量失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"测量失败");
                        }else{
                            cloudarrary[c_row]=cloudarrary[raw_cloud1];
                            itemi->setText(2,"距离为"+QString::number(fabsf(result)));

                            std::vector<std::vector <float>> t;

                            std::vector <float> r_a;
                            r_a.push_back(raw_cloud1);
                            t.push_back(r_a);

                            std::vector <float> r_b;
                            r_b.push_back(raw_cloud2);
                            t.push_back(r_b);

                            std::vector <float> t_a;
                            t_a.push_back(ap.x);
                            t_a.push_back(ap.y);
                            t_a.push_back(ap.z);
                            t.push_back(t_a);

                            std::vector <float> t_b;
                            t_b.push_back(bp.x);
                            t_b.push_back(bp.y);
                            t_b.push_back(bp.z);
                            t.push_back(t_b);

                            res[c_row]=t;
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="面到面"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无点云输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==3&&order_position.size()==3){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=-1,raw_cloud_2=-1;
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找面")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为面");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源不为面");
                            raw_cloud=-1;
                        }
                    }

                    QStringList r2=order_s.at(1).split("=");
                    if(r2.at(0)=="raw_cloud2"){
                        raw_cloud_2=r2.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud_2=-1;
                        }else if(cloudarrary[raw_cloud_2].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无点云输入");
                            raw_cloud_2=-1;
                        }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找面")){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为面");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"点云源2不为面");
                            raw_cloud_2=-1;
                        }
                    }

                    if(raw_cloud!=-1&&raw_cloud_2!=-1){
                        int raw_cloud1=raw_cloud;
                        int raw_cloud2=raw_cloud_2;


                        YZVision::Measurement::MeasureDirection d;

                        for(int z=2;z<order_s.size();z++){
                            QStringList a=order_s.at(z).split("=");
                            if(a.at(0)=="direction"){
                                if(a.at(1).toInt()==0)
                                    d=YZVision::Measurement::MeasureDirection::PARALLEL_TO_Z_AXIS;

                            }
                        }

                        std::vector<float> a,b;
                        for(int i=0;i<res[raw_cloud1][0].size();i++)
                            a.push_back(res[raw_cloud1][0][i]);

                        for(int i=0;i<res[raw_cloud2][0].size();i++)
                            b.push_back(res[raw_cloud2][0][i]);

                        YZVision::PointXYZ point;
                        double x,y,z;
                        x=order_position.at(0).toDouble();
                        y=order_position.at(1).toDouble();
                        z=order_position.at(2).toDouble();
                        point.setPoint(x,y,z);
                        YZVision::PointXYZ ap,bp;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        double result=0;
                        int resu;
                        YZVision::Measurement* measurement = NULL;
                        YZVision::PlaneToPlaneDis_3D* p_plane2planeDis = new YZVision::PlaneToPlaneDis_3D();
                        measurement = p_plane2planeDis;
                        YZVision::Measurement::InputParam input_Param;
                        YZVision::Measurement::OutputParam output_Param;
                        input_Param.plane1Coeffients=a;
                        input_Param.plane2Coeffients=b;
                        input_Param.ref_pt=point;
                        input_Param.measure_dir=d;
                        resu=measurement->measure(input_Param, &output_Param);
                        result=output_Param.distance;
                        ap=output_Param.pt5_on_plane;
                        bp=output_Param.pt6_on_plane;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(resu==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测量失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"测量失败");
                        }else{
                            cloudarrary[c_row]=cloudarrary[raw_cloud1];
                            itemi->setText(2,"距离为"+QString::number(fabsf(result)));

                            std::vector<std::vector <float>> t;

                            std::vector <float> r_a;
                            r_a.push_back(raw_cloud1);
                            t.push_back(r_a);

                            std::vector <float> r_b;
                            r_b.push_back(raw_cloud2);
                            t.push_back(r_b);

                            std::vector <float> t_a;
                            t_a.push_back(ap.x);
                            t_a.push_back(ap.y);
                            t_a.push_back(ap.z);
                            t.push_back(t_a);

                            std::vector <float> t_b;
                            t_b.push_back(bp.x);
                            t_b.push_back(bp.y);
                            t_b.push_back(bp.z);
                            t.push_back(t_b);

                            res[c_row]=t;
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="平整度"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==2&&order_position.size()==12){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            QStringList a=order_s.at(1).split("=");
                            double threshold =a.at(1).toDouble();
                            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                            YZVision::vPointsXYZ cloud;
                            int result;
                            float min,max,sum;
                            QElapsedTimer  mstimer;
                            mstimer.start();
                            YZVision::Planenesscloud_3D *planeness=new YZVision::Planenesscloud_3D();
                            YZVision::Planenesscloud_3D::InputParam input= YZVision::Planenesscloud_3D::InputParam();
                            YZVision::Planenesscloud_3D::OutputParam output= YZVision::Planenesscloud_3D::OutputParam();
                            input.inputcloud=&cloudarrary[raw_cloud];
                            input.r_0=threshold;
                            input.m_StartPoint=start;
                            input.m_EndPoint=end;
                            result=planeness->planenesscloud(input,&output);
                            cloud=output.outputcloud;
                            min=output.min_p;
                            max=output.max_p;
                            sum=output.sum_p;
                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *item = new QTableWidgetItem;
                            item->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,item);
                            if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测量失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"测量失败");
                            }else{
                                cloudarrary[c_row]=cloud;
                                itemi->setText(2,"平整度为"+QString::number(min)+","+QString::number(max)+","+QString::number(sum));
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="截面积"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==5&&order_position.size()==12){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud;
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }
                    }

                    if(raw_cloud!=-1){
                        int raw1,raw2;
                        bool four,custom;

                        for(int z=1;z<order_s.size();z++){
                            QStringList a=order_s.at(z).split("=");
                            if(a.at(0)=="four"){
                                if(a.at(1).toInt()==0)
                                    four=false;
                                else
                                    four=true;
                            }else if(a.at(0)=="custom"){
                                if(a.at(1).toInt()==0)
                                    custom=false;
                                else
                                    custom=true;
                            }else if(a.at(0)=="custom_min"){
                                raw1=a.at(1).toInt()-1;
                            }else if(a.at(0)=="custom_max"){
                                raw2=a.at(1).toInt()-1;
                            }
                        }
                        start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                        end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());

                        YZVision::PointsXYZ left;
                        YZVision::PointsXYZ right;
                        float result=0;
                        int resu;
                        if(custom){
                            int raw1=ui->outline_custom_min->currentText().toInt()-1;
                            int raw2=ui->outline_custom_max->currentText().toInt()-1;

                            if((ui->ordertable->item(raw1,3)->text()=="找边缘点"
                                ||ui->ordertable->item(raw1,3)->text()=="找拐点")&&
                                (ui->ordertable->item(raw2,3)->text()=="找边缘点"
                                ||ui->ordertable->item(raw2,3)->text()=="找拐点")){

                                YZVision::PointXYZ p1,p2;
                                int z=0;
                                for(z=0;z<res[raw1].size();z++){
                                    if(cloudarrary[raw_cloud][0].y==res[raw1][z][1]){
                                        p1.setPoint(res[raw1][z][0],res[raw1][z][1],res[raw1][z][2]);
                                        break;
                                    }
                                }
                                if(z==res[raw1].size())
                                    p1.setPoint(res[raw1][0][0],cloudarrary[raw_cloud][0].y,res[raw1][0][2]);


                                for(z=0;z<res[raw2].size();z++){
                                    if(cloudarrary[raw_cloud][0].y==res[raw2][z][1]){
                                        p2.setPoint(res[raw2][z][0],res[raw2][z][1],res[raw2][z][2]);
                                        break;
                                    }
                                }
                                if(z==res[raw2].size())
                                    p2.setPoint(res[raw2][0][0],cloudarrary[raw_cloud][0].y,res[raw2][0][2]);

                                if(p2.x>p1.x){
                                    left=p1;
                                    right=p2;
                                }else{
                                    left=p2;
                                    right=p1;
                                }
                            }else{
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"自定义的点并非找拐点或找边缘点的结果");
                                ui->journal->insertPlainText("\r\n");
                                continue;
                            }
                        }else{
                            left=start;
                            right=end;
                        }
                        if(custom)
                            custom=false;
                        else
                            custom=true;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        YZVision::Outlinearea_3D *Outlinearea=new YZVision::Outlinearea_3D();
                        YZVision::Outlinearea_3D::InputParam input= YZVision::Outlinearea_3D::InputParam();
                        YZVision::Outlinearea_3D::OutputParam output= YZVision::Outlinearea_3D::OutputParam();
                        input.inputcloud=&cloudarrary[raw_cloud];
                        input.XXX=four;
                        input.x_0=custom;
                        input.m_StartPoint=left;
                        input.m_EndPoint=right;
                        resu=Outlinearea->outlinearea(input,&output);
                        result=output.s_0;
                        cloudarrary[c_row]=output.outputcloud_roi;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(resu==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测量失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"测量失败");
                        }else{
                            itemi->setText(2,"截面积为"+QString::number(fabsf(result)));
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="锚定"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==1&&order_position.size()==3){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            double x,y,z;
                            x=order_position.at(0).toDouble();
                            y=order_position.at(1).toDouble();
                            z=order_position.at(2).toDouble();
                            YZVision::PointXYZ point;
                            point.setPoint(x,y,z);

                            int result=0;
                            QElapsedTimer  mstimer;
                            mstimer.start();

                            YZVision::Transformation* transformation = NULL;
                            YZVision::MovePointCloud* p_movePointCloud = new YZVision::MovePointCloud();
                            transformation = p_movePointCloud;
                            YZVision::Transformation::InputParam input_Param;
                            YZVision::Transformation::OutputParam output_Param;
                            input_Param.input_cloud=&cloudarrary[raw_cloud];
                            input_Param.anchor_point=point;
                            input_Param.angle_xyz[0] = 0;
                            input_Param.angle_xyz[1] = 0;
                            input_Param.angle_xyz[2] = 0;
                            result = transformation->transform(input_Param, &output_Param);
                            cloudarrary[c_row]=output_Param.trans_point_cloud;

                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *item = new QTableWidgetItem;
                            item->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,item);
                            if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"锚定失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"锚定失败");
                            }else{
                                itemi->setText(2,"锚定成功");
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="矫正"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==2&&order_position.size()==3){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            QStringList a=order_s.at(1).split("=");
                            int l=a.at(1).toInt();
                            bool line;
                            if(l==1)
                                line=true;
                            else
                                line=false;
                            float xa;
                            float ya;
                            float za;
                            if(line){
                                xa=res[raw_cloud][1][0];
                                ya=res[raw_cloud][1][1];
                                za=res[raw_cloud][1][2];
                            }else{
                                double x,y,z;
                                x=order_position.at(0).toDouble();
                                y=order_position.at(1).toDouble();
                                z=order_position.at(2).toDouble();
                                xa=x/180*M_PI;
                                ya=y/180*M_PI;
                                za=z/180*M_PI;
                            }

                            int result=0;
                            QElapsedTimer  mstimer;
                            mstimer.start();

                            YZVision::Transformation* transformation = NULL;
                            YZVision::RotatePointCloud* p_rotatePointCloud = new YZVision::RotatePointCloud();
                            transformation = p_rotatePointCloud;
                            YZVision::Transformation::InputParam input_Param;
                            YZVision::Transformation::OutputParam output_Param;
                            input_Param.input_cloud=&cloudarrary[raw_cloud];
                            input_Param.angle_xyz[0] = xa;
                            input_Param.angle_xyz[1] = ya;
                            input_Param.angle_xyz[2] = za;
                            result = transformation->transform(input_Param, &output_Param);
                            cloudarrary[c_row]=output_Param.trans_point_cloud;

                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *item = new QTableWidgetItem;
                            item->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,item);
                            if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"矫正失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"矫正失败");
                            }else{
                                itemi->setText(2,"矫正成功");
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="零平面"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==3){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            int raw1,raw2;
                            for(int z=1;z<order_s.size();z++){
                                QStringList plane=order_s.at(z).split("=");

                                if(plane.at(0)=="plane1"){
                                    raw1=plane.at(1).toInt()-1;
                                }else if(plane.at(0)=="plane2"){
                                    raw2=plane.at(1).toInt()-1;
                                }
                            }
                            if(ui->ordertable->item(raw1,3)->text()=="裁切"&&
                                    ui->ordertable->item(raw2,3)->text()=="裁切"){
                                int r1,r2;
                                QStringList order_s1=ui->ordertable->item(raw1,4)->text().split(",");
                                QStringList s_data1=order_s1.at(0).split("=");
                                r1=s_data1.at(1).toInt()-1;
                                QStringList order_s2=ui->ordertable->item(raw2,4)->text().split(",");
                                QStringList s_data2=order_s2.at(0).split("=");
                                r2=s_data2.at(1).toInt()-1;
                                if(r1==raw_cloud&&r2==raw_cloud){
                                    int result;
                                    QElapsedTimer  mstimer;
                                    mstimer.start();

                                    YZVision::Cloudzeroplane_3D zeroplane;
                                    YZVision::Cloudzeroplane_3D::InputParam input= YZVision::Cloudzeroplane_3D::InputParam();
                                    YZVision::Cloudzeroplane_3D::OutputParam output= YZVision::Cloudzeroplane_3D::OutputParam();
                                    input.inputcloud=&cloudarrary[raw_cloud];
                                    input.inputcloud_1=&cloudarrary[raw1];
                                    input.inputcloud_2=&cloudarrary[raw2];
                                    result=zeroplane.cloudzeroplane(input,&output);
                                    cloudarrary[c_row]=output.outputcloud;

                                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                                    QTableWidgetItem *item = new QTableWidgetItem;
                                    item->setText(QString::number(time));
                                    ui->ordertable->setItem(c_row,2,item);

                                    if(result==0){
                                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"设置零平面失败");
                                        ui->journal->insertPlainText("\r\n");
                                        itemi->setText(2,"设置零平面失败");
                                    }else{
                                        itemi->setText(2,"设置零平面成功");
                                    }
                                }else{
                                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"截取的图源不为操作图源");
                                    ui->journal->insertPlainText("\r\n");
                                    itemi->setText(2,"截取的图源不为操作图源");
                                }
                            }else{
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"截取的图源不为操作图源");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"截取的图源不为裁切结果");
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="3d斑点高度"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
                if(order_s.size()==3&&order_position.size()==12){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            QStringList a=order_s.at(1).split("=");
                            double radius=a.at(1).toDouble();
                            QStringList b=order_s.at(2).split("=");
                            double number=b.at(1).toDouble();
                            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                            int result;
                            QElapsedTimer  mstimer;
                            mstimer.start();

                            YZVision::Cloudseg_3D *blob_3d=new YZVision::Cloudseg_3D();
                            YZVision::Cloudseg_3D::InputParam input= YZVision::Cloudseg_3D::InputParam();
                            YZVision::Cloudseg_3D::OutputParam output= YZVision::Cloudseg_3D::OutputParam();
                            input.inputcloud=&cloudarrary[raw_cloud];
                            input.r_0=radius;
                            input.num=number;
                            input.m_StartPoint=start;
                            input.m_EndPoint=end;
                            result=blob_3d->cloudseg(input,&output);
                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *item = new QTableWidgetItem;
                            item->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,item);
                            if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测量失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"测量失败");
                            }else{
                                cloudarrary[c_row]=cloudarrary[raw_cloud];
                                QString c="";
                                for(int z=0;z<output.out_seg.size()-1;z++){
                                    std::vector <float> temp;
                                    qDebug()<<output.num_0[z];
                                    temp.push_back(output.num_0[z]);
                                    c+="斑点"+QString::number(z+1)+"高度为"+QString::number(output.num_0[z])+"|";

                                    for(int x=0;x<output.out_seg[z].size();x++){
                                        temp.push_back(output.out_seg[z][x].x);
                                        temp.push_back(output.out_seg[z][x].y);
                                        temp.push_back(output.out_seg[z][x].z);
                                    }
                                    res[c_row].push_back(temp);
                                }
                                std::vector <float> temp;
                                int z=output.out_seg.size()-1;
                                qDebug()<<output.num_0[z];
                                temp.push_back(output.num_0[z]);
                                c+="斑点"+QString::number(z+1)+"高度为"+QString::number(output.num_0[z]);

                                for(int x=0;x<output.out_seg[z].size();x++){
                                    temp.push_back(output.out_seg[z][x].x);
                                    temp.push_back(output.out_seg[z][x].y);
                                    temp.push_back(output.out_seg[z][x].z);
                                }
                                res[c_row].push_back(temp);

                                itemi->setText(2,c);
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }else if (ui->ordertable->item(c_row,3)->text()=="轮廓点云"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==2){
                    QStringList s_data=order_s.at(0).split("=");
                    int raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                    }else{
                        if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                        }else{
                            QStringList a=order_s.at(1).split("=");
                            double y=a.at(1).toDouble();

                            int result;
                            QElapsedTimer  mstimer;
                            mstimer.start();

                            YZVision::Cloudoutline_3D Cloudoutline;
                            YZVision::Cloudoutline_3D::InputParam input= YZVision::Cloudoutline_3D::InputParam();
                            YZVision::Cloudoutline_3D::OutputParam output= YZVision::Cloudoutline_3D::OutputParam();

                            input.inputcloud=&cloudarrary[raw_cloud];
                            input.y_0=y;
                            result=Cloudoutline.outlinearea(input,&output);

                            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                            QTableWidgetItem *item = new QTableWidgetItem;
                            item->setText(QString::number(time));
                            ui->ordertable->setItem(c_row,2,item);
                            if(result==0){
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"轮廓提取失败");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"轮廓提取失败");
                            }else{
                                cloudarrary[c_row]=output.outputcloud;
                                itemi->setText(2,"轮廓提取成功");
                            }
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
        }
        ui->out_list->addTopLevelItem(itemi->clone());
//        item->addChild(itemi->clone());
    }
    ui->outwidget->show();
    ui->journalWidget->show();
}

//单步运行
void VGRibbonWindow::on_singerun_clicked()
{
    ui->out_list->clear();
    ui->variable_list->clear();
    ui->variable_list->close();
    ui->expansion->setText("⮝");
    if(ui->ordertable->rowCount()==0)
        return;
    pattern_changed=true;
//    ui->cameraWidget->show();
    ui->settingWidget->close();
//    QTreeWidgetItem *item=new QTreeWidgetItem;
//    item->setText(0,"result");
//    ui->out_list->addTopLevelItem(item);
    QTreeWidgetItem *itemi=new QTreeWidgetItem;

    if(c_row>ui->ordertable->rowCount()-1)
        c_row=0;
    itemi->setText(0,QString::number(c_row+1));
    itemi->setText(1,ui->ordertable->item(c_row,3)->text());

    if(ui->ordertable->item(c_row,3)->text()=="选择图像"){
        openimagepath=ui->ordertable->item(c_row,4)->text();
        if(openimagepath!=""){
            ui->origin_x->setText(ui->ordertable->item(c_row,5)->text());
            ui->origin_y->setText(ui->ordertable->item(c_row,6)->text());
            ui->image_rotate->setText(ui->ordertable->item(c_row,7)->text());
            QElapsedTimer  mstimer;
            mstimer.start();
            image[c_row].load(openimagepath);
            if(image[c_row].isNull()){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图像读取失败");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                on_image_rotate_editingFinished();
                float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                QTableWidgetItem *timei = new QTableWidgetItem;
                timei->setText(QString::number(time));
                ui->ordertable->setItem(c_row,2,timei);
                itemi->setText(2,"尺寸:("+QString::number(image[c_row].width())+","+QString::number(image[c_row].height())+"),"+ui->image_rotate->text()+"°");
            }
        }else{
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="二值化图像"){
        image[c_row]=empty_image;
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_image;
            bool Adaptive;
            QString upper_threshold,lower_threshold,forecolor,backcolor;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QString order_type=ui->ordertable->item(c_row,8)->text();
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            int type;
            YZVision::Basic2D::PointXY bounary[4];
              if(order_s.size()==6&&order_position.size()==5){
                for(int i=0;i<order_s.size();i++){
                    //将有效数据中以=分割,取=后面数据
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_image"){
                        raw_image=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                        if(image[raw_image].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="Adaptive"){
                        if(s_data.at(1)=="true")
                            Adaptive=true;
                        else
                            Adaptive=false;
                    }else if(s_data.at(0)=="upper_threshold")
                        upper_threshold=s_data.at(1);
                    else if(s_data.at(0)=="lower_threshold")
                        lower_threshold=s_data.at(1);
                    else if(s_data.at(0)=="forecolor")
                        forecolor=s_data.at(1);
                    else if(s_data.at(0)=="backcolor")
                        backcolor=s_data.at(1);
                }
                if(raw_image!=-1){
                    if(order_type=="矩形")
                        type=1;
                    else
                        type=2;
                    int x,y,height,width,rotate;
                    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    rotate=order_position.at(4).toInt();
                    boundary_position(type,x,y,width,height,rotate);
                    for(int j=0;j<4;j++){
                        bounary[j]=boundary[j];
                    }
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    int result;
                    Mat raw=Image2cvMat(image[raw_image].toImage());
                    YZVision::Binary_2D binary;
                    YZVision::Binary_2D::InputParam input= YZVision::Binary_2D::InputParam();
                    YZVision::Binary_2D::OutputParam output= YZVision::Binary_2D::OutputParam();
                    input.raw=raw;
                    input.Adaptive=Adaptive;
                    input.upper=upper_threshold.toInt();
                    input.lower=lower_threshold.toInt();
                    input.forecolor=forecolor.toInt();
                    input.backcolor=backcolor.toInt();
                    input.type=type;
                                  for(int j=0;j<4;j++){
                        input.position[j]=bounary[j];
                    }

                    result=binary.Binary(input,&output);
                    image[c_row]=QPixmap::fromImage(cvMat2Image(output.res));
                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *timei = new QTableWidgetItem;
                    timei->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,timei);
                    if(type==1)
                        itemi->setText(2,"矩形ROI坐标("+QString::number(x)+","+QString::number(y)+"),角度"+QString::number(rotate)+"°"+",尺寸["+QString::number(width)+","+QString::number(height)+"]");
                    else
                        itemi->setText(2,"ROI圆心("+QString::number(x)+","+QString::number(y)+")"+",直径"+QString::number(height));
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"部分设置为空");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="膨胀/腐蚀"){
        image[c_row]=empty_image;
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_image;
            bool expansion;
            QString Iteration_time;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QString order_type=ui->ordertable->item(c_row,8)->text();
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            int type;
            YZVision::Basic2D::PointXY bounary[4];
            if(order_s.size()==3&&order_position.size()==5){
                for(int i=0;i<order_s.size();i++){
                    //将有效数据中以=分割,取=后面数据
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_image"){
                        raw_image=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                        if(image[raw_image].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="Expansion"){
                        if(s_data.at(1)=="true")
                            expansion=true;
                        else
                            expansion=false;
                    }else if(s_data.at(0)=="Iteration_time")
                       Iteration_time=s_data.at(1);
                }
                if(raw_image!=-1){
                    if(order_type=="矩形")
                        type=1;
                    else
                        type=2;
                    int x,y,height,width,rotate;
                    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    rotate=order_position.at(4).toInt();
                    boundary_position(type,x,y,width,height,rotate);
                    for(int j=0;j<4;j++){
                        bounary[j]=boundary[j];
                    }
                    int result;
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    Mat raw=Image2cvMat(image[raw_image].toImage());
                    YZVision::Morphology_2D Expansion;
                    YZVision::Morphology_2D::InputParam input= YZVision::Morphology_2D::InputParam();
                    YZVision::Morphology_2D::OutputParam output= YZVision::Morphology_2D::OutputParam();
                    input.raw=raw;
                    input.Iteration_time=Iteration_time.toInt();
                    input.type=type;
                    for(int j=0;j<4;j++){
                        input.position[j]=bounary[j];
                    }

                    if(expansion){
                        result=Expansion.Expansion(input,&output);
                    }else{
                        result=Expansion.Corrosion(input,&output);
                    }
                    image[c_row]=QPixmap::fromImage(cvMat2Image(output.res));
                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *timei = new QTableWidgetItem;
                    timei->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,timei);
                    if(type==1)
                        itemi->setText(2,"矩形ROI坐标("+QString::number(x)+","+QString::number(y)+"),角度"+QString::number(rotate)+"°"+",尺寸["+QString::number(width)+","+QString::number(height)+"]");
                    else
                        itemi->setText(2,"ROI圆心("+QString::number(x)+","+QString::number(y)+")"+",直径"+QString::number(height));
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"部分设置为空");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="图像运算"){
        image[c_row]=empty_image;
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_image_1,raw_image_2;
            QString add_1,add_2,operation;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QString order_type=ui->ordertable->item(c_row,8)->text();
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            int type;
            YZVision::Basic2D::PointXY bounary[8];
            if(order_s.size()==5&&order_position.size()==8){
                for(int i=0;i<order_s.size();i++){
                    //将有效数据中以=分割,取=后面数据
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_image_1"){
                        raw_image_1=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image_1,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源1已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image_1=-1;
                            break;
                        }
                        if(image[raw_image_1].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image_1=-1;
                            break;
                        }
                    }if(s_data.at(0)=="raw_image_2"){
                        raw_image_2=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image_2,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image_2=-1;
                            break;
                        }
                        if(image[raw_image_2].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image_2=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="operation"){
                        operation=s_data.at(1);;
                    }else if(s_data.at(0)=="add_1")
                       add_1=s_data.at(1);
                    else if(s_data.at(0)=="add_2")
                       add_2=s_data.at(1);
                }
                if(raw_image_1!=-1&&raw_image_2!=-1){
                    if(order_type=="矩形")
                        type=1;
                    else
                        type=2;
                    int x,y,height,width,rotate,x2,y2,a;
                    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image_1].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image_1].height();
                    rotate=order_position.at(4).toInt();
                    boundary_position(type,x,y,width,height,rotate);
                    x2=order_position.at(5).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                    y2=order_position.at(6).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                    a=order_position.at(7).toInt();
                    for(int j=0;j<4;j++){
                        bounary[j]=boundary[j];
                    }
                    boundary_position(type,x2,y2,width,height,a);
                    for(int j=0;j<4;j++){
                        bounary[4+j]=boundary[j];
                    }
                    int result;
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    Mat raw1=Image2cvMat(image[raw_image_1].toImage());
                    Mat raw2=Image2cvMat(image[raw_image_2].toImage());
                    YZVision::Math_2D image_math;
                    YZVision::Math_2D::InputParam input= YZVision::Math_2D::InputParam();
                    YZVision::Math_2D::OutputParam output= YZVision::Math_2D::OutputParam();
                    input.Operands=raw1;
                    input.Operand=raw2;
                    input.add_1=add_1.toFloat();
                    input.add_2=add_2.toFloat();
                    input.operation=operation.toStdString();
                    input.type=type;
                    for(int j=0;j<8;j++){
                        input.position[j]=bounary[j];
                    }

                    result=image_math.imageMath(input,&output);
                    image[c_row]=QPixmap::fromImage(cvMat2Image(output.res));

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *timei = new QTableWidgetItem;
                    timei->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,timei);
                    if(type==1)
                        itemi->setText(2,"矩形ROI坐标("+QString::number(x)+","+QString::number(y)+"),角度"+QString::number(rotate)+"°"+",尺寸["+QString::number(width)+","+QString::number(height)+"]#"+
                                       "矩形ROI坐标("+QString::number(x2)+","+QString::number(y2)+"),角度"+QString::number(rotate)+"°"+",尺寸["+QString::number(width)+","+QString::number(height)+"]");
                    else
                        itemi->setText(2,"ROI圆心("+QString::number(x)+","+QString::number(y)+")"+",直径"+QString::number(height)+"#"+
                                       "ROI圆心("+QString::number(x2)+","+QString::number(y2)+"),直径"+QString::number(height));
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"部分设置为空");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="斑点查找"){
        image[c_row]=empty_image;
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_image;
            bool border,fill,width_f,height_f,area,number;
            int type,threshold_lower,threshold_upper,width_f_min,width_f_max,height_f_min,height_f_max,area_min,area_max,number_min,number_max;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QString order_type=ui->ordertable->item(c_row,8)->text();
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            int type_p;
            YZVision::Basic2D::PointXY bounary[4];
            if(order_s.size()==18&&order_position.size()==5){
                for(int i=0;i<order_s.size();i++){
                    //将有效数据中以=分割,取=后面数据
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_image"){
                        raw_image=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                        if(image[raw_image].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                    }if(s_data.at(0)=="type"){
                        type=s_data.at(1).toInt();
                    }else if(s_data.at(0)=="threshold_lower"){
                        threshold_lower=s_data.at(1).toInt();
                    }else if(s_data.at(0)=="threshold_upper")
                       threshold_upper=s_data.at(1).toInt();
                    else if(s_data.at(0)=="border")
                       if(s_data.at(1)=="true"){
                           border=true;
                       }else{
                           border=false;
                       }
                    else if(s_data.at(0)=="fill")
                       if(s_data.at(1)=="true"){
                           fill=true;
                       }else{
                           fill=false;
                       }
                    else if(s_data.at(0)=="width_f")
                       if(s_data.at(1)=="true"){
                           width_f=true;
                       }else{
                           width_f=false;
                       }
                    else if(s_data.at(0)=="width_f_min")
                        width_f_min=s_data.at(1).toInt();
                    else if(s_data.at(0)=="width_f_max")
                        width_f_max=s_data.at(1).toInt();
                    else if(s_data.at(0)=="height_f")
                       if(s_data.at(1)=="true"){
                           height_f=true;
                       }else{
                           height_f=false;
                       }
                    else if(s_data.at(0)=="height_f_min")
                        height_f_min=s_data.at(1).toInt();
                    else if(s_data.at(0)=="height_f_max")
                        height_f_max=s_data.at(1).toInt();
                    else if(s_data.at(0)=="area")
                       if(s_data.at(1)=="true"){
                           area=true;
                       }else{
                           area=false;
                       }
                    else if(s_data.at(0)=="area_min")
                        area_min=s_data.at(1).toInt();
                    else if(s_data.at(0)=="area_max")
                        area_max=s_data.at(1).toInt();
                    else if(s_data.at(0)=="number")
                       if(s_data.at(1)=="true"){
                           number=true;
                       }else{
                           number=false;
                       }
                    else if(s_data.at(0)=="number_min")
                        number_min=s_data.at(1).toInt();
                    else if(s_data.at(0)=="number_max")
                        number_max=s_data.at(1).toInt();
                }
                if(raw_image!=-1){
                    if(order_type=="矩形")
                        type_p=1;
                    else
                        type_p=2;
                    int x,y,height,width,rotate;
                    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    rotate=order_position.at(4).toInt();
                    boundary_position(type_p,x,y,width,height,rotate);
                    for(int j=0;j<4;j++){
                        bounary[j]=boundary[j];
                    }
                    int resu;
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    Mat raw=Image2cvMat(image[raw_image].toImage());
                    YZVision::FindBlob_2D blob;
                    YZVision::FindBlob_2D::InputParam input= YZVision::FindBlob_2D::InputParam();
                    YZVision::FindBlob_2D::OutputParam result= YZVision::FindBlob_2D::OutputParam();
                    input.raw=raw;
                    input.threshold_lower=threshold_lower;
                    input.threshold_upper=threshold_upper;
                    input.type=type;
                    input.border=border;
                    input.fill=fill;
                    input.type_p=type_p;
                    for(int j=0;j<4;j++){
                        input.position[j]=bounary[j];
                    }
                    input.width_f=width_f;
                    input.width_f_min=width_f_min;
                    input.width_f_max=width_f_max;
                    input.height_f=height_f;
                    input.height_f_min=height_f_min;
                    input.height_f_max=height_f_max;
                    input.area=area;
                    input.area_min=area_min;
                    input.area_max=area_max;
                    input.number=number;
                    input.number_min=number_min;
                    input.number_max=number_max;

                    resu=blob.FindBlob(input,&result);
                    image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *timei = new QTableWidgetItem;
                    timei->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,timei);
                    QString c="",n;
                    std::vector<std::vector <float>> temp;
                    if(result.areas.size()>0){
                        for(unsigned long long z=0;z<result.areas.size()-1;z++){
                            c+="宽度"+QString::number(result.widths[z])+" ";
                            c+="高度"+QString::number(result.heights[z])+" ";
                            c+="面积"+QString::number(result.areas[z])+" ";
                            for(unsigned long long x=0;x<result.resContours[z].size()-1;x++ )
                                c+="("+QString::number(result.resContours[z][x].x)+","+QString::number(result.resContours[z][x].y)+")|";
                            c+="("+QString::number(result.resContours[z][result.resContours[z].size()-1].x)+","+QString::number(result.resContours[z][result.resContours[z].size()-1].y)+")";
                            c+="#";
                            std::vector <float> temp_widths;
                            temp_widths.push_back(result.widths[z]);
                            temp_widths.push_back(result.heights[z]);
                            temp_widths.push_back(result.areas[z]);
                            temp.push_back(temp_widths);
                            std::vector <float> temp_points;
                            for(unsigned long long x=0;x<result.resContours[z].size();x++){
                                temp_points.push_back(result.resContours[z][x].x);
                                temp_points.push_back(result.resContours[z][x].y);
                            }
                            temp.push_back(temp_points);
                        }
                        unsigned long long z=result.areas.size()-1;
                        c+="宽度"+QString::number(result.widths[z])+" ";
                        c+="高度"+QString::number(result.heights[z])+" ";
                        c+="面积"+QString::number(result.areas[z])+" ";
                        for(unsigned long long x=0;x<result.resContours[z].size()-1;x++ )
                            c+="("+QString::number(result.resContours[z][x].x)+","+QString::number(result.resContours[z][x].y)+")|";
                        c+="("+QString::number(result.resContours[z][result.resContours[z].size()-1].x)+","+QString::number(result.resContours[z][result.resContours[z].size()-1].y)+")";
                        std::vector <float> temp_widths;
                        temp_widths.push_back(result.widths[z]);
                        temp_widths.push_back(result.heights[z]);
                        temp_widths.push_back(result.areas[z]);
                        temp.push_back(temp_widths);
                        std::vector <float> temp_points;
                        for(unsigned long long x=0;x<result.resContours[z].size();x++){
                            temp_points.push_back(result.resContours[z][x].x);
                            temp_points.push_back(result.resContours[z][x].y);
                        }
                        temp.push_back(temp_points);
                    }else{
                        c="未找到匹配项";
                    }
                    res[c_row]=temp;
                    itemi->setText(2,c);
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"部分设置为空");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="线查找"){
        image[c_row]=empty_image;
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_image;
            int threshold_lower,threshold_upper,type,border,ratio,Subpixel;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QString order_type=ui->ordertable->item(c_row,8)->text();
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            YZVision::Basic2D::PointXY bounary[4];
            if(order_s.size()==7&&order_position.size()==5){
                for(int i=0;i<order_s.size();i++){
                    //将有效数据中以=分割,取=后面数据
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_image"){
                        raw_image=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                        if(image[raw_image].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="threshold_lower"){
                        threshold_lower=s_data.at(1).toInt();
                    }else if(s_data.at(0)=="threshold_upper")
                       threshold_upper=s_data.at(1).toInt();
                    else if(s_data.at(0)=="type")
                        type=s_data.at(1).toInt();
                    else if(s_data.at(0)=="border")
                        border=s_data.at(1).toInt();
                    else if(s_data.at(0)=="ratio")
                        ratio=s_data.at(1).toInt();
                    else if(s_data.at(0)=="Subpixel")
                        Subpixel=s_data.at(1).toInt();
                }
                if(raw_image!=-1){
                    int x,y,height,width,rotate;
                    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    rotate=order_position.at(4).toInt();
                    boundary_position(1,x,y,width,height,rotate);
                    for(int j=0;j<4;j++){
                        bounary[j]=boundary[j];
                    }
                    int resu;
                    QElapsedTimer  mstimer;
                    mstimer.start();

                    Mat raw=Image2cvMat(image[raw_image].toImage());
                    YZVision::FindLine_2D line_find;
                    YZVision::FindLine_2D::InputParam input= YZVision::FindLine_2D::InputParam();
                    YZVision::FindLine_2D::OutputParam result= YZVision::FindLine_2D::OutputParam();
                    input.raw=raw;
                    input.threshold_lower=threshold_lower;
                    input.threshold_upper=threshold_upper;
                    input.type=type;
                    input.border=border;
                    input.ratio=ratio;
                    input.subpixel=Subpixel;
                    for(int j=0;j<4;j++){
                        input.position[j]=bounary[j];
                    }
                    resu=line_find.FindLine(input,&result);
                    image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));
                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *timei = new QTableWidgetItem;
                    timei->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,timei);
                    QString c="",n;
                    if(result.code==0){
                        double x1,x2,y1,y2,t,a;
                        x1=result.l.a.x;
                        y1=result.l.a.y;
                        x2=result.l.b.x;
                        y2=result.l.b.y;
                        t=sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
                        a=atan2((y1-y2),(x2-x1));
                        a=a*180/M_PI;
                        c+="长度"+QString::number(t)+",角度"+QString::number(a)+"° (";
                        c+="起始点"+QString::number(x1)+","+QString::number(y1)+"),终点("+QString::number(x2)+","+QString::number(y2)+")";
                        std::vector<std::vector <float>> temp;
                        std::vector <float> temp_start;
                        temp_start.push_back(result.l.a.x);
                        temp_start.push_back(result.l.a.y);
                        temp.push_back(temp_start);
                        std::vector <float> temp_end;
                        temp_end.push_back(result.l.b.x);
                        temp_end.push_back(result.l.b.y);
                        temp.push_back(temp_end);
                        std::vector <float> samplePts;
                        for(unsigned long long z=0;z<result.samplePts.size();z++){
                            samplePts.push_back(result.samplePts[z].x);
                            samplePts.push_back(result.samplePts[z].y);
                        }
                        temp.push_back(samplePts);
                        res[c_row]=temp;
                    }else{
                        c="未找到匹配项";
                    }
                    itemi->setText(2,c);
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"部分设置为空");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="圆查找"){
        image[c_row]=empty_image;
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_image;
            int threshold_lower,threshold_upper,type,border,ratio,ratio_min,ratio_max;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            YZVision::Basic2D::PointXY bounary[4];
            if(order_s.size()==8&&order_position.size()==5){
                for(int i=0;i<order_s.size();i++){
                    //将有效数据中以=分割,取=后面数据
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_image"){
                        raw_image=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                        if(image[raw_image].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="threshold_lower"){
                        threshold_lower=s_data.at(1).toInt();
                    }else if(s_data.at(0)=="threshold_upper")
                       threshold_upper=s_data.at(1).toInt();
                    else if(s_data.at(0)=="type")
                        type=s_data.at(1).toInt();
                    else if(s_data.at(0)=="border")
                        border=s_data.at(1).toInt();
                    else if(s_data.at(0)=="ratio")
                        ratio=s_data.at(1).toInt();
                    else if(s_data.at(0)=="ratio_min")
                        ratio_min=s_data.at(1).toInt();
                    else if(s_data.at(0)=="ratio_max")
                        ratio_max=s_data.at(1).toInt();
                }
                if(raw_image!=-1){
                    int x,y,height,width;
                    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    boundary_position(2,x,y,width,height,0);
                    for(int j=0;j<4;j++){
                        bounary[j]=boundary[j];
                    }
                    int resu;
                    float c1,c2;
                    c1=bounary[0].x-bounary[2].x;
                    c2=bounary[0].x-bounary[1].x;
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    Mat raw=Image2cvMat(image[raw_image].toImage());
                    YZVision::FindCircle_2D Circle_find;
                    YZVision::FindCircle_2D::InputParam input= YZVision::FindCircle_2D::InputParam();
                    YZVision::FindCircle_2D::OutputParam result= YZVision::FindCircle_2D::OutputParam();
                    input.raw=raw;
                    input.threshold_lower=threshold_lower;
                    input.threshold_upper=threshold_upper;
                    input.type=type;
                    input.border=border;
                    input.ratio=ratio;
                    input.radius_min=ratio_min;
                    input.radius_max=ratio_max;
                    input.circleCenter=bounary[0];
                    input.innerRadius=c1;
                    input.outerRadius=c2;

                    resu=Circle_find.FindCircle(input,&result);
                    image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *timei = new QTableWidgetItem;
                    timei->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,timei);
                    QString c="",n;
                    if(result.code==0){
                        std::vector<std::vector <float>> temp;
                        std::vector <float> temp_cir1;
                        temp_cir1.push_back(result.circle1.x);
                        temp_cir1.push_back(result.circle1.y);
                        temp_cir1.push_back(result.circle1.r);
                        temp.push_back(temp_cir1);
                        std::vector <float> temp_samplePts;
                        for(long long z=0;z<result.samplePts.size();z++){
                            temp_samplePts.push_back(result.samplePts[z].x());
                            temp_samplePts.push_back(result.samplePts[z].y());
                        }
                        temp.push_back(temp_samplePts);
                        c+="圆心("+QString::number(result.circle1.x)+","+QString::number(result.circle1.y)+")半径"+QString::number(result.circle1.r);
                        if(type>3){
                            c+="#内圆心("+QString::number(result.circle2.x)+","+QString::number(result.circle2.y)+")半径"+QString::number(result.circle2.r);
                            std::vector <float> temp_cir2;
                            temp_cir2.push_back(result.circle2.x);
                            temp_cir2.push_back(result.circle2.y);
                            temp_cir2.push_back(result.circle2.r);
                            temp.push_back(temp_cir2);
                            std::vector <float> temp_samplePts2;
                            for(long long z=0;z<result.samplePts2.size();z++){
                                temp_samplePts2.push_back(result.samplePts2[z].x());
                                temp_samplePts2.push_back(result.samplePts2[z].y());
                            }
                            temp.push_back(temp_samplePts2);
                        }
                        res[c_row]=temp;
                    }else{
                        c="未找到匹配项";
                    }
                    itemi->setText(2,c);
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"部分设置为空");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="模板匹配"){
        image[c_row]=empty_image;
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_type=ui->ordertable->item(c_row,8)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            int raw_image,raw_image2;
            int rotate,rotate_min,rotate_max,zoom;
            qreal zoom_min,zoom_max;
            int type,type1,type2;
            int score,number;
            int x,y,width,height,roi_a,x2,y2,width2,height2,roi_a2;
            YZVision::Basic2D::PointXY bounary[8];
            if(order_s.size()==11&&order_position.size()==10){
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_image_1"){
                        raw_image=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源1已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                        if(image[raw_image].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源1为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                    }if(s_data.at(0)=="raw_image_2"){
                        raw_image2=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image2,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                        if(image[raw_image2].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_image=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="rotate")
                        rotate=s_data.at(1).toInt();
                    else if(s_data.at(0)=="rotate_min")
                        rotate_min=s_data.at(1).toInt();
                    else if(s_data.at(0)=="rotate_max")
                        rotate_max=s_data.at(1).toInt();
                    else if(s_data.at(0)=="zoom")
                        zoom=s_data.at(1).toInt();
                    else if(s_data.at(0)=="zoom_min")
                        zoom_min=s_data.at(1).toDouble();
                    else if(s_data.at(0)=="zoom_max")
                        zoom_max=s_data.at(1).toDouble();
                    else if(s_data.at(0)=="type")
                        type=s_data.at(1).toInt();
                    else if(s_data.at(0)=="search")
                        score=s_data.at(1).toInt();
                    else if(s_data.at(0)=="number")
                        number=s_data.at(1).toInt();
                }
                if(raw_image!=-1){
                    if(order_type.at(0)=="矩形")
                        type1=1;
                    else
                        type1=2;
                    if(order_type.at(1)=="矩形")
                        type2=1;
                    else
                        type2=2;
                    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();

                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    roi_a=order_position.at(4).toInt();

                    x2=order_position.at(5).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
                    y2=order_position.at(6).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
                    width2=order_position.at(7).toInt();
                    if(width2==0)
                        width2=image[raw_image2].width();
                    height2=order_position.at(8).toInt();
                    if(height2==0)
                        height2=image[raw_image2].height();
                    roi_a2=order_position.at(9).toInt();
                    boundary_position(type1,x,y,width,height,roi_a);
                    for(int j=0;j<4;j++){
                        bounary[j]=boundary[j];
                    }
                    boundary_position(type2,x2,y2,width2,height2,roi_a2);
                    for(int j=0;j<4;j++){
                        bounary[4+j]=boundary[j];
                    }
                    int resu;
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    Mat raw1=Image2cvMat(image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].toImage());
                    Mat raw2=Image2cvMat(image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].toImage());
                    YZVision::MatchTemplate_2D Pattern;
                    YZVision::MatchTemplate_2D::InputParam input= YZVision::MatchTemplate_2D::InputParam();
                    YZVision::MatchTemplate_2D::OutputParam result= YZVision::MatchTemplate_2D::OutputParam();
                    input.train_changed=pattern_changed;
                    input.train=raw1;
                    input.search=raw2;
                    input.rotate=ui->Pattern_find_rotate->currentIndex();
                    input.rotate_min=ui->Pattern_find_rotate_min->text().toInt();
                    input.rotate_max=ui->Pattern_find_rotate_max->text().toInt();
                    input.zoom=ui->Pattern_find_zoom->currentIndex();
                    input.zoom_min=ui->Pattern_find_zoom_min->text().toDouble();
                    input.zoom_max=ui->Pattern_find_zoom_max->text().toInt();
                    input.type=ui->Pattern_find_type->currentIndex();
                    input.scores=ui->Pattern_find_min_search->text().toInt();
                    input.number=number;
                    input.type1=type1;
                    input.type2=type2;
                    for(int j=0;j<8;j++){
                        input.position[j]=bounary[j];
                    }
                    resu=Pattern.MatchTemplate(input,&result);

                    image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));//                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;

                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    QString c="";
                    std::vector<std::vector <float>> temp;
                    if(!result.code){
                        if(result.tems.size()>1){
                            for(int z=0;z<result.tems.size()-1;z++){
                                c+="坐标("+QString::number(result.tems[z].x)+","+QString::number(result.tems[z].y)+") ";
                                c+="相似性"+QString::number(result.tems[z].similarity)+" ";
//                                    c+="尺寸"+QString::number(result.tems[z].w)+"X"+QString::number(result.tems[z].h)+" ";
                                c+="角度"+QString::number(result.tems[z].angle)+" ";
                                c+="缩放比"+QString::number(result.tems[z].scale)+"#";
                                std::vector <float> temp_size;
                                temp_size.push_back(result.tems[z].x);
                                temp_size.push_back(result.tems[z].y);
                                temp_size.push_back(result.tems[z].similarity);
                                temp_size.push_back(result.tems[z].w);
                                temp_size.push_back(result.tems[z].h);
                                temp_size.push_back(result.tems[z].angle);
                                temp_size.push_back(result.tems[z].scale);
                                temp.push_back(temp_size);
                                std::vector <float> features;
                                for(long long x=0;x<result.tems[z].features.size();x++){
                                    features.push_back(result.tems[z].features[x].x);
                                    features.push_back(result.tems[z].features[x].y);
                                    features.push_back(result.tems[z].features[x].lbl);
                                }
                                temp.push_back(features);
                            }
                        }
                        int z=result.tems.size()-1;
                        c+="坐标("+QString::number(result.tems[z].x)+","+QString::number(result.tems[z].y)+") ";
                        c+="相似性"+QString::number(result.tems[z].similarity)+" ";
                        c+="尺寸"+QString::number(result.tems[z].w)+"X"+QString::number(result.tems[z].h)+" ";
                        c+="角度"+QString::number(result.tems[z].angle)+" ";
                        c+="缩放比"+QString::number(result.tems[z].scale);
                        std::vector <float> temp_size;
                        temp_size.push_back(result.tems[z].x);
                        temp_size.push_back(result.tems[z].y);
                        temp_size.push_back(result.tems[z].similarity);
                        temp_size.push_back(result.tems[z].w);
                        temp_size.push_back(result.tems[z].h);
                        temp_size.push_back(result.tems[z].angle);
                        temp_size.push_back(result.tems[z].scale);
                        temp.push_back(temp_size);
                        std::vector <float> features;
                        for(long long x=0;x<result.tems[z].features.size();x++){
                            features.push_back(result.tems[z].features[x].x);
                            features.push_back(result.tems[z].features[x].y);
                            features.push_back(result.tems[z].features[x].lbl);
                        }
                        temp.push_back(features);
                        res[c_row]=temp;
                    }else{
                        c="未找到匹配项";
                    }
                    itemi->setText(2,c);
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"部分设置为空");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="测距"){
        image[c_row]=empty_image;
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_image,raw_image_2;
            double startx,starty,endx,endy;
            QStringList order_a=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_a.size()==2){
                QStringList order_s=order_a.at(0).split("=");
                if(order_s.at(0)=="raw_image"){
                    raw_image=order_s.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_image,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_image=-1;
                    }else if(image[raw_image].isNull()){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_image=-1;
                    }else if(ui->ordertable->item(raw_image,3)->text()!="圆查找"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源不是圆查找结果");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_image=-1;
                    }
                }
                QStringList order_s2=order_a.at(1).split("=");
                if(order_s2.at(0)=="raw_image_2"){
                    raw_image_2=order_s2.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_image_2,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_image_2=-1;
                    }else if(image[raw_image_2].isNull()){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_image_2=-1;
                    }else if(ui->ordertable->item(raw_image_2,3)->text()!="圆查找"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源不是圆查找结果");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_image_2=-1;
                    }
                }
                if(raw_image!=-1&&raw_image_2!=-1){
                    startx=res[raw_image][0][0];
                    starty=res[raw_image][0][1];
                    endx=res[raw_image_2][0][0];
                    endy=res[raw_image_2][0][1];
                    YZVision::Basic2D::PointXY start(startx,starty),end(endx,endy);
                    int resu;
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    Mat raw=Image2cvMat(image[raw_image ].toImage());
                    YZVision::CalcDistance_2D length;
                    YZVision::CalcDistance_2D::InputParam input= YZVision::CalcDistance_2D::InputParam();
                    YZVision::CalcDistance_2D::OutputParam result= YZVision::CalcDistance_2D::OutputParam();
                    input.raw=raw;
                    input.startpoint=start;
                    input.endpoint=end;
                    resu=length.calc_distance(input,&result);
                    image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *timei = new QTableWidgetItem;
                    timei->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,timei);
                    std::vector<std::vector <float>> temp;
                    std::vector <float> temp_size;
                    QString c="",n;
                    if(result.code==0){
                        c+="起点("+QString::number(startx)+","+QString::number(starty)+"),终点("+
                                QString::number(endx)+","+QString::number(endy)+") 长度="+QString::number(result.l);
                        temp_size.push_back(result.l);
                        temp.push_back(temp_size);
                        res[c_row]=temp;
                    }else{
                        c="未找到匹配项";
                    }
                    itemi->setText(2,c);
                }
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="面积计算"){
        image[c_row]=empty_image;
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_image;
            QStringList order=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_s=order.at(0).split("=");
             if(order_s.at(0)=="raw_image"){
                raw_image=order_s.at(1).toInt()-1;
                if(ui->ordertable->item(raw_image,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                    raw_image=-1;
                }else if(image[raw_image].isNull()){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                    raw_image=-1;
                }else if(ui->ordertable->item(raw_image,3)->text()!="斑点查找"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源并不是斑点查找");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                    raw_image=-1;
                }
            }
            if(raw_image!=-1){
                QStringList order_a=order.at(1).split("=");
                int raw_blob=order_a.at(1).toInt()-1;
                YZVision::Pts blob;
                for(long long z=0;z<res[raw_image][raw_blob*2+1].size()/2;z++){
                    YZVision::pt a(res[raw_image][raw_blob*2+1][z*2],res[raw_image][raw_blob*2+1][z*2+1]);
                    blob.push_back(a);
                }
                QElapsedTimer  mstimer;
                mstimer.start();
                int resu;
                YZVision::CalcArea_2D area;
                YZVision::CalcArea_2D::InputParam input= YZVision::CalcArea_2D::InputParam();
                YZVision::CalcArea_2D::OutputParam output= YZVision::CalcArea_2D::OutputParam();
                input.contour=blob;
                resu=area.calc_area(input,&output);
                double result=output.area;
                float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                QTableWidgetItem *timei = new QTableWidgetItem;
                timei->setText(QString::number(time));
                ui->ordertable->setItem(c_row,2,timei);
                image[c_row]=image[raw_image];
                std::vector<std::vector <float>> temp;
                std::vector <float> temp_size;
                QString c="",n;
                if(resu!=0){
                    c+="面积="+QString::number(result);
                    temp_size.push_back(result);
                    temp.push_back(temp_size);
                    res[c_row]=temp;
                }else{
                    c="未确定斑点区域";
                }
                itemi->setText(2,c);
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="图片拼接"){
        image[c_row]=empty_image;
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无图像输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_image_1,raw_image_2;
            int up,low,number;
            bool black;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==6){
                for(int i=0;i<order_s.size();i++){
                    //将有效数据中以=分割,取=后面数据
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw"){
                        raw_image_1=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image_1,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源1已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"图源1已被停用");
                            raw_image_1=-1;
                            break;
                        }
                        if(image[raw_image_1].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源1已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"图源1已被停用");
                            raw_image_1=-1;
                            break;
                        }
                    }if(s_data.at(0)=="raw_2"){
                        raw_image_2=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_image_2,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"图源2已被停用");
                            raw_image_2=-1;
                            break;
                        }
                        if(image[raw_image_2].isNull()){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"图源2已被停用");
                            raw_image_2=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="upper_threshold")
                       up=s_data.at(1).toInt();
                    else if(s_data.at(0)=="lower_threshold")
                       low=s_data.at(1).toInt();
                    else if(s_data.at(0)=="number")
                       number=s_data.at(1).toInt();
                    else if(s_data.at(0)=="black"){
                       if(s_data.at(1)=="1")
                           black=true;
                       else
                           black=false;
                    }
                }
                if(raw_image_1!=-1&&raw_image_2!=-1){
                    Mat raw1,raw2;
                    raw1=Image2cvMat(image[raw_image_1].toImage());
                    raw2=Image2cvMat(image[raw_image_2].toImage());
                    int result;
                    QElapsedTimer  mstimer;
                    mstimer.start();

                    YZVision::Imagesplicing_2D Imagesplicing;
                    YZVision::Imagesplicing_2D::InputParam input= YZVision::Imagesplicing_2D::InputParam();
                    YZVision::Imagesplicing_2D::OutputParam output= YZVision::Imagesplicing_2D::OutputParam();
                    input.srcImage1=raw1;
                    input.srcImage2=raw2;
                    input.min_0=number;
                    input.x_0=black;
                    input.down=low;
                    input.up=up;
                    result =Imagesplicing.imagesplicing(input,&output);
                    image[c_row]=QPixmap::fromImage(cvMat2Image(output.outImage));

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);

                    if(result==1){

                        itemi->setText(2,"无输出参数");
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"图片拼接失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"图片拼接失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"部分设置为空");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="选择点云"){
        cloudarrary[c_row].resize(0);
        opencloudpath=ui->ordertable->item(c_row,4)->text();
        if(opencloudpath==""){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{

            QFileInfo file;
            file=QFileInfo(opencloudpath);
            QString path1=qApp->applicationDirPath()+"/1.txt";
            QString path=qApp->applicationDirPath()+"/1.pcd";
            if(file.suffix()=="txt"){
                qDebug()<<QFile::remove(path);
                qDebug()<<QFile::remove(path1);
                QFile::copy(opencloudpath,path1);
            }else{
                qDebug()<<QFile::remove(path);
                QFile::copy(opencloudpath,path);
                path1=path;
            }

            QElapsedTimer  mstimer;
            mstimer.start();
            YZVision::Readcloud_3D read;
            YZVision::Readcloud_3D::InputParam input= YZVision::Readcloud_3D::InputParam();
            YZVision::Readcloud_3D::OutputParam output= YZVision::Readcloud_3D::OutputParam();
            input.read=path1.toStdString();
            input.save=path.toStdString();

            read.readcloud(input,&output);
            cloudarrary[c_row]=output.outputcloud;
            qDebug()<<QFile::remove(path);
            qDebug()<<QFile::remove(path1);

            float time = (double)mstimer.nsecsElapsed()/(double)1000000;
            QTableWidgetItem *timei = new QTableWidgetItem;
            timei->setText(QString::number(time));
            ui->ordertable->setItem(c_row,2,timei);
            if(cloudarrary[c_row].size()==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无法读取点云");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无法读取点云");
            }else{
                itemi->setText(2,"点云读取成功");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="找边缘点"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==2&&order_position.size()==12){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        QStringList a=order_s.at(1).split("=");
                        int direction=a.at(1).toInt();
                        YZVision::ROIProbeDirection d;
                        if(direction==0)
                            d=YZVision::ROIProbeDirection::RIGHT;
                        else if (direction==1)
                            d=YZVision::ROIProbeDirection::LEFT;
                        else if (direction==2)
                            d=YZVision::ROIProbeDirection::UP;
                        else if (direction==3)
                            d=YZVision::ROIProbeDirection::DOWN;
                        start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                        end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                        int result;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        YZVision::vPointsXYZ edgePointCloud;
                        YZVision::Feature* feature = NULL;
                        YZVision::EdgePoint_3D* p_edgePoint = new YZVision::EdgePoint_3D();
                        feature = p_edgePoint;
                        YZVision::Feature::InputParam input= YZVision::Feature::InputParam();
                        YZVision::Feature::OutputParam output= YZVision::Feature::OutputParam();
                        input.inputCloud=&cloudarrary[raw_cloud];
                        input.serachDir=d;
                        input.m_StartPoint=start;
                        input.m_EndPoint=end;
                        result=feature->findFeature(input,&output);
                        cloudarrary[c_row]=cloudarrary[raw_cloud];
                        edgePointCloud=output.outputPoints;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        if(result==1){
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            itemi->setText(2,"找边缘点成功");
                            std::vector<std::vector <float>> t;
                            for(long z=0;z<edgePointCloud.size();z++){
                                std::vector <float> t_a;
                                t_a.push_back(edgePointCloud[z].x);
                                t_a.push_back(edgePointCloud[z].y);
                                t_a.push_back(edgePointCloud[z].z);
                                t.push_back(t_a);
                            }
                            res[c_row]=t;
                        }else if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"查找失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"找边缘点失败");
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="找拐点"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==3&&order_position.size()==12){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        QStringList a=order_s.at(1).split("=");
                        int direction=a.at(1).toInt();
                        YZVision::ROIProbeDirection d;
                        if(direction==0)
                            d=YZVision::ROIProbeDirection::RIGHT;
                        else if (direction==1)
                            d=YZVision::ROIProbeDirection::LEFT;
                        else if (direction==2)
                            d=YZVision::ROIProbeDirection::UP;
                        else if (direction==3)
                            d=YZVision::ROIProbeDirection::DOWN;
                        QStringList b=order_s.at(2).split("=");
                        double threshold=b.at(1).toDouble();
                        start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                        end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                        int result;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        YZVision::vPointsXYZ turningPointCloud;
                        YZVision::Feature* feature = NULL;
                        YZVision::TurningPoint_3D* p_turnPoint = new YZVision::TurningPoint_3D();
                        feature = p_turnPoint;
                        YZVision::Feature::InputParam input= YZVision::Feature::InputParam();
                        YZVision::Feature::OutputParam output= YZVision::Feature::OutputParam();
                        input.inputCloud=&cloudarrary[raw_cloud];
                        input.serachDir=d;
                        input.m_StartPoint=start;
                        input.m_EndPoint=end;
                        input.z_thres=threshold;
                        result=feature->findFeature(input,&output);
                        cloudarrary[c_row]=cloudarrary[raw_cloud];
                        turningPointCloud=output.outputPoints;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);

                        if(result==1){
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            itemi->setText(2,"找拐点成功");
                            std::vector<std::vector <float>> t;
                            for(long z=0;z<turningPointCloud.size();z++){
                                std::vector<float> t_a;
                                t_a.push_back(turningPointCloud[z].x);
                                t_a.push_back(turningPointCloud[z].y);
                                t_a.push_back(turningPointCloud[z].z);
                                t.push_back(t_a);
                            }
                            res[c_row]=t;
                        }else if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"查找失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"找拐点失败");
                        }

                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="找线"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==3&&order_position.size()==12){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        QStringList a=order_s.at(1).split("=");
                        int direction=a.at(1).toInt();
                        QStringList b=order_s.at(2).split("=");
                        int type=b.at(1).toInt();
                        YZVision::ROIProbeDirection d;
                        if(direction==0)
                            d=YZVision::ROIProbeDirection::RIGHT;
                        else if (direction==1)
                            d=YZVision::ROIProbeDirection::LEFT;
                        else if (direction==2)
                            d=YZVision::ROIProbeDirection::UP;
                        else if (direction==3)
                            d=YZVision::ROIProbeDirection::DOWN;
                        start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                        end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());

                        int result;
                        std::vector<int> index;
                        std::vector<float> Coeffients;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        YZVision::Segmentation* segmentation = NULL;
                        YZVision::LineSegment* p_lineSeg = new YZVision::LineSegment();
                        segmentation = p_lineSeg;
                        YZVision::Segmentation::InputParam input_Param;
                        YZVision::Segmentation::OutputParam output_Param;
                        input_Param.inputCloud = &cloudarrary[raw_cloud];
                        input_Param.serachDir = d;
                        input_Param.m_StartPoint = start;
                        input_Param.m_EndPoint = end;
                        input_Param.distance_Threshold = 0.5;
                        input_Param.max_iteratios = 100;
                        input_Param.z_threshold=0.1;
                        if(type==1){
                            input_Param.line_seg_option=YZVision::Segmentation::LineSegOption::FIT_LINE_BASE_ON_TURNINGPOINTS;
                        }

                        result = segmentation->segment(input_Param, &output_Param);
                        index=output_Param.modelInliers;
                        Coeffients=output_Param.modelCoeffients;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"找线失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"找线失败");
                        }else{
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            std::vector<std::vector <float>> t;
                            std::vector <float> t_a;
                            for(int x=0;x<Coeffients.size();x++){
                                t_a.push_back(Coeffients[x]);
                                qDebug()<<Coeffients[x];
                            }
                            t.push_back(t_a);
                            std::vector <float> t_r;
                            t_r.push_back(output_Param.xyz_angles[0]);
                            t_r.push_back(output_Param.xyz_angles[1]);
                            t_r.push_back(output_Param.xyz_angles[2]);
                            t.push_back(t_r);
                            res[c_row]=t;
                            itemi->setText(2,"找线成功");
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="找面"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==2&&order_position.size()==12){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        QStringList a=order_s.at(1).split("=");
                        int direction=a.at(1).toInt();
                        YZVision::ROIProbeDirection d;
                        if(direction==0)
                            d=YZVision::ROIProbeDirection::FRONT;
                        else if (direction==1)
                            d=YZVision::ROIProbeDirection::BACK;
                        start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                        end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                        int result;
                        std::vector<int> index;
                        std::vector<float> Coeffients;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        YZVision::Segmentation* segmentation = NULL;
                        YZVision::PlaneSegment* p_planeSeg = new YZVision::PlaneSegment();
                        segmentation = p_planeSeg;
                        YZVision::Segmentation::InputParam input_Param;
                        YZVision::Segmentation::OutputParam output_Param;
                        input_Param.inputCloud = &cloudarrary[raw_cloud];
                        input_Param.serachDir = d;
                        input_Param.m_StartPoint = start;
                        input_Param.m_EndPoint = end;
                        input_Param.distance_Threshold = 0.5;
                        input_Param.max_iteratios = 100;

                        result = segmentation->segment(input_Param, &output_Param);
                        index=output_Param.modelInliers;
                        Coeffients=output_Param.modelCoeffients;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"查找失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"找面失败");
                        }else{
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            std::vector<std::vector <float>> t;
                            std::vector <float> t_a;
                            for(int x=0;x<Coeffients.size();x++){
                                t_a.push_back(Coeffients[x]);
                                qDebug()<<Coeffients[x];
                            }
                            t.push_back(t_a);
                            res[c_row]=t;
                            itemi->setText(2,"找面成功");
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="找质心"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==1&&order_position.size()==12){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                        end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                        int result;
                        YZVision::vPointsXYZ CentroidPointCloud;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        YZVision::Feature* feature = NULL;
                        YZVision::Centroid_3D* p_Centroid = new YZVision::Centroid_3D();
                        feature = p_Centroid;
                        YZVision::Feature::InputParam input= YZVision::Feature::InputParam();
                        YZVision::Feature::OutputParam output= YZVision::Feature::OutputParam();
                        input.inputCloud=&cloudarrary[raw_cloud];
                        input.serachDir = YZVision::ROIProbeDirection::RIGHT;
                        input.m_StartPoint=start;
                        input.m_EndPoint=end;
                        result=feature->findFeature(input,&output);
                        CentroidPointCloud=output.outputPoints;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *timei = new QTableWidgetItem;
                        timei->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,timei);
                        if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"查找失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"找质心失败");
                        }else{
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            std::vector<std::vector <float>> t;
                            std::vector <float> t_a;
                            t_a.push_back(CentroidPointCloud[0].x);
                            t_a.push_back(CentroidPointCloud[0].y);
                            t_a.push_back(CentroidPointCloud[0].z);
                            t.push_back(t_a);
                            res[c_row]=t;
                            itemi->setText(2,QString("(%1,%2,%3)").arg(CentroidPointCloud[0].x).arg(CentroidPointCloud[0].y).arg(CentroidPointCloud[0].z));
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="重采样"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_cloud,type;
            double length,radius,step;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==5){
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                            break;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="type"){
                        type=s_data.at(1).toInt();
                    }else if(s_data.at(0)=="length"){
                        length=s_data.at(1).toDouble();
                    }else if(s_data.at(0)=="radius"){
                        radius=s_data.at(1).toDouble();
                    }else if(s_data.at(0)=="step"){
                        step=s_data.at(1).toDouble();
                    }
                }
                if(raw_cloud!=-1){
                    int result;
                    YZVision::vPointsXYZ cloud;
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    if(type==0){
                        YZVision::Downresampling_3D Downresampling;
                        YZVision::Downresampling_3D::InputParam input= YZVision::Downresampling_3D::InputParam();
                        YZVision::Downresampling_3D::OutputParam output= YZVision::Downresampling_3D::OutputParam();
                        input.inputcloud=&cloudarrary[raw_cloud];
                        input.r_0=length;
                        result=Downresampling.downresampling(input,&output);
                        cloud=output.outputcloud;
                    }else if(type==1){
                        YZVision::Averageresampling_3D Averageresampling;
                        YZVision::Averageresampling_3D::InputParam input= YZVision::Averageresampling_3D::InputParam();
                        YZVision::Averageresampling_3D::OutputParam output= YZVision::Averageresampling_3D::OutputParam();
                        input.inputcloud=&cloudarrary[raw_cloud];
                        input.r_0=length;
                        result=Averageresampling.averageresampling(input,&output);
                        cloud=output.outputcloud;
                     }else if(type==2){
                        YZVision::Upresampling_3D Upresampling;
                        YZVision::Upresampling_3D::InputParam input= YZVision::Upresampling_3D::InputParam();
                        YZVision::Upresampling_3D::OutputParam output= YZVision::Upresampling_3D::OutputParam();
                        input.inputcloud=&cloudarrary[raw_cloud];
                        input.r_0=length;
                        input.r_1=radius;
                        input.s_0=step;
                        result=Upresampling.upresampling(input,&output);
                        cloud=output.outputcloud;
                    }
                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(result==1){
                        cloudarrary[c_row]=cloud;
                        itemi->setText(2,"重采样成功");
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"重采样失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"重采样失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="裁切"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==2&&order_position.size()==12){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        QStringList a=order_s.at(1).split("=");
                        int ini=a.at(1).toInt();
                        bool in;
                        if(ini==1)
                            in=true;
                        else
                            in=false;
                        start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                        end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        int result;
                        YZVision::Cutcloud_3D *Cutcloud=new YZVision::Cutcloud_3D();
                        YZVision::Cutcloud_3D::InputParam input= YZVision::Cutcloud_3D::InputParam();
                        YZVision::Cutcloud_3D::OutputParam output= YZVision::Cutcloud_3D::OutputParam();
                        input.inputcloud=&cloudarrary[raw_cloud];
                        input.x_0=in;
                        input.m_StartPoint=start;
                        input.m_EndPoint=end;
                        result=Cutcloud->cutcloud(input,&output);
                        cloudarrary[c_row]=output.outputcloud;
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"裁切失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"裁切失败");
                        }else{
                            itemi->setText(2,"裁切成功");
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="拼接"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_cloud,raw_cloud_2,crop;
            double move,low,high;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==6){
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud_1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                            break;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="raw_cloud_2"){
                        raw_cloud_2=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                            break;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="CROP"){
                        crop=s_data.at(1).toInt();
                    }else if(s_data.at(0)=="move"){
                        move=s_data.at(1).toDouble();
                    }else if(s_data.at(0)=="low"){
                        low=s_data.at(1).toDouble();
                    }else if(s_data.at(0)=="high"){
                        high=s_data.at(1).toDouble();
                    }
                }
                if(raw_cloud!=-1&&raw_cloud_2!=-1){
                    int result;
                    bool cropd;
                    if(crop)
                        cropd=false;
                    else
                        cropd=true;
                    QElapsedTimer  mstimer;
                    mstimer.start();

                    YZVision::Cloudsplicing_3D Cloudsplicing;
                    YZVision::Cloudsplicing_3D::InputParam input= YZVision::Cloudsplicing_3D::InputParam();
                    YZVision::Cloudsplicing_3D::OutputParam output= YZVision::Cloudsplicing_3D::OutputParam();
                    input.inputcloud_90=&cloudarrary[raw_cloud];
                    input.inputcloud_91=&cloudarrary[raw_cloud_2];
                    input.Q=cropd;
                    input.x_0=move;
                    input.l_0=low;
                    input.l_1=high;
                    result=Cloudsplicing.cloudsplicing(input,&output);
                    cloudarrary[c_row]=output.outputcloud_90_91;

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(result==1){
                        itemi->setText(2,"拼接成功");
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"拼接失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"拼接失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="3D转深度图"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_cloud;
            double zoomx,zoomy,threshold;
            bool wave;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==5){
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                            break;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                            break;
                        }
                    }else if(s_data.at(0)=="zoom"){
                        zoomx=s_data.at(1).toDouble();
                    }else if(s_data.at(0)=="zoom_y"){
                        zoomy=s_data.at(1).toDouble();
                    }else if(s_data.at(0)=="wave"){
                        if(s_data.at(1)=="1"){
                            wave=true;
                        }else{
                            wave=false;
                        }
                    }else if(s_data.at(0)=="threshold"){
                        threshold=s_data.at(1).toDouble();
                    }
                }
                if(raw_cloud!=-1){
                    int result;
                    QImage resu;
                    QElapsedTimer  mstimer;
                    YZVision::vPointsXYZ cloud;
                    cloud=cloudarrary[raw_cloud];
                    mstimer.start();
                    YZVision::Deepcloud_3D deep;
                    YZVision::Deepcloud_3D::InputParam input= YZVision::Deepcloud_3D::InputParam();
                    YZVision::Deepcloud_3D::OutputParam output= YZVision::Deepcloud_3D::OutputParam();
                    input.inputcloud=&cloud;
                    input.x_0=zoomx;
                    input.y_0=zoomy;
                    input.Q=wave;
                    input.a_0=threshold;
                    result=deep.deepcloud(input,&output);
                    resu =cvMat2Image(output.outImage);
                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(result==1){
                        image[c_row]=QPixmap::fromImage(resu);
                        itemi->setText(2,"转深度图成功");
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"转深度图失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"转深度图失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="拟合圆柱"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==1&&order_position.size()==12){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                        end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                        int result;
                        std::vector<int> index;
                        std::vector<float> Coeffients;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        YZVision::Segmentation* segmentation = NULL;
                        YZVision::CylinderSegment* p_cylinderSeg = new YZVision::CylinderSegment();
                        segmentation = p_cylinderSeg;
                        YZVision::Segmentation::InputParam input_Param;
                        YZVision::Segmentation::OutputParam output_Param;
                        input_Param.inputCloud = &cloudarrary[raw_cloud];
                        input_Param.m_StartPoint = start;
                        input_Param.m_EndPoint = end;
                        input_Param.distance_Threshold = 0.1;
                        input_Param.distance_weight = 0.1;
                        input_Param.k_nearest_neighbors = 10;
                        input_Param.max_iteratios = 20;

                        result = segmentation->segment(input_Param, &output_Param);
                        Coeffients=output_Param.modelCoeffients;
                        index=output_Param.modelInliers;
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"拟合失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"拟合失败");
                        }else{
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            std::vector<std::vector <float>> t;
                            std::vector <float> t_a;
                            for(int x=0;x<Coeffients.size();x++){
                                t_a.push_back(Coeffients[x]);
                                qDebug()<<Coeffients[x];
                            }
                            t.push_back(t_a);
                            res[c_row]=t;
                            itemi->setText(2,"拟合成功");
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="曲面展开"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_cloud;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==1){
                QStringList s_data=order_s.at(0).split("=");
                if(s_data.at(0)=="raw_cloud"){
                    raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud=-1;
                    }else if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                        raw_cloud=-1;
                    }else if(ui->ordertable->item(raw_cloud,3)->text()!="拟合圆柱"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源不是拟合圆柱结果");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源不符合要求");
                        raw_cloud=-1;
                    }

                }
                if(raw_cloud!=-1){
                    int result;
                    YZVision::vPointsXYZ out;
//                        YZ3DVision::GEO_CYLINDER para_cylinder;
//                        para_cylinder.R = res[raw_cloud][0][6];
//                        para_cylinder.Axial = YZ3DVision::AXIS::AXIS_Y;
//                        para_cylinder.RadialTran = YZ3DVision::AXIS::AXIS_X;
//                        para_cylinder.RadialLong = YZ3DVision::AXIS::AXIS_Z;
//                        para_cylinder.CenterTran = res[raw_cloud][0][0];
//                        para_cylinder.CenterLong = res[raw_cloud][0][2];
                    QElapsedTimer  mstimer;
                    mstimer.start();
//                        YZ3DVision::Algorithm* p_algorithm_plane = new YZ3DVision::Algorithm();
//                        result=p_algorithm_plane->cylinderToPlane(&cloudarrary[raw_cloud],para_cylinder,&out);
                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(result==1){
                        cloudarrary[c_row]=out;
                        itemi->setText(2,"曲面展开成功");
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"曲面展开失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"曲面展开失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="平滑"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_cloud;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==2){
                QStringList s_data=order_s.at(0).split("=");
                if(s_data.at(0)=="raw_cloud"){
                    raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud=-1;
                    }else if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                        raw_cloud=-1;
                    }
                }
                if(raw_cloud!=-1){
                    QStringList a=order_s.at(1).split("=");
                    double radius=a.at(1).toDouble();
                    int result;
                    YZVision::vPointsXYZ cloud;
                    QElapsedTimer  mstimer;
                    mstimer.start();

                    YZVision::Fullupcloud_3D smooth;
                    YZVision::Fullupcloud_3D::InputParam input= YZVision::Fullupcloud_3D::InputParam();
                    YZVision::Fullupcloud_3D::OutputParam output= YZVision::Fullupcloud_3D::OutputParam();
                    input.inputcloud=&cloudarrary[raw_cloud];
                    input.r_0=radius;
                    result=smooth.fullupcloud(input,&output);
                    cloud=output.outputcloud;

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(result==1){
                        cloudarrary[c_row]=cloud;
                        itemi->setText(2,"平滑成功");
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"平滑失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"平滑失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="滤波"){
            cloudarrary[c_row].resize(0);
            if(c_row==0){
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }else{
                int raw_cloud;
                QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                if(order_s.size()==8){
                    QStringList s_data=order_s.at(0).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"部分设置为空");
                            raw_cloud=-1;
                        }else if(cloudarrary[raw_cloud].size()==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"无图像输入");
                            raw_cloud=-1;
                        }
                    }
                    if(raw_cloud!=-1){
                        int type,direction;
                        double up,down,number,zoom;
                        bool saved;
                        for(int z=1;z<order_s.size();z++){
                            QStringList a=order_s.at(z).split("=");
                            if(a.at(0)=="direction"){
                                direction=a.at(1).toInt();
                            }else if(a.at(0)=="up"){
                                up=a.at(1).toDouble();
                            }else if(a.at(0)=="down"){
                                down=a.at(1).toDouble();
                            }else if(a.at(0)=="number"){
                                number=a.at(1).toDouble();
                            }else if(a.at(0)=="zoom"){
                                zoom=a.at(1).toDouble();
                            }else if(a.at(0)=="save"){
                                if(a.at(1)=="0")
                                    saved=false;
                                else
                                    saved=true;
                            }else if(a.at(0)=="type"){
                                type=a.at(1).toInt();
                            }

                        }
                        int result;
                        YZVision::vPointsXYZ cloud;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        if(type==0){
                            YZVision::PassthroughFilter_3D pass;
                            YZVision::PassthroughFilter_3D::InputParam input= YZVision::PassthroughFilter_3D::InputParam();
                            YZVision::PassthroughFilter_3D::OutputParam output= YZVision::PassthroughFilter_3D::OutputParam();
                            input.inputcloud=&cloudarrary[raw_cloud];
                            input.a=direction;
                            input.R_0=saved;
                            input.x_0=down;
                            input.x_1=up;
                            result=pass.passThroughFilter(input,&output);
                            cloud=output.outputcloud;
                        }else if(type==1){
                            YZVision::Statisticalcloud_3D Statis;
                            YZVision::Statisticalcloud_3D::InputParam input= YZVision::Statisticalcloud_3D::InputParam();
                            YZVision::Statisticalcloud_3D::OutputParam output= YZVision::Statisticalcloud_3D::OutputParam();
                            input.inputcloud=&cloudarrary[raw_cloud];
                            input.x_0=saved;
                            input.a_0=number;
                            input.s_0=zoom;
                            result=Statis.statisticalcloud(input,&output);
                            cloud=output.outputcloud;
                        }else if(type==2){
                            YZVision::Radiuscloud_3D Radius;
                            YZVision::Radiuscloud_3D::InputParam input= YZVision::Radiuscloud_3D::InputParam();
                            YZVision::Radiuscloud_3D::OutputParam output= YZVision::Radiuscloud_3D::OutputParam();
                            input.inputcloud=&cloudarrary[raw_cloud];
                            input.a_0=number;
                            input.r_0=zoom;
                            result=Radius.raduiscloud(input,&output);
                            cloud=output.outputcloud;
                        }
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==1){
                            cloudarrary[c_row]=cloud;
                            itemi->setText(2,"滤波成功");
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"滤波失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"滤波失败");
                        }
                    }
                }else{
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"无图像输入");
                }
            }
    }else if (ui->ordertable->item(c_row,3)->text()=="去重"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_cloud;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==5){
                QStringList s_data=order_s.at(0).split("=");
                if(s_data.at(0)=="raw_cloud"){
                    raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud=-1;
                    }else if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                        raw_cloud=-1;
                    }
                }
                if(raw_cloud!=-1){
                    int direction;
                    double low,high,move;

                    for(int z=1;z<order_s.size();z++){
                        QStringList a=order_s.at(z).split("=");
                        if(a.at(0)=="direction"){
                            direction=a.at(1).toInt();
                        }else if(a.at(0)=="low"){
                            low=a.at(1).toDouble();
                        }else if(a.at(0)=="high"){
                            high=a.at(1).toDouble();
                        }else if(a.at(0)=="move"){
                            move=a.at(1).toDouble();
                        }
                    }
                    int result;
                    QElapsedTimer  mstimer;
                    mstimer.start();

                    YZVision::CloudDeduplication_3D CROP;
                    YZVision::CloudDeduplication_3D::InputParam input= YZVision::CloudDeduplication_3D::InputParam();
                    YZVision::CloudDeduplication_3D::OutputParam output= YZVision::CloudDeduplication_3D::OutputParam();
                    input.inputcloud_90=&cloudarrary[raw_cloud];
                    input.a=direction;
                    input.l_0=low;
                    input.l_1=high;
                    result=CROP.clouddeduplication(input,&output);

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(result==1){
                        cloudarrary[c_row]=output.outputcloud;
                        itemi->setText(2,"去重成功");
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"去重失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"去重失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
}else if (ui->ordertable->item(c_row,3)->text()=="点到点"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_cloud,raw_cloud_2;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==2){
                QStringList s_data=order_s.at(0).split("=");
                if(s_data.at(0)=="raw_cloud1"){
                    raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud=-1;
                    }else if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                        raw_cloud=-1;
                    }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找边缘点"||
                              ui->ordertable->item(raw_cloud,3)->text()=="找拐点"||
                              ui->ordertable->item(raw_cloud,3)->text()=="找质心")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为点");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源1不为点");
                        raw_cloud=-1;
                    }
                }
                QStringList a=order_s.at(1).split("=");
                if(a.at(0)=="raw_cloud2"){
                    raw_cloud_2=a.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud_2=-1;
                    }else if(cloudarrary[raw_cloud_2].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无点云输入");
                        raw_cloud_2=-1;
                    }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找边缘点"||
                              ui->ordertable->item(raw_cloud_2,3)->text()=="找拐点"||
                              ui->ordertable->item(raw_cloud_2,3)->text()=="找质心")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为点");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源2不为点");
                        raw_cloud_2=-1;
                    }
                }
                if(raw_cloud!=-1&&raw_cloud_2!=-1){
                    YZVision::PointXYZ a,b;
                    std::vector <float> ra,rb;
                    double cx=0,cy=0,cz=0;
                    for(long z=0;z<res[raw_cloud].size();z++){
                        cx+=res[raw_cloud][z][0];
                        cy+=res[raw_cloud][z][1];
                        cz+=res[raw_cloud][z][2];
                        ra.push_back(res[raw_cloud][z][0]);
                        ra.push_back(res[raw_cloud][z][1]);
                        ra.push_back(res[raw_cloud][z][2]);
                    }
                    cx=cx/res[raw_cloud].size();
                    cy=cy/res[raw_cloud].size();
                    cz=cz/res[raw_cloud].size();
                    a.setPoint(cx,cy,cz);

                    for(long x=0;x<res[raw_cloud_2].size();x++){
                        cx+=res[raw_cloud_2][x][0];
                        cy+=res[raw_cloud_2][x][1];
                        cz+=res[raw_cloud_2][x][2];
                        rb.push_back(res[raw_cloud_2][x][0]);
                        rb.push_back(res[raw_cloud_2][x][1]);
                        rb.push_back(res[raw_cloud_2][x][2]);
                    }
                    cx=cx/res[raw_cloud_2].size();
                    cy=cy/res[raw_cloud_2].size();
                    cz=cz/res[raw_cloud_2].size();

                    b.setPoint(cx,cy,cz);
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    double result=0;
                    int resu;
                    YZVision::Measurement* measurement = NULL;
                    YZVision::PointToPointDis_3D* p_p2pDis = new YZVision::PointToPointDis_3D();
                    measurement = p_p2pDis;
                    YZVision::Measurement::InputParam input_Param;
                    YZVision::Measurement::OutputParam output_Param;
                    input_Param.pt1=a;
                    input_Param.pt2=b;
                    resu=measurement->measure(input_Param, &output_Param);
                    result=output_Param.distance;
                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(resu!=0){
                        cloudarrary[c_row]=cloudarrary[raw_cloud];
                        itemi->setText(2,"距离为"+QString::number(result));

                        std::vector<std::vector <float>> t;

                        t.push_back(ra);

                        t.push_back(rb);

                        std::vector <float> t_a;
                        t_a.push_back(a.x);
                        t_a.push_back(a.y);
                        t_a.push_back(a.z);
                        t.push_back(t_a);

                        std::vector <float> t_b;
                        t_b.push_back(b.x);
                        t_b.push_back(b.y);
                        t_b.push_back(b.z);
                        t.push_back(t_b);

                        res[c_row]=t;
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测距失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"测距失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="点到线"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_cloud,raw_cloud_2;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==2){
                QStringList s_data=order_s.at(0).split("=");
                if(s_data.at(0)=="raw_cloud1"){
                    raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud=-1;
                    }else if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                        raw_cloud=-1;
                    }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找边缘点"||
                              ui->ordertable->item(raw_cloud,3)->text()=="找拐点"||
                              ui->ordertable->item(raw_cloud,3)->text()=="找质心")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为点");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源不为点");
                        raw_cloud=-1;
                    }
                }
                QStringList a=order_s.at(1).split("=");
                if(a.at(0)=="raw_cloud2"){
                    raw_cloud_2=a.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud_2=-1;
                    }else if(cloudarrary[raw_cloud_2].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无点云输入");
                        raw_cloud_2=-1;
                    }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找线")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为线");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源2不为线");
                        raw_cloud_2=-1;
                    }
                }
                if(raw_cloud!=-1&&raw_cloud_2!=-1){
                    YZVision::PointXYZ a;
                    std::vector<float> b;
                    std::vector <float> ra;
                    double cx=0,cy=0,cz=0;
                    for(long z=0;z<res[raw_cloud].size();z++){
                        cx+=res[raw_cloud][z][0];
                        cy+=res[raw_cloud][z][1];
                        cz+=res[raw_cloud][z][2];
                        ra.push_back(res[raw_cloud][z][0]);
                        ra.push_back(res[raw_cloud][z][1]);
                        ra.push_back(res[raw_cloud][z][2]);
                    }
                    cx=cx/res[raw_cloud].size();
                    cy=cy/res[raw_cloud].size();
                    cz=cz/res[raw_cloud].size();
                    a.setPoint(cx,cy,cz);

                    for(int i=0;i<res[raw_cloud_2][0].size();i++)
                        b.push_back(res[raw_cloud_2][0][i]);
                    QElapsedTimer  mstimer;
                    mstimer.start();

                    double result=0;
                    int resu;
                    YZVision::Measurement* measurement = NULL;
                    YZVision::PointToLineDis_3D* p_p2lDis = new YZVision::PointToLineDis_3D();
                    measurement = p_p2lDis;
                    YZVision::Measurement::InputParam input_Param;
                    YZVision::Measurement::OutputParam output_Param;
                    input_Param.pt_out_line=a;
                    input_Param.modelCoeffients=b;
                    resu=measurement->measure(input_Param, &output_Param);
                    result=output_Param.distance;

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(resu==1){
                        cloudarrary[c_row]=cloudarrary[raw_cloud];
                        itemi->setText(2,"距离为"+QString::number(result));

                        std::vector<std::vector <float>> t;

                        t.push_back(ra);

                        std::vector <float> r_b;
                        r_b.push_back(raw_cloud_2);
                        t.push_back(r_b);

                        std::vector <float> t_a;
                        t_a.push_back(a.x);
                        t_a.push_back(a.y);
                        t_a.push_back(a.z);
                        t.push_back(t_a);

                    //    std::vector <float> t_b;
                    //    t_b.push_back(bp.x);
                    //    t_b.push_back(bp.y);
                    //    t_b.push_back(bp.z);
                    //    t.push_back(t_b);

                        res[c_row]=t;
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测距失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"测距失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="点到面"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_cloud,raw_cloud_2;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==2){
                QStringList s_data=order_s.at(0).split("=");
                if(s_data.at(0)=="raw_cloud1"){
                    raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud=-1;
                    }else if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                        raw_cloud=-1;
                    }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找边缘点"||
                              ui->ordertable->item(raw_cloud,3)->text()=="找拐点"||
                              ui->ordertable->item(raw_cloud,3)->text()=="找质心")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为点");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源不为点");
                        raw_cloud=-1;
                    }
                }
                QStringList a=order_s.at(1).split("=");
                if(a.at(0)=="raw_cloud2"){
                    raw_cloud_2=a.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud_2=-1;
                    }else if(cloudarrary[raw_cloud_2].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无点云输入");
                        raw_cloud_2=-1;
                    }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找面")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为面");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源2不为面");
                        raw_cloud_2=-1;
                    }
                }
                if(raw_cloud!=-1&&raw_cloud_2!=-1){
                    YZVision::PointXYZ a;
                    std::vector<float> b;
                    std::vector <float> ra;
                    double cx=0,cy=0,cz=0;
                    for(long z=0;z<res[raw_cloud].size();z++){
                        cx+=res[raw_cloud][z][0];
                        cy+=res[raw_cloud][z][1];
                        cz+=res[raw_cloud][z][2];
                        ra.push_back(res[raw_cloud][z][0]);
                        ra.push_back(res[raw_cloud][z][1]);
                        ra.push_back(res[raw_cloud][z][2]);
                    }
                    cx=cx/res[raw_cloud].size();
                    cy=cy/res[raw_cloud].size();
                    cz=cz/res[raw_cloud].size();
                    a.setPoint(cx,cy,cz);

                    for(int i=0;i<res[raw_cloud_2][0].size();i++)
                        b.push_back(res[raw_cloud_2][0][i]);
                    QElapsedTimer  mstimer;
                    mstimer.start();

                    double result=0;
                    int resu;
                    YZVision::Measurement* measurement = NULL;
                    YZVision::PointToPlaneDis_3D* p_p2planeDis = new YZVision::PointToPlaneDis_3D();
                    measurement = p_p2planeDis;
                    YZVision::Measurement::InputParam input_Param;
                    YZVision::Measurement::OutputParam output_Param;
                    input_Param.pt_out_line=a;
                    input_Param.modelCoeffients=b;
                    resu=measurement->measure(input_Param, &output_Param);
                    result=output_Param.distance;

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(resu==1){
                        cloudarrary[c_row]=cloudarrary[raw_cloud];
                        itemi->setText(2,"距离为"+QString::number(result));

                        std::vector<std::vector <float>> t;

                        t.push_back(ra);

                        std::vector <float> r_b;
                        r_b.push_back(raw_cloud_2);
                        t.push_back(r_b);

                        std::vector <float> t_a;
                        t_a.push_back(a.x);
                        t_a.push_back(a.y);
                        t_a.push_back(a.z);
                        t.push_back(t_a);

                    //    std::vector <float> t_b;
                    //    t_b.push_back(bp.x);
                    //    t_b.push_back(bp.y);
                    //    t_b.push_back(bp.z);
                    //    t.push_back(t_b);

                        res[c_row]=t;
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测距失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"测距失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="线到线"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            int raw_cloud,raw_cloud_2;
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==2){
                QStringList s_data=order_s.at(0).split("=");
                if(s_data.at(0)=="raw_cloud1"){
                    raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud=-1;
                    }else if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                        raw_cloud=-1;
                    }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找线")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为线");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源不为线");
                        raw_cloud=-1;
                    }
                }
                QStringList a=order_s.at(1).split("=");
                if(a.at(0)=="raw_cloud2"){
                    raw_cloud_2=a.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud_2=-1;
                    }else if(cloudarrary[raw_cloud_2].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无点云输入");
                        raw_cloud_2=-1;
                    }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找线")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为线");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源2不为线");
                        raw_cloud_2=-1;
                    }
                }
                if(raw_cloud!=-1&&raw_cloud_2!=-1){
                    std::vector<float> a,b;
                    for(int i=0;i<res[raw_cloud][0].size();i++)
                        a.push_back(res[raw_cloud][0][i]);

                    for(int i=0;i<res[raw_cloud_2][0].size();i++)
                        b.push_back(res[raw_cloud_2][0][i]);

                    YZVision::PointXYZ ap,bp;

                    QElapsedTimer  mstimer;
                    mstimer.start();

                    double result=0;
                    int resu;
                    YZVision::Measurement* measurement = NULL;
                    YZVision::LineToLineDis_3D* p_l2lDis = new YZVision::LineToLineDis_3D();
                    measurement = p_l2lDis;
                    YZVision::Measurement::InputParam input_Param;
                    YZVision::Measurement::OutputParam output_Param;
                    input_Param.line1Coeffients=a;
                    input_Param.line2Coeffients=b;
                    resu=measurement->measure(input_Param, &output_Param);
                    result=output_Param.distance;
                    ap=output_Param.pt1_on_line;
                    bp=output_Param.pt2_on_line;

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(resu==1){
                        cloudarrary[c_row]=cloudarrary[raw_cloud];
                        itemi->setText(2,"距离为"+QString::number(result));

                        std::vector<std::vector <float>> t;

                        std::vector <float> r_a;
                        r_a.push_back(raw_cloud);
                        t.push_back(r_a);

                        std::vector <float> r_b;
                        r_b.push_back(raw_cloud_2);
                        t.push_back(r_b);

                        std::vector <float> t_a;
                        t_a.push_back(ap.x);
                        t_a.push_back(ap.y);
                        t_a.push_back(ap.z);
                        t.push_back(t_a);

                        std::vector <float> t_b;
                        t_b.push_back(bp.x);
                        t_b.push_back(bp.y);
                        t_b.push_back(bp.z);
                        t.push_back(t_b);

                        res[c_row]=t;
                    }else{
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测距失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"测距失败");
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="线到面"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==3&&order_position.size()==3){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=-1,raw_cloud_2=-1;
                if(s_data.at(0)=="raw_cloud1"){
                    raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud=-1;
                    }else if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                        raw_cloud=-1;
                    }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找线")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为线");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源不为线");
                        raw_cloud=-1;
                    }
                }

                QStringList r2=order_s.at(1).split("=");
                if(r2.at(0)=="raw_cloud2"){
                    raw_cloud_2=r2.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud_2=-1;
                    }else if(cloudarrary[raw_cloud_2].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无点云输入");
                        raw_cloud_2=-1;
                    }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找面")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为面");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源2不为面");
                        raw_cloud_2=-1;
                    }
                }

                if(raw_cloud!=-1&&raw_cloud_2!=-1){
                    int raw_cloud1=raw_cloud;
                    int raw_cloud2=raw_cloud_2;


                    YZVision::Measurement::MeasureDirection d;

                    for(int z=2;z<order_s.size();z++){
                        QStringList a=order_s.at(z).split("=");
                        if(a.at(0)=="direction"){
                            if(a.at(1).toInt()==0)
                                d=YZVision::Measurement::MeasureDirection::PARALLEL_TO_Z_AXIS;

                        }
                    }

                    std::vector<float> a,b;
                    for(int i=0;i<res[raw_cloud1][0].size();i++)
                        a.push_back(res[raw_cloud1][0][i]);

                    for(int i=0;i<res[raw_cloud2][0].size();i++)
                        b.push_back(res[raw_cloud2][0][i]);

                    YZVision::PointXYZ point;
                    double x,y,z;
                    x=order_position.at(0).toDouble();
                    y=order_position.at(1).toDouble();
                    z=order_position.at(2).toDouble();
                    point.setPoint(x,y,z);

                    QElapsedTimer  mstimer;
                    mstimer.start();
                    YZVision::PointXYZ ap,bp;

                    double result=0;
                    int resu;
                    YZVision::Measurement* measurement = NULL;
                    YZVision::LineToPlaneDis_3D* p_l2planeDis = new YZVision::LineToPlaneDis_3D();
                    measurement = p_l2planeDis;
                    YZVision::Measurement::InputParam input_Param;
                    YZVision::Measurement::OutputParam output_Param;
                    input_Param.line_out_plane=a;
                    input_Param.plane1Coeffients=b;
                    input_Param.ref_pt=point;
                    input_Param.measure_dir=d;
                    resu=measurement->measure(input_Param, &output_Param);
                    result=output_Param.distance;
                    ap=output_Param.pt3_on_line;
                    bp=output_Param.pt4_on_plane;

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(resu==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测量失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"测量失败");
                    }else{
                        cloudarrary[c_row]=cloudarrary[raw_cloud1];
                        itemi->setText(2,"距离为"+QString::number(fabsf(result)));

                        std::vector<std::vector <float>> t;

                        std::vector <float> r_a;
                        r_a.push_back(raw_cloud1);
                        t.push_back(r_a);

                        std::vector <float> r_b;
                        r_b.push_back(raw_cloud2);
                        t.push_back(r_b);

                        std::vector <float> t_a;
                        t_a.push_back(ap.x);
                        t_a.push_back(ap.y);
                        t_a.push_back(ap.z);
                        t.push_back(t_a);

                        std::vector <float> t_b;
                        t_b.push_back(bp.x);
                        t_b.push_back(bp.y);
                        t_b.push_back(bp.z);
                        t.push_back(t_b);

                        res[c_row]=t;
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="面到面"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无点云输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==3&&order_position.size()==3){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=-1,raw_cloud_2=-1;
                if(s_data.at(0)=="raw_cloud1"){
                    raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud=-1;
                    }else if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                        raw_cloud=-1;
                    }else if(!(ui->ordertable->item(raw_cloud,3)->text()=="找面")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源1不为面");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源不为面");
                        raw_cloud=-1;
                    }
                }

                QStringList r2=order_s.at(1).split("=");
                if(r2.at(0)=="raw_cloud2"){
                    raw_cloud_2=r2.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud_2,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud_2=-1;
                    }else if(cloudarrary[raw_cloud_2].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无点云输入");
                        raw_cloud_2=-1;
                    }else if(!(ui->ordertable->item(raw_cloud_2,3)->text()=="找面")){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源2不为面");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"点云源2不为面");
                        raw_cloud_2=-1;
                    }
                }

                if(raw_cloud!=-1&&raw_cloud_2!=-1){
                    int raw_cloud1=raw_cloud;
                    int raw_cloud2=raw_cloud_2;


                    YZVision::Measurement::MeasureDirection d;

                    for(int z=2;z<order_s.size();z++){
                        QStringList a=order_s.at(z).split("=");
                        if(a.at(0)=="direction"){
                            if(a.at(1).toInt()==0)
                                d=YZVision::Measurement::MeasureDirection::PARALLEL_TO_Z_AXIS;

                        }
                    }

                    std::vector<float> a,b;
                    for(int i=0;i<res[raw_cloud1][0].size();i++)
                        a.push_back(res[raw_cloud1][0][i]);

                    for(int i=0;i<res[raw_cloud2][0].size();i++)
                        b.push_back(res[raw_cloud2][0][i]);

                    YZVision::PointXYZ point;
                    double x,y,z;
                    x=order_position.at(0).toDouble();
                    y=order_position.at(1).toDouble();
                    z=order_position.at(2).toDouble();
                    point.setPoint(x,y,z);
                    YZVision::PointXYZ ap,bp;
                    QElapsedTimer  mstimer;
                    mstimer.start();

                    double result=0;
                    int resu;
                    YZVision::Measurement* measurement = NULL;
                    YZVision::PlaneToPlaneDis_3D* p_plane2planeDis = new YZVision::PlaneToPlaneDis_3D();
                    measurement = p_plane2planeDis;
                    YZVision::Measurement::InputParam input_Param;
                    YZVision::Measurement::OutputParam output_Param;
                    input_Param.plane1Coeffients=a;
                    input_Param.plane2Coeffients=b;
                    input_Param.ref_pt=point;
                    input_Param.measure_dir=d;
                    resu=measurement->measure(input_Param, &output_Param);
                    result=output_Param.distance;
                    ap=output_Param.pt5_on_plane;
                    bp=output_Param.pt6_on_plane;

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(resu==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测量失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"测量失败");
                    }else{
                        cloudarrary[c_row]=cloudarrary[raw_cloud1];
                        itemi->setText(2,"距离为"+QString::number(fabsf(result)));

                        std::vector<std::vector <float>> t;

                        std::vector <float> r_a;
                        r_a.push_back(raw_cloud1);
                        t.push_back(r_a);

                        std::vector <float> r_b;
                        r_b.push_back(raw_cloud2);
                        t.push_back(r_b);

                        std::vector <float> t_a;
                        t_a.push_back(ap.x);
                        t_a.push_back(ap.y);
                        t_a.push_back(ap.z);
                        t.push_back(t_a);

                        std::vector <float> t_b;
                        t_b.push_back(bp.x);
                        t_b.push_back(bp.y);
                        t_b.push_back(bp.z);
                        t.push_back(t_b);

                        res[c_row]=t;
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="平整度"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==2&&order_position.size()==12){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        QStringList a=order_s.at(1).split("=");
                        double threshold =a.at(1).toDouble();
                        start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                        end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                        YZVision::vPointsXYZ cloud;
                        int result;
                        float min,max,sum;
                        QElapsedTimer  mstimer;
                        mstimer.start();
                        YZVision::Planenesscloud_3D *planeness=new YZVision::Planenesscloud_3D();
                        YZVision::Planenesscloud_3D::InputParam input= YZVision::Planenesscloud_3D::InputParam();
                        YZVision::Planenesscloud_3D::OutputParam output= YZVision::Planenesscloud_3D::OutputParam();
                        input.inputcloud=&cloudarrary[raw_cloud];
                        input.r_0=threshold;
                        input.m_StartPoint=start;
                        input.m_EndPoint=end;
                        result=planeness->planenesscloud(input,&output);
                        cloud=output.outputcloud;
                        min=output.min_p;
                        max=output.max_p;
                        sum=output.sum_p;
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测量失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"测量失败");
                        }else{
                            cloudarrary[c_row]=cloud;
                            itemi->setText(2,"平整度为"+QString::number(min)+","+QString::number(max)+","+QString::number(sum));
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="截面积"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==5&&order_position.size()==12){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud;
                if(s_data.at(0)=="raw_cloud"){
                    raw_cloud=s_data.at(1).toInt()-1;
                    if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"部分设置为空");
                        raw_cloud=-1;
                    }else if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                        raw_cloud=-1;
                    }
                }

                if(raw_cloud!=-1){
                    int raw1,raw2;
                    bool four,custom;

                    for(int z=1;z<order_s.size();z++){
                        QStringList a=order_s.at(z).split("=");
                        if(a.at(0)=="four"){
                            if(a.at(1).toInt()==0)
                                four=false;
                            else
                                four=true;
                        }else if(a.at(0)=="custom"){
                            if(a.at(1).toInt()==0)
                                custom=false;
                            else
                                custom=true;
                        }else if(a.at(0)=="custom_min"){
                            raw1=a.at(1).toInt()-1;
                        }else if(a.at(0)=="custom_max"){
                            raw2=a.at(1).toInt()-1;
                        }
                    }
                    start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                    end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());

                    YZVision::PointsXYZ left;
                    YZVision::PointsXYZ right;
                    float result=0;
                    int resu;
                    if(custom){
                        int raw1=ui->outline_custom_min->currentText().toInt()-1;
                        int raw2=ui->outline_custom_max->currentText().toInt()-1;

                        if((ui->ordertable->item(raw1,3)->text()=="找边缘点"
                            ||ui->ordertable->item(raw1,3)->text()=="找拐点")&&
                            (ui->ordertable->item(raw2,3)->text()=="找边缘点"
                            ||ui->ordertable->item(raw2,3)->text()=="找拐点")){

                            YZVision::PointXYZ p1,p2;
                            int z=0;
                            for(z=0;z<res[raw1].size();z++){
                                if(cloudarrary[raw_cloud][0].y==res[raw1][z][1]){
                                    p1.setPoint(res[raw1][z][0],res[raw1][z][1],res[raw1][z][2]);
                                    break;
                                }
                            }
                            if(z==res[raw1].size())
                                p1.setPoint(res[raw1][0][0],cloudarrary[raw_cloud][0].y,res[raw1][0][2]);


                            for(z=0;z<res[raw2].size();z++){
                                if(cloudarrary[raw_cloud][0].y==res[raw2][z][1]){
                                    p2.setPoint(res[raw2][z][0],res[raw2][z][1],res[raw2][z][2]);
                                    break;
                                }
                            }
                            if(z==res[raw2].size())
                                p2.setPoint(res[raw2][0][0],cloudarrary[raw_cloud][0].y,res[raw2][0][2]);

                            if(p2.x>p1.x){
                                left=p1;
                                right=p2;
                            }else{
                                left=p2;
                                right=p1;
                            }
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"自定义的点并非找拐点或找边缘点的结果");
                            ui->journal->insertPlainText("\r\n");
                        }
                    }else{
                        left=start;
                        right=end;
                    }
                    if(custom)
                        custom=false;
                    else
                        custom=true;
                    QElapsedTimer  mstimer;
                    mstimer.start();
                    YZVision::Outlinearea_3D *Outlinearea=new YZVision::Outlinearea_3D();
                    YZVision::Outlinearea_3D::InputParam input= YZVision::Outlinearea_3D::InputParam();
                    YZVision::Outlinearea_3D::OutputParam output= YZVision::Outlinearea_3D::OutputParam();
                    input.inputcloud=&cloudarrary[raw_cloud];
                    input.XXX=four;
                    input.x_0=custom;
                    input.m_StartPoint=left;
                    input.m_EndPoint=right;
                    resu=Outlinearea->outlinearea(input,&output);
                    result=output.s_0;
                    cloudarrary[c_row]=output.outputcloud_roi;

                    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                    QTableWidgetItem *item = new QTableWidgetItem;
                    item->setText(QString::number(time));
                    ui->ordertable->setItem(c_row,2,item);
                    if(resu==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测量失败");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"测量失败");
                    }else{
                        itemi->setText(2,"截面积为"+QString::number(fabsf(result)));
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="锚定"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==1&&order_position.size()==3){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        double x,y,z;
                        x=order_position.at(0).toDouble();
                        y=order_position.at(1).toDouble();
                        z=order_position.at(2).toDouble();
                        YZVision::PointXYZ point;
                        point.setPoint(x,y,z);

                        int result=0;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        YZVision::Transformation* transformation = NULL;
                        YZVision::MovePointCloud* p_movePointCloud = new YZVision::MovePointCloud();
                        transformation = p_movePointCloud;
                        YZVision::Transformation::InputParam input_Param;
                        YZVision::Transformation::OutputParam output_Param;
                        input_Param.input_cloud=&cloudarrary[raw_cloud];
                        input_Param.anchor_point=point;
                        input_Param.angle_xyz[0] = 0;
                        input_Param.angle_xyz[1] = 0;
                        input_Param.angle_xyz[2] = 0;
                        result = transformation->transform(input_Param, &output_Param);
                        cloudarrary[c_row]=output_Param.trans_point_cloud;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"锚定失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"锚定失败");
                        }else{
                            itemi->setText(2,"锚定成功");
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="矫正"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==2&&order_position.size()==3){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        QStringList a=order_s.at(1).split("=");
                        int l=a.at(1).toInt();
                        bool line;
                        if(l==1)
                            line=true;
                        else
                            line=false;
                        float xa;
                        float ya;
                        float za;
                        if(line){
                            xa=res[raw_cloud][1][0];
                            ya=res[raw_cloud][1][1];
                            za=res[raw_cloud][1][2];
                        }else{
                            double x,y,z;
                            x=order_position.at(0).toDouble();
                            y=order_position.at(1).toDouble();
                            z=order_position.at(2).toDouble();
                            xa=x/180*M_PI;
                            ya=y/180*M_PI;
                            za=z/180*M_PI;
                        }

                        int result=0;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        YZVision::Transformation* transformation = NULL;
                        YZVision::RotatePointCloud* p_rotatePointCloud = new YZVision::RotatePointCloud();
                        transformation = p_rotatePointCloud;
                        YZVision::Transformation::InputParam input_Param;
                        YZVision::Transformation::OutputParam output_Param;
                        input_Param.input_cloud=&cloudarrary[raw_cloud];
                        input_Param.angle_xyz[0] = xa;
                        input_Param.angle_xyz[1] = ya;
                        input_Param.angle_xyz[2] = za;
                        result = transformation->transform(input_Param, &output_Param);
                        cloudarrary[c_row]=output_Param.trans_point_cloud;

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"矫正失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"矫正失败");
                        }else{
                            itemi->setText(2,"矫正成功");
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="零平面"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==3){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        int raw1,raw2;
                        for(int z=1;z<order_s.size();z++){
                            QStringList plane=order_s.at(z).split("=");

                            if(plane.at(0)=="plane1"){
                                raw1=plane.at(1).toInt()-1;
                            }else if(plane.at(0)=="plane2"){
                                raw2=plane.at(1).toInt()-1;
                            }
                        }
                        if(ui->ordertable->item(raw1,3)->text()=="裁切"&&
                                ui->ordertable->item(raw2,3)->text()=="裁切"){
                            int r1,r2;
                            QStringList order_s1=ui->ordertable->item(raw1,4)->text().split(",");
                            QStringList s_data1=order_s1.at(0).split("=");
                            r1=s_data1.at(1).toInt()-1;
                            QStringList order_s2=ui->ordertable->item(raw2,4)->text().split(",");
                            QStringList s_data2=order_s2.at(0).split("=");
                            r2=s_data2.at(1).toInt()-1;
                            if(r1==raw_cloud&&r2==raw_cloud){
                                int result;
                                QElapsedTimer  mstimer;
                                mstimer.start();

                                YZVision::Cloudzeroplane_3D zeroplane;
                                YZVision::Cloudzeroplane_3D::InputParam input= YZVision::Cloudzeroplane_3D::InputParam();
                                YZVision::Cloudzeroplane_3D::OutputParam output= YZVision::Cloudzeroplane_3D::OutputParam();
                                input.inputcloud=&cloudarrary[raw_cloud];
                                input.inputcloud_1=&cloudarrary[raw1];
                                input.inputcloud_2=&cloudarrary[raw2];
                                result=zeroplane.cloudzeroplane(input,&output);
                                cloudarrary[c_row]=output.outputcloud;

                                float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                                QTableWidgetItem *item = new QTableWidgetItem;
                                item->setText(QString::number(time));
                                ui->ordertable->setItem(c_row,2,item);

                                if(result==0){
                                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"设置零平面失败");
                                    ui->journal->insertPlainText("\r\n");
                                    itemi->setText(2,"设置零平面失败");
                                }else{
                                    itemi->setText(2,"设置零平面成功");
                                }
                            }else{
                                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"截取的图源不为操作图源");
                                ui->journal->insertPlainText("\r\n");
                                itemi->setText(2,"截取的图源不为操作图源");
                            }
                        }else{
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"截取的图源不为操作图源");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"截取的图源不为裁切结果");
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="3d斑点高度"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
            if(order_s.size()==3&&order_position.size()==12){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        QStringList a=order_s.at(1).split("=");
                        double radius=a.at(1).toDouble();
                        QStringList b=order_s.at(2).split("=");
                        double number=b.at(1).toDouble();
                        start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                        end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                        int result;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        YZVision::Cloudseg_3D *blob_3d=new YZVision::Cloudseg_3D();
                        YZVision::Cloudseg_3D::InputParam input= YZVision::Cloudseg_3D::InputParam();
                        YZVision::Cloudseg_3D::OutputParam output= YZVision::Cloudseg_3D::OutputParam();
                        input.inputcloud=&cloudarrary[raw_cloud];
                        input.r_0=radius;
                        input.num=number;
                        input.m_StartPoint=start;
                        input.m_EndPoint=end;
                        result=blob_3d->cloudseg(input,&output);
                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"测量失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"测量失败");
                        }else{
                            cloudarrary[c_row]=cloudarrary[raw_cloud];
                            QString c="";
                            for(int z=0;z<output.out_seg.size()-1;z++){
                                std::vector <float> temp;
                                qDebug()<<output.num_0[z];
                                temp.push_back(output.num_0[z]);
                                c+="斑点"+QString::number(z)+"高度为"+QString::number(output.num_0[z])+"|";

                                for(int x=0;x<output.out_seg[z].size();x++){
                                    temp.push_back(output.out_seg[z][x].x);
                                    temp.push_back(output.out_seg[z][x].y);
                                    temp.push_back(output.out_seg[z][x].z);
                                }
                                res[c_row].push_back(temp);
                            }
                            std::vector <float> temp;
                            int z=output.out_seg.size()-1;
                            qDebug()<<output.num_0[z];
                            temp.push_back(output.num_0[z]);
                            c+="斑点"+QString::number(z)+"高度为"+QString::number(output.num_0[z]);

                            for(int x=0;x<output.out_seg[z].size();x++){
                                temp.push_back(output.out_seg[z][x].x);
                                temp.push_back(output.out_seg[z][x].y);
                                temp.push_back(output.out_seg[z][x].z);
                            }
                            res[c_row].push_back(temp);

                            itemi->setText(2,c);
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }else if (ui->ordertable->item(c_row,3)->text()=="轮廓点云"){
        cloudarrary[c_row].resize(0);
        if(c_row==0){
            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"无点云输入");
            ui->journal->insertPlainText("\r\n");
            itemi->setText(2,"无图像输入");
        }else{
            QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
            if(order_s.size()==2){
                QStringList s_data=order_s.at(0).split("=");
                int raw_cloud=s_data.at(1).toInt()-1;
                if(ui->ordertable->item(raw_cloud,0)->text()=="off"){
                    ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                    ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源已被停用");
                    ui->journal->insertPlainText("\r\n");
                    itemi->setText(2,"部分设置为空");
                }else{
                    if(cloudarrary[raw_cloud].size()==0){
                        ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                        ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"点云源为空");
                        ui->journal->insertPlainText("\r\n");
                        itemi->setText(2,"无图像输入");
                    }else{
                        QStringList a=order_s.at(1).split("=");
                        double y=a.at(1).toDouble();

                        int result;
                        QElapsedTimer  mstimer;
                        mstimer.start();

                        YZVision::Cloudoutline_3D Cloudoutline;
                        YZVision::Cloudoutline_3D::InputParam input= YZVision::Cloudoutline_3D::InputParam();
                        YZVision::Cloudoutline_3D::OutputParam output= YZVision::Cloudoutline_3D::OutputParam();

                        input.inputcloud=&cloudarrary[raw_cloud];
                        input.y_0=y;
                        result=Cloudoutline.outlinearea(input,&output);

                        float time = (double)mstimer.nsecsElapsed()/(double)1000000;
                        QTableWidgetItem *item = new QTableWidgetItem;
                        item->setText(QString::number(time));
                        ui->ordertable->setItem(c_row,2,item);
                        if(result==0){
                            ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                            ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"轮廓提取失败");
                            ui->journal->insertPlainText("\r\n");
                            itemi->setText(2,"轮廓提取失败");
                        }else{
                            cloudarrary[c_row]=output.outputcloud;
                            itemi->setText(2,"轮廓提取成功");
                        }
                    }
                }
            }else{
                ui->journal->insertPlainText(QDateTime::currentDateTime().toString("[hh:mm:ss:zzz] :"));
                ui->journal->insertPlainText("操作"+QString::number(c_row+1)+"部分设置为空");
                ui->journal->insertPlainText("\r\n");
                itemi->setText(2,"无图像输入");
            }
        }
    }
    ui->out_list->addTopLevelItem(itemi->clone());
//    item->addChild(itemi->clone());
    c_row++;
    while(c_row<ui->ordertable->rowCount()&&ui->ordertable->item(c_row,0)->text()=="off"){
        c_row++;
    }
    ui->outwidget->show();
}

//输出栏点击事件
void VGRibbonWindow::on_out_list_itemClicked(QTreeWidgetItem *item, int column)
{
    Q_UNUSED(column);
    c_row=item->text(0).toInt()-1;

    if(item->childCount()==0){
        ui->cameraWidget->show();
        ui->settingWidget->close();

        ui->position->show();
        if(ui->ordertable->item(item->text(0).toInt()-1,10)->text()=="3D"){
            ui->view_reset->show();
            ui->view_back->show();
            ui->view_backlso->show();
            ui->view_bottom->show();
            ui->view_front->show();
            ui->view_frontlso->show();
            ui->view_left->show();
            ui->view_right->show();
            ui->view_up->show();
            ui->color->close();
        }else{

            ui->view_reset->close();
            ui->view_back->close();
            ui->view_backlso->close();
            ui->view_bottom->close();
            ui->view_front->close();
            ui->view_frontlso->close();
            ui->view_left->close();
            ui->view_right->close();
            ui->view_up->close();

            ui->color->show();
        }
        if(item->text(0)=="result")
            return;
        if(1/*item->parent()->text(0)=="result"*/){
            c_row=item->text(0).toInt()-1;
            if(ui->ordertable->item(item->text(0).toInt()-1,10)->text()=="2D"){

                QGraphicsScene *scene = new QGraphicsScene;
                graphicsimageitem* raw = new graphicsimageitem(image[item->text(0).toInt()-1]);
                n_image=image[item->text(0).toInt()-1];
                connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                scene->addItem(raw);
                ui->graphicsView->setScene(scene);
                ui->cameraWidget->setWidget(ui->graphicsView);
            }else{
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                if(cloudarrary[c_row].size()>0){
                    z_min=10000;
                    z_max=0;
                    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
                        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
                        vertices->InsertNextCell(1);
                        vertices->InsertCellPoint(z);
                        if (cloudarrary[c_row][z].z < z_min)
                        {
                            z_min = cloudarrary[c_row][z].z;
                        }

                        if (cloudarrary[c_row][z].z > z_max)
                        {
                            z_max = cloudarrary[c_row][z].z;
                        }
                    }
                    if(item->text(1)=="找边缘点"||item->text(1)=="找拐点"||item->text(1)=="找质心"){
                        openrawcloud(cloudarrary[c_row]);
                        YZVision::vPointsXYZ pts;
                        for(long z=0;z<res[c_row].size();z++){
                            YZVision::PointXYZ p;
                            p.setPoint(res[c_row][z][0],res[c_row][z][1],res[c_row][z][2]);
                            pts.push_back(p);
                        }
                        highLight(pts);

                        QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                        QStringList s_data=order_s.at(0).split("=");
                        int r=s_data.at(1).toInt()-1;

                        while(ui->ordertable->item(r,3)->text()=="找边缘点"||
                              ui->ordertable->item(r,3)->text()=="找拐点"||
                              ui->ordertable->item(r,3)->text()=="找线"||
                              ui->ordertable->item(r,3)->text()=="找面"||
                              ui->ordertable->item(r,3)->text()=="找质心"){
                            if(res[r].size()==0)
                                break;
                            if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                                    ui->ordertable->item(r,3)->text()=="找拐点"||
                                    ui->ordertable->item(r,3)->text()=="找质心"){
                                YZVision::vPointsXYZ points;
                                for(int z=0;z<res[r].size();z++){
                                    YZVision::PointXYZ point;
                                    point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                                    points.push_back(point);
                                }
                                highLighthistory(points);
                            }else if(ui->ordertable->item(r,3)->text()=="找线"){
                                highLightlinehistory(r);
                            }else if(ui->ordertable->item(r,3)->text()=="找面"){
                                highLightplanehistory(r);
                            }
                            QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
                            QStringList s_data=order_s.at(0).split("=");
                            r=s_data.at(1).toInt()-1;
                        }

                    }else if(item->text(1)=="找线"){
                        opencloud();
                        highLightline(c_row);

                        QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                        QStringList s_data=order_s.at(0).split("=");
                        int r=s_data.at(1).toInt()-1;

                        while(ui->ordertable->item(r,3)->text()=="找边缘点"||
                              ui->ordertable->item(r,3)->text()=="找拐点"||
                              ui->ordertable->item(r,3)->text()=="找线"||
                              ui->ordertable->item(r,3)->text()=="找面"||
                              ui->ordertable->item(r,3)->text()=="找质心"){
                            if(res[r].size()==0)
                                break;
                            if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                                    ui->ordertable->item(r,3)->text()=="找拐点"||
                                    ui->ordertable->item(r,3)->text()=="找质心"){
                                YZVision::vPointsXYZ points;
                                for(int z=0;z<res[r].size();z++){
                                    YZVision::PointXYZ point;
                                    point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                                    points.push_back(point);
                                }
                                highLighthistory(points);
                            }else if(ui->ordertable->item(r,3)->text()=="找线"){
                                highLightlinehistory(r);
                            }else if(ui->ordertable->item(r,3)->text()=="找面"){
                                highLightplanehistory(r);
                            }
                            QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
                            QStringList s_data=order_s.at(0).split("=");
                            r=s_data.at(1).toInt()-1;
                        }

                    }else if(item->text(1)=="找面"){
                        opencloud();
                        highLightplane(c_row);

                        QStringList order_s=ui->ordertable->item(c_row,4)->text().split(",");
                        QStringList s_data=order_s.at(0).split("=");
                        int r=s_data.at(1).toInt()-1;

                        while(ui->ordertable->item(r,3)->text()=="找边缘点"||
                              ui->ordertable->item(r,3)->text()=="找拐点"||
                              ui->ordertable->item(r,3)->text()=="找线"||
                              ui->ordertable->item(r,3)->text()=="找面"||
                              ui->ordertable->item(r,3)->text()=="找质心"){
                            if(res[r].size()==0)
                                break;
                            if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                                    ui->ordertable->item(r,3)->text()=="找拐点"||
                                    ui->ordertable->item(r,3)->text()=="找质心"){
                                YZVision::vPointsXYZ points;
                                for(int z=0;z<res[r].size();z++){
                                    YZVision::PointXYZ point;
                                    point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                                    points.push_back(point);
                                }
                                highLighthistory(points);
                            }else if(ui->ordertable->item(r,3)->text()=="找线"){
                                highLightlinehistory(r);
                            }else if(ui->ordertable->item(r,3)->text()=="找面"){
                                highLightplanehistory(r);
                            }
                            QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
                            QStringList s_data=order_s.at(0).split("=");
                            r=s_data.at(1).toInt()-1;
                        }

                    }else if(item->text(1)=="拟合圆柱"){
                        opencloud();
                        double radius1 = res[c_row][0][6];
                        double center1[3] = {res[c_row][0][0],res[c_row][0][1],res[c_row][0][2]};
                        vtkSmartPointer<vtkCylinderSource> cylinder = vtkSmartPointer<vtkCylinderSource>::New();
                        cylinder->SetCapping(false);
                        cylinder->SetRadius(radius1);
                        cylinder->SetCenter(center1);
                        cylinder->SetHeight(1000);
                        // Set the number of facets used to represent the cone.
                        cylinder->SetResolution(100);
                        cylinder->Update();
                        vtkSmartPointer<vtkPolyDataMapper> cylinderMapper1 = vtkSmartPointer<vtkPolyDataMapper>::New();
                        cylinderMapper1->SetInputData(cylinder->GetOutput());
                        vtkSmartPointer<vtkActor> cylinderActor1 = vtkSmartPointer<vtkActor>::New();
                        cylinderActor1->SetMapper(cylinderMapper1);
                        cylinderActor1->GetProperty()->SetColor(0.46, 0.46, 0.93);
                        cylinderActor1->GetProperty()->SetOpacity(0.6);
                        renderer->AddActor(cylinderActor1);
                    }else if(item->text(1)=="点到点"){
                        openrawcloud(cloudarrary[c_row]);

                        YZVision::vPointsXYZ p1;
                        for(long z=0;z<res[c_row].size()/3;z++){
                            YZVision::PointXYZ p;
                            p.setPoint(res[c_row][0][3*z],res[c_row][0][3*z+1],res[c_row][0][3*z+2]);
                            p1.push_back(p);
                        }
                        highLight(p1);

                        YZVision::vPointsXYZ p2;
                        for(long x=0;x<res[c_row].size()/3;x++){
                            YZVision::PointXYZ p;
                            p.setPoint(res[c_row][1][3*x],res[c_row][1][3*x+1],res[c_row][1][3*x+2]);
                            p2.push_back(p);
                        }
                        highLight(p2);

                        YZVision::PointXYZ a,b;
                        a.setPoint(res[c_row][2][0],res[c_row][2][1],res[c_row][2][2]);
                        b.setPoint(res[c_row][3][0],res[c_row][3][1],res[c_row][3][2]);

                        setVtkLine(a,b);

                    }else if(item->text(1)=="点到线"){
                        openrawcloud(cloudarrary[c_row]);

                        YZVision::vPointsXYZ p1;
                        for(long z=0;z<res[c_row].size()/3;z++){
                            YZVision::PointXYZ p;
                            p.setPoint(res[c_row][0][3*z],res[c_row][0][3*z+1],res[c_row][0][3*z+2]);
                            p1.push_back(p);
                        }
                        highLight(p1);

                        float line=res[c_row][1][0];
                        highLightline(line);

                        YZVision::PointXYZ a,b;
                        a.setPoint(res[c_row][2][0],res[c_row][2][1],res[c_row][2][2]);
    //                    b.setPoint(res[c_row][3][0],res[c_row][3][1],res[c_row][3][2]);

    //                    setVtkLine(a,b);

                    }else if(item->text(1)=="点到面"){
                        openrawcloud(cloudarrary[c_row]);

                        YZVision::vPointsXYZ p1;
                        for(long z=0;z<res[c_row].size()/3;z++){
                            YZVision::PointXYZ p;
                            p.setPoint(res[c_row][0][3*z],res[c_row][0][3*z+1],res[c_row][0][3*z+2]);
                            p1.push_back(p);
                        }
                        highLight(p1);

                        float plane=res[c_row][1][0];
                        highLightplane(plane);

                        YZVision::PointXYZ a,b;
                        a.setPoint(res[c_row][2][0],res[c_row][2][1],res[c_row][2][2]);
    //                    b.setPoint(res[c_row][3][0],res[c_row][3][1],res[c_row][3][2]);

    //                    setVtkLine(a,b);

                    }else if(item->text(1)=="线到线"){
                        openrawcloud(cloudarrary[c_row]);

                        float line=res[c_row][0][0];
                        highLightline(line);

                        float line2=res[c_row][1][0];
                        highLightline(line2);

                        YZVision::PointXYZ a,b;
                        a.setPoint(res[c_row][2][0],res[c_row][2][1],res[c_row][2][2]);
                        b.setPoint(res[c_row][3][0],res[c_row][3][1],res[c_row][3][2]);

                        setVtkLine(a,b);

                    }else if(item->text(1)=="线到面"){
                        openrawcloud(cloudarrary[c_row]);

                        float line=res[c_row][0][0];
                        highLightline(line);

                        float line2=res[c_row][1][0];
                        highLightplane(line2);

                        YZVision::PointXYZ a,b;
                        a.setPoint(res[c_row][2][0],res[c_row][2][1],res[c_row][2][2]);
                        b.setPoint(res[c_row][3][0],res[c_row][3][1],res[c_row][3][2]);

                        setVtkLine(a,b);

                    }else if(item->text(1)=="面到面"){
                        openrawcloud(cloudarrary[c_row]);

                        float line=res[c_row][0][0];
                        highLightplane(line);

                        float line2=res[c_row][1][0];
                        highLightplane(line2);

                        YZVision::PointXYZ a,b;
                        a.setPoint(res[c_row][2][0],res[c_row][2][1],res[c_row][2][2]);
                        b.setPoint(res[c_row][3][0],res[c_row][3][1],res[c_row][3][2]);

                        setVtkLine(a,b);

                    }else if(item->text(1)=="3d斑点高度"){
                        openrawcloud(cloudarrary[c_row]);
                        for(int i=0;i<res[c_row].size();i++){
                            YZVision::vPointsXYZ points;
                            for(int j=0;j<res[c_row][i].size()/3;j++){
                                YZVision::PointsXYZ point;
                                point.setPoint(res[c_row][i][j*3+1],res[c_row][i][j*3+2],res[c_row][i][j*3+3]);
                                points.push_back(point);
                            }
                            highLightblob(points);
                        }
                    }else
                        opencloud();
                }else{
                    opencloud();

                }
            }
            ui->variable_list->clear();
            QTreeWidgetItem *result=new QTreeWidgetItem;
            result->setText(0,item->text(1));
            QStringList result_s=item->text(2).split("#");
            for(int i=0;i<result_s.size();i++){
                QTreeWidgetItem *result1=new QTreeWidgetItem;
                result1->setText(0,QString::number(i+1));
                QStringList result_a=result_s.at(i).split(" ");
                for(int z=0;z<result_a.size();z++){
                    QTreeWidgetItem *result2=new QTreeWidgetItem;
                    QStringList result_b=result_a.at(z).split("|");
                    if(result_b.size()>1){
                        result2->setText(0,"point");
                        for(unsigned long long x=0;x<result_b.size();x++ ){
                            QTreeWidgetItem *result3=new QTreeWidgetItem;
                            result3->setText(0,result_b.at(x));
                            result2->addChild(result3->clone());
                        }
                    }else
                        result2->setText(0,result_a.at(z));
                    result1->addChild(result2->clone());
                }
                result->addChild(result1->clone());
            }
            ui->variable_list->addTopLevelItem(result->clone());
//            c_row++;

//            while(c_row<ui->ordertable->rowCount()&&ui->ordertable->item(c_row,0)->text()=="off"){
//                c_row++;
//                if(c_row>ui->ordertable->rowCount()-1)
//                    c_row=0;
//            }

        }
    }else{
        if(ui->out_list->currentItem()->isExpanded())
            ui->out_list->collapseItem(ui->out_list->currentItem());
        else
            ui->out_list->expandItem(ui->out_list->currentItem());
    }
}
//输出栏详细表展开事件
void VGRibbonWindow::on_expansion_clicked()
{
    if(ui->expansion->text()=="⮝"){
        ui->variable_list->show();
        ui->expansion->setText("⮟");
    }else{
        ui->variable_list->close();
        ui->expansion->setText("⮝");
    }
}

//步骤栏点击事件
void VGRibbonWindow::on_ordertable_cellClicked(int row, int column)
{
    c_row=row;
    c_column=column;
    roi=1;
    if (column==0){
        QTableWidgetItem *item = new QTableWidgetItem();
        item=ui->ordertable->item(row,column)->clone();
        item->setFlags(item->flags() & (~Qt::ItemIsEditable));
        ui->ordertable->setItem(row, column, item);
        QString c=ui->ordertable->item(row,column)->text();
        if(c=="on")
            ui->ordertable->item(row,column)->setText("off");
        else
            ui->ordertable->item(row,column)->setText("on");
    }else{
        if(column!=1){
            QTableWidgetItem *item = new QTableWidgetItem();
            item=ui->ordertable->item(row,column)->clone();
            item->setFlags(item->flags() & (~Qt::ItemIsEditable));
            ui->ordertable->setItem(row, column, item);
        }
        ui->cameraWidget->show();
        ui->settingWidget->show();
        ui->position->show();
        if(ui->ordertable->item(c_row,10)->text()=="3D"){
            ui->view_reset->show();
            ui->view_back->show();
            ui->view_backlso->show();
            ui->view_bottom->show();
            ui->view_front->show();
            ui->view_frontlso->show();
            ui->view_left->show();
            ui->view_right->show();
            ui->view_up->show();
            ui->color->close();
        }else{
            ui->view_reset->close();
            ui->view_back->close();
            ui->view_backlso->close();
            ui->view_bottom->close();
            ui->view_front->close();
            ui->view_frontlso->close();
            ui->view_left->close();
            ui->view_right->close();
            ui->view_up->close();
            ui->color->show();
        }
        QString c=ui->ordertable->item(row,3)->text();
        if(c=="选择图像"){
            QString x,y,a;
            ui->cameraWidget->setWidget(ui->graphicsView);
            openimagepath=ui->ordertable->item(row,4)->text();
            x=ui->ordertable->item(row,5)->text();
            y=ui->ordertable->item(row,6)->text();
            a=ui->ordertable->item(row,7)->text();
            if(openimagepath!=""){
                ui->origin_x->setText(ui->ordertable->item(row,5)->text());
                ui->origin_y->setText(ui->ordertable->item(row,6)->text());
                ui->image_rotate->setText(ui->ordertable->item(row,7)->text());
                image[c_row].load(openimagepath);
                on_image_rotate_editingFinished();
                ui->origin_x->setText(x);
                ui->origin_y->setText(y);
                ui->image_rotate->setText(a);
                QTableWidgetItem *item = new QTableWidgetItem;
                item->setText(x);
                ui->ordertable->setItem(c_row,5,item->clone());
                item->setText(y);
                ui->ordertable->setItem(c_row,6,item->clone());
            }
            if(image[c_row].isNull()){
                ui->image_rotate->setEnabled(false);
                ui->origin_x->setEnabled(false);
                ui->origin_y->setEnabled(false);
            }else{
                ui->image_rotate->setEnabled(true);
                ui->origin_x->setEnabled(true);
                ui->origin_y->setEnabled(true);
            }
            ui->setting->setCurrentIndex(0);
            QGraphicsScene *scene = new QGraphicsScene;
            graphicsimageitem * raw = new graphicsimageitem(image[c_row]);
            n_image=image[c_row];
            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
            scene->addItem(raw);
            ui->graphicsView->setScene(scene);
            if(!image[c_row].isNull())
                origin_add(0,ui->ordertable->item(row,5)->text().toInt(),ui->ordertable->item(row,6)->text().toInt());
        }else if(c=="二值化图像"){
            if(c_row!=0){
                ui->cameraWidget->setWidget(ui->graphicsView);
                ui->setting->setCurrentIndex(1);
                on_binary_image_General_clicked();
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QString order_type=ui->ordertable->item(row,8)->text();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                int type;
                int x,y,height,width,rotate;
                int raw_image;
                if(order_s.size()>0&&order_position.size()>0){
                    for(int z=0;z<order_s.size();z++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(z).split("=");
                        if(s_data.at(0)=="raw_image"){
                            ui->binary_image_raw_image->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,0)->text()=="off")
                                    continue;
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                ui->binary_image_raw_image->addItem(QString::number(i));
                            }
                            ui->binary_image_raw_image->setCurrentText(s_data.at(1));
                            raw_image=s_data.at(1).toInt()-1;
                        }
                        else if(s_data.at(0)=="Adaptive")
                            if(s_data.at(1)=="true")
                                ui->binary_image_adaptive->setChecked(true);
                            else
                                ui->binary_image_adaptive->setChecked(false);
                        else if(s_data.at(0)=="upper_threshold")
                            ui->binary_image_upper_threshold->setText(s_data.at(1));
                        else if(s_data.at(0)=="lower_threshold")
                            ui->binary_image_lower_threshold->setText(s_data.at(1));
                        else if(s_data.at(0)=="forecolor")
                            ui->binary_image_forecolor->setText(s_data.at(1));
                        else if(s_data.at(0)=="backcolor")
                            ui->binary_image_backcolor->setText(s_data.at(1));
                    }
                    if(order_type=="矩形"){
                        type=1;
                        ui->binary_image_a_l->show();
                        ui->binary_image_a->show();
                        ui->binary_image_w_l->show();
                        ui->binary_image_width->show();
                        ui->binary_image_h_l->setText("高");
                        if(ui->binary_image_type->currentIndex()!=0)
                            ui->binary_image_type->setCurrentIndex(0);
                    }else{
                        type=2;
                        ui->binary_image_a_l->close();
                        ui->binary_image_a->close();
                        ui->binary_image_w_l->close();
                        ui->binary_image_width->close();
                        ui->binary_image_h_l->setText("直径");
                        if(ui->binary_image_type->currentIndex()!=1)
                            ui->binary_image_type->setCurrentIndex(1);
                    }
                    x=order_position.at(0).toInt();
                    y=order_position.at(1).toInt();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    rotate=order_position.at(4).toInt();
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem *raw = new graphicsimageitem(image[raw_image]);
                    n_image=image[raw_image];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    if(x==0 && y==0 && rotate==0 && width==image[raw_image].width() && height==image[raw_image].height()){
                        ui->binary_image_x->setText(QString::number(0));
                        ui->binary_image_y->setText(QString::number(0));
                        ui->binary_image_a->setText(QString::number(0));
                        ui->binary_image_width->setText(QString::number(image[raw_image].width()));
                        ui->binary_image_height->setText(QString::number(image[raw_image].height()));
                        ui->binary_image_ROI_setting->close();
                    }else{
                        if(!image[raw_image].isNull())
                            ROI_add(type,x,y,width,height,rotate);
                        ui->binary_image_x->setText(QString::number(x));
                        ui->binary_image_y->setText(QString::number(y));
                        ui->binary_image_a->setText(QString::number(rotate));
                        ui->binary_image_width->setText(QString::number(width));
                        ui->binary_image_height->setText(QString::number(height));
                        ui->binary_image_ROI_setting->show();
                    }
                }
            }else{
                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();

            }
        }else if(c=="膨胀/腐蚀"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->cameraWidget->setWidget(ui->graphicsView);
                ui->setting->setCurrentIndex(2);
                on_Expansion_corrosion_General_clicked();
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QString order_type=ui->ordertable->item(row,8)->text();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                int type;
                int x,y,height,width,rotate;
                int raw_image;
                if(order_s.size()>0&&order_position.size()>0){
                    for(int z=0;z<order_s.size();z++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(z).split("=");
                        if(s_data.at(0)=="raw_image"){
                            ui->Expansion_corrosion_raw_image->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,0)->text()=="off")
                                    continue;
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                ui->Expansion_corrosion_raw_image->addItem(QString::number(i));
                            }
                            ui->Expansion_corrosion_raw_image->setCurrentText(s_data.at(1));
                            raw_image=s_data.at(1).toInt()-1;

                            QGraphicsScene *scene = new QGraphicsScene;
                            graphicsimageitem* raw = new graphicsimageitem(image[s_data.at(1).toInt()-1]);
                            n_image=image[raw_image];
                            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                            scene->addItem(raw);
                            ui->graphicsView->setScene(scene);

                        }
                        else if(s_data.at(0)=="Iteration_time")
                            ui->Expansion_corrosion_Iteration_time->setText(s_data.at(1));
                        else if(s_data.at(0)=="Expansion"){
                            if(s_data.at(1)=="true"){
                                ui->Expansion->setChecked(true);
                            }else{
                                ui->Corrosion->setChecked(true);
                            }
                        }
                        if(order_type=="矩形"){
                            type=1;
                            ui->Expansion_corrosion_a_l->show();
                            ui->Expansion_corrosion_a->show();
                            ui->Expansion_corrosion_w_l->show();
                            ui->Expansion_corrosion_width->show();
                            ui->Expansion_corrosion_h_l->setText("高");
                            if(ui->Expansion_corrosion_type->currentIndex()!=0)
                                ui->Expansion_corrosion_type->setCurrentIndex(0);
                        }else{
                            type=2;
                            ui->Expansion_corrosion_a_l->close();
                            ui->Expansion_corrosion_a->close();
                            ui->Expansion_corrosion_w_l->close();
                            ui->Expansion_corrosion_width->close();
                            ui->Expansion_corrosion_h_l->setText("直径");
                            if(ui->Expansion_corrosion_type->currentIndex()!=1)
                                ui->Expansion_corrosion_type->setCurrentIndex(1);
                        }
                        x=order_position.at(0).toInt();
                        y=order_position.at(1).toInt();
                        width=order_position.at(2).toInt();
                        if(width==0)
                            width=image[raw_image].width();
                        height=order_position.at(3).toInt();
                        if(height==0)
                            height=image[raw_image].height();
                        rotate=order_position.at(4).toInt();
                        QGraphicsScene *scene = new QGraphicsScene;
                        graphicsimageitem *raw = new graphicsimageitem(image[raw_image]);
                        n_image=image[raw_image];
                        connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                        scene->addItem(raw);
                        ui->graphicsView->setScene(scene);
                        if(x==0 && y==0 && rotate==0 && width==image[raw_image].width() && height==image[raw_image].height()){
                            ui->Expansion_corrosion_x->setText(QString::number(0));
                            ui->Expansion_corrosion_y->setText(QString::number(0));
                            ui->Expansion_corrosion_a->setText(QString::number(0));
                            ui->Expansion_corrosion_width->setText(QString::number(image[raw_image].width()));
                            ui->Expansion_corrosion_height->setText(QString::number(image[raw_image].height()));
                            ui->Expansion_corrosion_ROI_setting->close();
                        }else{
                            if(!image[raw_image].isNull())
                                ROI_add(type,x,y,width,height,rotate);
                            ui->Expansion_corrosion_x->setText(QString::number(x));
                            ui->Expansion_corrosion_y->setText(QString::number(y));
                            ui->Expansion_corrosion_a->setText(QString::number(rotate));
                            ui->Expansion_corrosion_width->setText(QString::number(width));
                            ui->Expansion_corrosion_height->setText(QString::number(height));
                            ui->Expansion_corrosion_ROI_setting->show();
                        }
                    }
                }
            }
        }else if(c=="图像运算"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->cameraWidget->setWidget(ui->graphicsView);
                ui->setting->setCurrentIndex(3);
                on_image_math_general_clicked();
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QString order_type=ui->ordertable->item(row,8)->text();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                int type;
                int x,y,height,width,rotate,x2,y2;
                int raw_image;
                if(order_s.size()>0&&order_position.size()>0){
                    for(int z=0;z<order_s.size();z++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(z).split("=");
                        if(s_data.at(0)=="raw_image_1"){
                            ui->image_math_raw_image_1->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,0)->text()=="off")
                                    continue;
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                ui->image_math_raw_image_1->addItem(QString::number(i));
                            }
                            ui->image_math_raw_image_1->setCurrentText(s_data.at(1));
                            raw_image=s_data.at(1).toInt()-1;

                            QGraphicsScene *scene = new QGraphicsScene;
                            graphicsimageitem* raw = new graphicsimageitem(image[s_data.at(1).toInt()-1]);
                            n_image=image[raw_image];
                            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                            scene->addItem(raw);
                            ui->graphicsView->setScene(scene);

                        }else if(s_data.at(0)=="raw_image_2"){
                            ui->image_math_raw_image_2->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,0)->text()=="off")
                                    continue;
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                ui->image_math_raw_image_2->addItem(QString::number(i));
                            }
                            ui->image_math_raw_image_2->setCurrentText(s_data.at(1));
    //                        if(!image[s_data.at(1).toInt()-1].isNull()){
    //                                            QGraphicsScene *scene = new QGraphicsScene;
    //                                            graphicsimageitem* raw = new graphicsimageitem(image[s_data.at(1).toInt()-1]);
    //                                            scene->addItem(raw);
    //                                            ui->graphicsView->setScene(scene);

                        }else if(s_data.at(0)=="operation")
                            ui->image_math_operation->setCurrentText(s_data.at(1));
                        else if(s_data.at(0)=="add_1")
                            ui->image_math_add_1->setText(s_data.at(1));
                        else if(s_data.at(0)=="add_2")
                            ui->image_math_add_2->setText(s_data.at(1));
                    }
                    if(order_type=="矩形"){
                        type=1;
                        ui->image_math_a_l->show();
                        ui->image_math_a->show();
                        ui->image_math_w_l->show();
                        ui->image_math_width->show();
                        ui->image_math_h_l->setText("高");
                        if(ui->image_math_type->currentIndex()!=0)
                            ui->image_math_type->setCurrentIndex(0);
                    }else{
                        type=2;
                        ui->image_math_a_l->close();
                        ui->image_math_a->close();
                        ui->image_math_w_l->close();
                        ui->image_math_width->close();
                        ui->image_math_h_l->setText("直径");
                        if(ui->image_math_type->currentIndex()!=1)
                            ui->image_math_type->setCurrentIndex(1);
                    }
                    x=order_position.at(0).toInt();
                    y=order_position.at(1).toInt();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    rotate=order_position.at(4).toInt();
                    x2=order_position.at(5).toInt();
                    y2=order_position.at(6).toInt();
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem *raw = new graphicsimageitem(image[raw_image]);
                    n_image=image[raw_image];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    if(x==0 && y==0 && rotate==0 && width==image[raw_image].width() && height==image[raw_image].height()){
                        ui->image_math_x->setText(QString::number(0));
                        ui->image_math_y->setText(QString::number(0));
                        ui->image_math_a->setText(QString::number(0));
                        ui->image_math_width->setText(QString::number(image[raw_image].width()));
                        ui->image_math_height->setText(QString::number(image[raw_image].height()));
                        ui->image_math_2_x->setText(QString::number(0));
                        ui->image_math_2_y->setText(QString::number(0));
                        ui->image_math_ROI_setting->close();
                        ui->image_math_ROI_setting_2->close();
                    }else{
                        if(!image[raw_image].isNull())
                            ROI_add(type,x,y,width,height,rotate);
                        ui->image_math_x->setText(QString::number(x));
                        ui->image_math_y->setText(QString::number(y));
                        ui->image_math_a->setText(QString::number(rotate));
                        ui->image_math_width->setText(QString::number(width));
                        ui->image_math_height->setText(QString::number(height));
                        ui->image_math_2_x->setText(QString::number(x2));
                        ui->image_math_2_y->setText(QString::number(y2));
                        ui->image_math_ROI_setting->show();
                        ui->image_math_ROI_setting_2->show();
                    }
                }
            }
        }else if(c=="斑点查找"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->cameraWidget->setWidget(ui->graphicsView);
                ui->setting->setCurrentIndex(4);
                on_blob_general_clicked();
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QString order_type=ui->ordertable->item(row,8)->text();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                int type;
                int x,y,height,width,rotate;
                int raw_image;
                if(order_s.size()>0&&order_position.size()>0){
                    for(int z=0;z<order_s.size();z++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(z).split("=");
                        if(s_data.at(0)=="raw_image"){
                            ui->blob_raw_image->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,0)->text()=="off")
                                    continue;
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                ui->blob_raw_image->addItem(QString::number(i));
                            }
                            ui->blob_raw_image->setCurrentText(s_data.at(1));
                            raw_image=s_data.at(1).toInt()-1;

                            QGraphicsScene *scene = new QGraphicsScene;
                            graphicsimageitem* raw = new graphicsimageitem(image[s_data.at(1).toInt()-1]);
                            n_image=image[raw_image];
                            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                            scene->addItem(raw);
                            ui->graphicsView->setScene(scene);

                        }else if(s_data.at(0)=="threshold_upper")
                            ui->blob_threshold_upper->setText(s_data.at(1));
                        else if(s_data.at(0)=="threshold_lower")
                            ui->blob_threshold_lower->setText(s_data.at(1));
                        else if(s_data.at(0)=="type")
                            ui->blob_type->setCurrentIndex(s_data.at(1).toInt());
                        else if(s_data.at(0)=="border"){
                            if(s_data.at(1)=="true")
                                ui->blob_exclude_borders->setChecked(true);
                            else
                                ui->blob_exclude_borders->setChecked(false);
                        }else if(s_data.at(0)=="fill"){
                            if(s_data.at(1)=="true")
                                ui->blob_fill->setChecked(true);
                            else
                                ui->blob_fill->setChecked(false);
                        }else if(s_data.at(0)=="width_f"){
                            if(s_data.at(1)=="true")
                                ui->blob_width->setChecked(true);
                            else
                                ui->blob_width->setChecked(false);
                        }else if(s_data.at(0)=="width_f_min")
                            ui->blob_width_min->setText(s_data.at(1));
                        else if(s_data.at(0)=="width_f_max")
                            ui->blob_width_max->setText(s_data.at(1));
                        else if(s_data.at(0)=="height_f"){
                            if(s_data.at(1)=="true")
                                 ui->blob_height->setChecked(true);
                            else
                                ui->blob_height->setChecked(false);
                        }else if(s_data.at(0)=="height_f_min")
                            ui->blob_height_min->setText(s_data.at(1));
                        else if(s_data.at(0)=="height_f_max")
                            ui->blob_height_max->setText(s_data.at(1));
                        else if(s_data.at(0)=="area"){
                            if(s_data.at(1)=="true")
                                 ui->blob_area->setChecked(true);
                            else
                                ui->blob_area->setChecked(false);
                        }else if(s_data.at(0)=="area_min")
                            ui->blob_area_min->setText(s_data.at(1));
                        else if(s_data.at(0)=="area_max")
                            ui->blob_area_max->setText(s_data.at(1));
                        else if(s_data.at(0)=="number"){
                            if(s_data.at(1)=="true")
                                 ui->blob_number->setChecked(true);
                            else
                                ui->blob_number->setChecked(false);
                        }else if(s_data.at(0)=="number_min")
                            ui->blob_number_min->setText(s_data.at(1));
                        else if(s_data.at(0)=="number_max")
                            ui->blob_number_max->setText(s_data.at(1));
                    }
                    if(order_type=="矩形"){
                        type=1;
                        ui->blob_ROI_a_l->show();
                        ui->blob_ROI_a->show();
                        ui->blob_ROI_w_l->show();
                        ui->blob_ROI_width->show();
                        ui->blob_ROI_h_l->setText("高");
                        if(ui->blob_ROI_type->currentIndex()!=0)
                            ui->blob_ROI_type->setCurrentIndex(0);
                    }else{
                        type=2;
                        ui->blob_ROI_a_l->close();
                        ui->blob_ROI_a->close();
                        ui->blob_ROI_w_l->close();
                        ui->blob_ROI_width->close();
                        ui->blob_ROI_h_l->setText("直径");
                        if(ui->blob_ROI_type->currentIndex()!=1)
                            ui->blob_ROI_type->setCurrentIndex(1);
                    }
                    x=order_position.at(0).toInt();
                    y=order_position.at(1).toInt();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    rotate=order_position.at(4).toInt();
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem *raw = new graphicsimageitem(image[raw_image]);
                    n_image=image[raw_image];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    if(x==0 && y==0 && rotate==0 && width==image[raw_image].width() && height==image[raw_image].height()){
                        ui->blob_ROI_x->setText(QString::number(0));
                        ui->blob_ROI_y->setText(QString::number(0));
                        ui->blob_ROI_a->setText(QString::number(0));
                        ui->blob_ROI_width->setText(QString::number(image[raw_image].width()));
                        ui->blob_ROI_height->setText(QString::number(image[raw_image].height()));
                        ui->blob_ROI_setting->close();
                    }else{
                        if(!image[raw_image].isNull())
                            ROI_add(type,x,y,width,height,rotate);
                        ui->blob_ROI_x->setText(QString::number(x));
                        ui->blob_ROI_y->setText(QString::number(y));
                        ui->blob_ROI_a->setText(QString::number(rotate));
                        ui->blob_ROI_width->setText(QString::number(width));
                        ui->blob_ROI_height->setText(QString::number(height));
                        ui->blob_ROI_setting->show();
                    }
                }
            }
        }else if(c=="线查找"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->cameraWidget->setWidget(ui->graphicsView);
                ui->setting->setCurrentIndex(5);
                on_line_find_general_clicked();
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QString order_type=ui->ordertable->item(row,8)->text();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                int type;
                int x,y,height,width,rotate;
                int raw_image;
                if(order_s.size()>0&&order_position.size()>0){
                    for(int z=0;z<order_s.size();z++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(z).split("=");
                        if(s_data.at(0)=="raw_image"){
                            ui->line_find_raw_image->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,0)->text()=="off")
                                    continue;
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                ui->line_find_raw_image->addItem(QString::number(i));
                            }
                            ui->line_find_raw_image->setCurrentText(s_data.at(1));
                            raw_image=s_data.at(1).toInt()-1;
                        }else if(s_data.at(0)=="threshold_lower")
                            ui->line_find_threshold_lower->setText(s_data.at(1));
                        else if(s_data.at(0)=="threshold_upper")
                            ui->line_find_threshold_upper->setText(s_data.at(1));
                        else if(s_data.at(0)=="type")
                            ui->line_find_type->setCurrentIndex(s_data.at(1).toInt());
                        else if(s_data.at(0)=="border")
                            ui->line_find_border->setCurrentIndex(s_data.at(1).toInt());
                        else if(s_data.at(0)=="ratio")
                            ui->line_find_ratio->setText(s_data.at(1));
                        else if(s_data.at(0)=="Subpixel")
                            ui->line_find_Subpixel->setText(s_data.at(1));
                    }
                    type=1;
                    x=order_position.at(0).toInt();
                    y=order_position.at(1).toInt();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    rotate=order_position.at(4).toInt();
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem *raw = new graphicsimageitem(image[raw_image]);
                    n_image=image[raw_image];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    if(x==0 && y==0 && rotate==0 && width==image[raw_image].width() && height==image[raw_image].height()){
                        ui->line_find_x->setText(QString::number(0));
                        ui->line_find_y->setText(QString::number(0));
                        ui->line_find_a->setText(QString::number(0));
                        ui->line_find_width->setText(QString::number(image[raw_image].width()));
                        ui->line_find_height->setText(QString::number(image[raw_image].height()));
                        ui->line_find_ROI_setting->show();
                    }else{
                        if(!image[raw_image].isNull())
                            ROI_add(type,x,y,width,height,rotate);
                        ui->line_find_x->setText(QString::number(x));
                        ui->line_find_y->setText(QString::number(y));
                        ui->line_find_a->setText(QString::number(rotate));
                        ui->line_find_width->setText(QString::number(width));
                        ui->line_find_height->setText(QString::number(height));
                        ui->line_find_ROI_setting->show();
                    }
                }
            }
        }else if(c=="圆查找"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->cameraWidget->setWidget(ui->graphicsView);
                ui->setting->setCurrentIndex(6);
                if(c_row==0){
    //                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                    return;
                }
                on_Circle_find_general_clicked();
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QString order_type=ui->ordertable->item(row,8)->text();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                int type;
                int x,y,height,width;
                int raw_image;
                if(order_s.size()>0&&order_position.size()>0){
                    for(int z=0;z<order_s.size();z++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(z).split("=");
                        if(s_data.at(0)=="raw_image"){
                            ui->Circle_find_raw_image->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,0)->text()=="off")
                                    continue;
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                ui->Circle_find_raw_image->addItem(QString::number(i));
                            }
                            ui->Circle_find_raw_image->setCurrentText(s_data.at(1));
                            raw_image=s_data.at(1).toInt()-1;
                        }else if(s_data.at(0)=="threshold_lower")
                            ui->Circle_find_threshold_lower->setText(s_data.at(1));
                        else if(s_data.at(0)=="threshold_upper")
                            ui->Circle_find_threshold_upper->setText(s_data.at(1));
                        else if(s_data.at(0)=="type")
                            ui->Circle_find_type->setCurrentIndex(s_data.at(1).toInt());
                        else if(s_data.at(0)=="border")
                            ui->Circle_find_border->setCurrentIndex(s_data.at(1).toInt());
                        else if(s_data.at(0)=="ratio")
                            ui->Circle_find_ratio->setText(s_data.at(1));
                        else if(s_data.at(0)=="radius_min")
                            ui->Circle_find_radius_min->setText(s_data.at(1));
                        else if(s_data.at(0)=="radius_max")
                            ui->Circle_find_radius_max->setText(s_data.at(1));
                    }
                    type=2;
                    x=order_position.at(0).toInt();
                    y=order_position.at(1).toInt();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();
                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem *raw = new graphicsimageitem(image[raw_image]);
                    n_image=image[raw_image];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    if(x==0 && y==0 && width==image[raw_image].width() && height==image[raw_image].height()){
                        ui->Circle_find_x->setText(QString::number(0));
                        ui->Circle_find_y->setText(QString::number(0));
                        ui->Circle_find_width->setText(QString::number(image[raw_image].width()));
                        ui->Circle_find_height->setText(QString::number(image[raw_image].height()));
                        ui->Circle_find_ROI_setting->show();
                    }else{
                        if(!image[raw_image].isNull())
                            ROI_add(type,x,y,width,height,0);
                        ui->Circle_find_x->setText(QString::number(x));
                        ui->Circle_find_y->setText(QString::number(y));
                        ui->Circle_find_width->setText(QString::number(width));
                        ui->Circle_find_height->setText(QString::number(height));
                        ui->Circle_find_ROI_setting->show();
                    }
                }
            }
        }else if(c=="模板匹配"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->cameraWidget->setWidget(ui->graphicsView);
                ui->setting->setCurrentIndex(7);
                on_Pattern_find_general_clicked();
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList order_type=ui->ordertable->item(row,8)->text().split(",");
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                int type1;
                int x,y,height,width,a,x2,y2,height2,width2,a2;
                int raw_image,raw_image2;

                if(order_s.size()>0&&order_type.size()>0&&order_position.size()>0){
                    for(int z=0;z<order_s.size();z++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(z).split("=");
                        if(s_data.at(0)=="raw_image_1"){
                            ui->Pattern_find_train_raw_image->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                if(ui->ordertable->item(i-1,0)->text()=="on")
                                    ui->Pattern_find_train_raw_image->addItem(QString::number(i));
                            }
                            ui->Pattern_find_train_raw_image->setCurrentText(s_data.at(1));
                            raw_image=s_data.at(1).toInt()-1;
                        }else if(s_data.at(0)=="raw_image_2"){
                            ui->Pattern_find_search_raw_image->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                if(ui->ordertable->item(i-1,0)->text()=="on")
                                    ui->Pattern_find_search_raw_image->addItem(QString::number(i));
                            }
                            ui->Pattern_find_search_raw_image->setCurrentText(s_data.at(1));
                            raw_image2=s_data.at(1).toInt()-1;
                        }else if(s_data.at(0)=="rotate")
                            ui->Pattern_find_rotate->setCurrentIndex(s_data.at(1).toInt());
                        else if(s_data.at(0)=="rotate_min")
                            ui->Pattern_find_rotate_min->setText(s_data.at(1));
                        else if(s_data.at(0)=="rotate_max")
                            ui->Pattern_find_rotate_max->setText(s_data.at(1));
                        else if(s_data.at(0)=="zoom")
                            ui->Pattern_find_zoom->setCurrentIndex(s_data.at(1).toInt());
                        else if(s_data.at(0)=="zoom_min")
                            ui->Pattern_find_zoom_min->setText(s_data.at(1));
                        else if(s_data.at(0)=="zoom_max")
                            ui->Pattern_find_zoom_max->setText(s_data.at(1));
                        else if(s_data.at(0)=="type")
                            ui->Pattern_find_type->setCurrentIndex(s_data.at(1).toInt());
                        else if(s_data.at(0)=="search")
                            ui->Pattern_find_min_search->setText(s_data.at(1));
                        else if(s_data.at(0)=="number"){
                            if(s_data.at(1).toInt()==0){
                                ui->Pattern_find_min_search->setEnabled(false);
                                ui->Pattern_find_all_number->setChecked(true);
                            }
                            ui->Pattern_find_max_number->setText(s_data.at(1));
                        }
                    }

                    if(order_type.at(0)=="矩形"){
                        type1=1;
                        ui->Pattern_find_ROI_a_l->show();
                        ui->Pattern_find_ROI_a->show();
                        ui->Pattern_find_ROI_w_l->show();
                        ui->Pattern_find_ROI_width->show();
                        ui->Pattern_find_ROI_h_l->setText("高");
                        if(ui->Pattern_find_ROI_type->currentIndex()!=0)
                            ui->Pattern_find_ROI_type->setCurrentIndex(0);
                    }else{
                        type1=2;
                        ui->Pattern_find_ROI_a_l->close();
                        ui->Pattern_find_ROI_a->close();
                        ui->Pattern_find_ROI_w_l->close();
                        ui->Pattern_find_ROI_width->close();
                        ui->Pattern_find_ROI_h_l->setText("直径");
                        if(ui->Pattern_find_ROI_type->currentIndex()!=1)
                            ui->Pattern_find_ROI_type->setCurrentIndex(1);
                    }
                    if(order_type.at(1)=="矩形"){
                        ui->Pattern_find_ROI_2_a_l->show();
                        ui->Pattern_find_ROI_2_a->show();
                        ui->Pattern_find_ROI_2_w_l->show();
                        ui->Pattern_find_ROI_2_width->show();
                        ui->Pattern_find_ROI_2_h_l->setText("高");
                        if(ui->Pattern_find_ROI_2_type->currentIndex()!=0)
                            ui->Pattern_find_ROI_2_type->setCurrentIndex(0);
                    }else{
                        ui->Pattern_find_ROI_2_a_l->close();
                        ui->Pattern_find_ROI_2_a->close();
                        ui->Pattern_find_ROI_2_w_l->close();
                        ui->Pattern_find_ROI_2_width->close();
                        ui->Pattern_find_ROI_2_h_l->setText("直径");
                        if(ui->Pattern_find_ROI_2_type->currentIndex()!=1)
                            ui->Pattern_find_ROI_2_type->setCurrentIndex(1);
                    }
                    x=order_position.at(0).toInt();
                    y=order_position.at(1).toInt();
                    width=order_position.at(2).toInt();
                    if(width==0)
                        width=image[raw_image].width();

                    height=order_position.at(3).toInt();
                    if(height==0)
                        height=image[raw_image].height();
                    a=order_position.at(4).toInt();

                    x2=order_position.at(5).toInt();
                    y2=order_position.at(6).toInt();
                    width2=order_position.at(7).toInt();
                    if(width2==0)
                        width2=image[raw_image2].width();
                    height2=order_position.at(8).toInt();
                    if(height2==0)
                        height2=image[raw_image2].height();
                    a2=order_position.at(9).toInt();

                    if(x2==0 && y2==0 && a2==0 && width2==image[raw_image2].width() && height2==image[raw_image2].height()){
                        ui->Pattern_find_ROI_2_x->setText(QString::number(0));
                        ui->Pattern_find_ROI_2_y->setText(QString::number(0));
                        ui->Pattern_find_ROI_2_a->setText(QString::number(0));
                        ui->Pattern_find_ROI_2_width->setText(QString::number(image[raw_image2].width()));
                        ui->Pattern_find_ROI_2_height->setText(QString::number(image[raw_image2].height()));
                    }else{
                        ui->Pattern_find_ROI_2_x->setText(QString::number(x2));
                        ui->Pattern_find_ROI_2_y->setText(QString::number(y2));
                        ui->Pattern_find_ROI_2_a->setText(QString::number(a2));
                        ui->Pattern_find_ROI_2_width->setText(QString::number(width2));
                        ui->Pattern_find_ROI_2_height->setText(QString::number(height2));
                    }
                    QGraphicsScene *scene = new QGraphicsScene;
                    graphicsimageitem *raw = new graphicsimageitem(image[raw_image]);
                    n_image=image[raw_image];
                    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                    scene->addItem(raw);
                    ui->graphicsView->setScene(scene);
                    if(x==0 && y==0 && a==0 && width==image[raw_image].width() && height==image[raw_image].height()){
                        ui->Pattern_find_ROI_x->setText(QString::number(0));
                        ui->Pattern_find_ROI_y->setText(QString::number(0));
                        ui->Pattern_find_ROI_a->setText(QString::number(0));
                        ui->Pattern_find_ROI_width->setText(QString::number(image[raw_image].width()));
                        ui->Pattern_find_ROI_height->setText(QString::number(image[raw_image].height()));
                        ui->Pattern_find_train_ROI_setting->close();
                        ui->Pattern_find_search_ROI_setting->close();
                    }else{
                        if(!image[raw_image].isNull())
                            ROI_add(type1,x,y,width,height,a);
                        ui->Pattern_find_ROI_x->setText(QString::number(x));
                        ui->Pattern_find_ROI_y->setText(QString::number(y));
                        ui->Pattern_find_ROI_a->setText(QString::number(a));
                        ui->Pattern_find_ROI_width->setText(QString::number(width));
                        ui->Pattern_find_ROI_height->setText(QString::number(height));
                        ui->Pattern_find_train_ROI_setting->show();
                        ui->Pattern_find_search_ROI_setting->show();
                    }
                }
            }
        }else if(c=="测距"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(11);
                ui->length_setting->setCurrentIndex(0);
                QStringList order_a=ui->ordertable->item(row,4)->text().split(",");
                ui->length_raw_image->clear();
                QStringList order_s=order_a.at(0).split("=");
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="3D")
                        continue;
                    ui->length_raw_image->addItem(QString::number(i));
                }
                ui->length_raw_image->setCurrentText(order_s.at(1));
                int raw_image=order_s.at(1).toInt()-1;
                QGraphicsScene *scene = new QGraphicsScene;
                graphicsimageitem* raw = new graphicsimageitem(image[order_s.at(1).toInt()-1]);
                n_image=image[raw_image];
                ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_image,5)->clone());
                ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_image,6)->clone());
                ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_image,7)->clone());
                connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                scene->addItem(raw);
                ui->graphicsView->setScene(scene);
                QStringList order_s2=order_a.at(1).split("=");
                ui->length_raw_image_2->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="3D")
                        continue;
                    ui->length_raw_image_2->addItem(QString::number(i));
                }
                ui->length_raw_image_2->setCurrentText(order_s2.at(1));
                on_length_General_clicked();
                length_setting_change();
            }
        }else if(c=="面积计算"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(12);
                ui->area_setting->setCurrentIndex(0);
                QStringList order=ui->ordertable->item(row,4)->text().split(",");
                QStringList order_s=order.at(0).split("=");
                ui->area_raw_image->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="3D")
                        continue;
    //                if(ui->ordertable->item(i-1,3)->text()!="斑点查找")
    //                    continue;
                    ui->area_raw_image->addItem(QString::number(i));
                }
                ui->area_raw_image->setCurrentText(order_s.at(1));
                int raw_image=order_s.at(1).toInt()-1;
                QGraphicsScene *scene = new QGraphicsScene;
                graphicsimageitem* raw = new graphicsimageitem(image[order_s.at(1).toInt()-1]);
                n_image=image[raw_image];
                ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_image,5)->clone());
                ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_image,6)->clone());
                ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_image,7)->clone());
                connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                scene->addItem(raw);
                ui->graphicsView->setScene(scene);
                if(!image[raw_image].isNull()){
                    if(ui->ordertable->item(raw_image,3)->text()=="斑点查找"){
                        ui->area_blob->setEnabled(true);
                        ui->area_blob->clear();
                        QStringList order_a=order.at(1).split("=");
                        for(int i=1;i<=res[raw_image].size()/2;i++){
                            ui->area_blob->addItem(QString::number(i));
                        }
                        ui->area_blob->setCurrentIndex(order_a.at(1).toInt());
                    }else{
                        ui->area_blob->setEnabled(false);
                    }
                }else{
                    ui->area_blob->setEnabled(false);
                }
                on_area_General_clicked();
                area_setting_change();
            }
        }else if(c=="图片拼接"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->cameraWidget->setWidget(ui->graphicsView);
                ui->setting->setCurrentIndex(30);
                if(c_row==0){
    //                QMessageBox::critical(0,QObject::tr("警告"),"请加入图源");
                    return;
                }
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                int raw_image;
                if(order_s.size()>0){
                    for(int z=0;z<order_s.size();z++){
                        //将有效数据中以=分割,取=后面数据
                        QStringList s_data=order_s.at(z).split("=");
                        if(s_data.at(0)=="raw"){
                            ui->image_Splicing_raw->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,0)->text()=="off")
                                    continue;
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                ui->image_Splicing_raw->addItem(QString::number(i));
                            }
                            ui->image_Splicing_raw->setCurrentText(s_data.at(1));
                            raw_image=s_data.at(1).toInt()-1;

                            QGraphicsScene *scene = new QGraphicsScene;
                            graphicsimageitem* raw = new graphicsimageitem(image[s_data.at(1).toInt()-1]);
                            n_image=image[raw_image];
                            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
                            scene->addItem(raw);
                            ui->graphicsView->setScene(scene);

                        }else if(s_data.at(0)=="raw_2"){
                            ui->image_Splicing_raw_2->clear();
                            for(int i=1;i<=c_row;i++){
                                if(ui->ordertable->item(i-1,0)->text()=="off")
                                    continue;
                                if(ui->ordertable->item(i-1,10)->text()=="3D")
                                    continue;
                                ui->image_Splicing_raw_2->addItem(QString::number(i));
                            }
                            ui->image_Splicing_raw_2->setCurrentText(s_data.at(1));
                        }else if(s_data.at(0)=="upper_threshold")
                            ui->image_Splicing_upper_threshold->setText(s_data.at(1));
                        else if(s_data.at(0)=="lower_threshold")
                            ui->image_Splicing_lower_threshold->setText(s_data.at(1));
                        else if(s_data.at(0)=="number")
                            ui->image_Splicing_number->setText(s_data.at(1));
                        else if(s_data.at(0)=="black"){
                            if(s_data.at(1)=="1"){
                                ui->image_Splicing_black->setChecked(true);
                            }else{
                                ui->image_Splicing_black->setChecked(false);
                            }
                        }
                    }
                    on_image_Splicing_general_clicked();
                    image_Splicing_setting_change();
                }
            }
        }else if(c=="选择点云"){
            ui->setting->setCurrentIndex(8);
            ui->reading->close();
            opencloudpath=ui->ordertable->item(c_row,4)->text();
            ui->cameraWidget->setWindowTitle("相机取景器");
            if(opencloudpath!=""){
                QFile file(opencloudpath);
                if (file.open(QIODevice::ReadOnly | QIODevice::Text)){
                    z_min=10000;
                    z_max=0;
                }else{
                    QMessageBox::critical(0,QObject::tr("打开失败"),"文件不存在");
                    file.close();
                    ui->cloud_n->setText("");
                    return;
                }
                file.close();
            }
            points = vtkSmartPointer<vtkPoints>::New();
            vertices = vtkSmartPointer<vtkCellArray>::New();
            for(unsigned long long z=0;z<cloudarrary[c_row].size();z++){
                points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
                vertices->InsertNextCell(1);
                vertices->InsertCellPoint(z);
                if (cloudarrary[c_row][z].z < z_min)
                {
                    z_min = cloudarrary[c_row][z].z;
                }

                if (cloudarrary[c_row][z].z > z_max)
                {
                    z_max = cloudarrary[c_row][z].z;
                }
            }
            ui->cloud_n->setText(QString::number(cloudarrary[c_row].size()));
            opencloud();
        }else if(c=="找边缘点"){
            ui->setting->setCurrentIndex(9);
            QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
            QStringList s_data=order_s.at(0).split("=");
//            int raw_cloud=s_data.at(1).toInt()-1;
            ui->point_cloud->clear();
            for(int i=1;i<=c_row;i++){
                if(ui->ordertable->item(i-1,0)->text()=="off")
                    continue;
                if(ui->ordertable->item(i-1,10)->text()=="2D")
                    continue;
                ui->point_cloud->addItem(QString::number(i));
            }
            ui->point_cloud->setCurrentText(s_data.at(1));
            QStringList a=order_s.at(1).split("=");
            ui->point_direction->setCurrentIndex(a.at(1).toInt());
            point_setting_change();
             QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
            ui->point_x->setText(order_position.at(0));
            ui->point_y->setText(order_position.at(1));
            ui->point_z->setText(order_position.at(2));
            ui->point_l->setText(order_position.at(3));
            ui->point_w->setText(order_position.at(4));
            ui->point_h->setText(order_position.at(5));
            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
            if(start.x==end.x&&start.y==end.y&&start.z==end.z)
                ui->point_ROI_setting->close();
            else
                ui->point_ROI_setting->show();
            on_point_general_clicked();
        }else if(c=="找拐点"){
            ui->setting->setCurrentIndex(10);
            QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
            for(int z=0;z<order_s.size();z++){
                QStringList s_data=order_s.at(z).split("=");
                if(s_data.at(0)=="raw_cloud"){
                    ui->turning_cloud->clear();
                    for(int i=1;i<=c_row;i++){
                        if(ui->ordertable->item(i-1,0)->text()=="off")
                            continue;
                        if(ui->ordertable->item(i-1,10)->text()=="2D")
                            continue;
                        ui->turning_cloud->addItem(QString::number(i));
                    }
                    ui->turning_cloud->setCurrentText(s_data.at(1));
                }else if(s_data.at(0)=="direction"){
                    ui->turning_direction->setCurrentIndex(s_data.at(1).toInt());
                }else if(s_data.at(0)=="threshold"){
                    ui->turning_threshold->setText(s_data.at(1));
                }
            }
            turning_setting_change();
            QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
            ui->turning_x->setText(order_position.at(0));
            ui->turning_y->setText(order_position.at(1));
            ui->turning_z->setText(order_position.at(2));
            ui->turning_l->setText(order_position.at(3));
            ui->turning_w->setText(order_position.at(4));
            ui->turning_h->setText(order_position.at(5));
            start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
            end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
            if(start.x==end.x&&start.y==end.y&&start.z==end.z)
                ui->turning_ROI_setting->close();
            else
                ui->turning_ROI_setting->show();
            on_turning_general_clicked();
        }else if(c=="找线"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(18);
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");
    //            int raw_cloud=s_data.at(1).toInt()-1;
                ui->line_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->line_cloud->addItem(QString::number(i));
                }
                ui->line_cloud->setCurrentText(s_data.at(1));
                QStringList a=order_s.at(1).split("=");
                ui->line_direction->setCurrentIndex(a.at(1).toInt());
                QStringList b=order_s.at(2).split("=");
                ui->line_type->setCurrentIndex(b.at(1).toInt());
                line_setting_change();

                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                ui->line_x->setText(order_position.at(0));
                ui->line_y->setText(order_position.at(1));
                ui->line_z->setText(order_position.at(2));
                ui->line_l->setText(order_position.at(3));
                ui->line_w->setText(order_position.at(4));
                ui->line_h->setText(order_position.at(5));
                start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                if(start.x==end.x&&start.y==end.y&&start.z==end.z)
                    ui->line_ROI_setting->close();
                else
                    ui->line_ROI_setting->show();
                on_line_general_clicked();
            }
        }else if(c=="找面"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(19);
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");
    //            int raw_cloud=s_data.at(1).toInt()-1;
                ui->plane_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->plane_cloud->addItem(QString::number(i));
                }
                ui->plane_cloud->setCurrentText(s_data.at(1));
                QStringList a=order_s.at(1).split("=");
                ui->plane_direction->setCurrentIndex(a.at(1).toInt());
                plane_setting_change();

                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                ui->plane_x->setText(order_position.at(0));
                ui->plane_y->setText(order_position.at(1));
                ui->plane_z->setText(order_position.at(2));
                ui->plane_l->setText(order_position.at(3));
                ui->plane_w->setText(order_position.at(4));
                ui->plane_h->setText(order_position.at(5));
                start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                if(start.x==end.x&&start.y==end.y&&start.z==end.z)
                    ui->plane_ROI_setting->close();
                else
                    ui->plane_ROI_setting->show();
                on_plane_general_clicked();
            }
        }else if(c=="找质心"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(20);
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");
    //            int raw_cloud=s_data.at(1).toInt()-1;
                ui->Centroid_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->Centroid_cloud->addItem(QString::number(i));
                }
                Centroid_setting_change();

                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                ui->Centroid_x->setText(order_position.at(0));
                ui->Centroid_y->setText(order_position.at(1));
                ui->Centroid_z->setText(order_position.at(2));
                ui->Centroid_l->setText(order_position.at(3));
                ui->Centroid_w->setText(order_position.at(4));
                ui->Centroid_h->setText(order_position.at(5));
                start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                if(start.x==end.x&&start.y==end.y&&start.z==end.z)
                    ui->Centroid_ROI_setting->close();
                else
                    ui->Centroid_ROI_setting->show();
                on_Centroid_general_clicked();
            }
        }else if(c=="拼接"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(13);
                int raw_cloud_1,raw_cloud_2;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud_1"){
                        raw_cloud_1=s_data.at(1).toInt()-1;
                        ui->Splicing_raw_cloud_1->clear();
                        for(int i=1;i<=c_row;i++){
                            if(ui->ordertable->item(i-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(i-1,10)->text()=="2D")
                                continue;
                            ui->Splicing_raw_cloud_1->addItem(QString::number(i));
                        }
                        ui->Splicing_raw_cloud_1->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="raw_cloud_2"){
                        raw_cloud_2=s_data.at(1).toInt()-1;
                        ui->Splicing_raw_cloud_2->clear();
                        for(int i=1;i<=c_row;i++){
                            if(ui->ordertable->item(i-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(i-1,10)->text()=="2D")
                                continue;
                            ui->Splicing_raw_cloud_2->addItem(QString::number(i));
                        }
                        ui->Splicing_raw_cloud_2->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="move"){
                        ui->Splicing_CROP_move->setText(s_data.at(1));
                    }else if(s_data.at(0)=="low"){
                        ui->Splicing_CROP_low->setText(s_data.at(1));
                    }else if(s_data.at(0)=="high"){
                        ui->Splicing_CROP_high->setText(s_data.at(1));
                    }else if(s_data.at(0)=="CROP"){
                        if(s_data.at(1)=="1"){
                            ui->Splicing_CROP->setChecked(true);
                            ui->Splicing_CROP_l->show();
                            ui->Splicing_CROP_low->show();
                            ui->Splicing_CROP_high->show();
                        }else{
                            ui->Splicing_CROP->setChecked(false);
                            ui->Splicing_CROP_l->close();
                            ui->Splicing_CROP_low->close();
                            ui->Splicing_CROP_high->close();
                        }
                    }
                }
                Splicing_setting_change();
                on_Splicing_general_clicked();
            }
        }else if(c=="平滑"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(14);
                int raw_cloud;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->smooth_raw_cloud->clear();
                        for(int i=1;i<=c_row;i++){
                            if(ui->ordertable->item(i-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(i-1,10)->text()=="2D")
                                continue;
                            ui->smooth_raw_cloud->addItem(QString::number(i));
                        }
                        ui->smooth_raw_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="radius"){
                        ui->smooth_radius->setText(s_data.at(1));
                    }
                }
                smooth_setting_change();
                on_smooth_general_clicked();
            }
        }else if(c=="去重"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(15);
                int raw_cloud;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->CROP_raw_cloud->clear();
                        for(int i=1;i<=c_row;i++){
                            if(ui->ordertable->item(i-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(i-1,10)->text()=="2D")
                                continue;
                            ui->CROP_raw_cloud->addItem(QString::number(i));
                        }
                        ui->CROP_raw_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="direction"){
                        ui->CROP_direction->setCurrentIndex(s_data.at(1).toInt());
                    }else if(s_data.at(0)=="low"){
                        ui->CROP_low->setText(s_data.at(1));
                    }else if(s_data.at(0)=="high"){
                        ui->CROP_high->setText(s_data.at(1));
                    }else if(s_data.at(0)=="move"){
                        ui->CROP_move->setText(s_data.at(1));
                    }
                }
                CROP_setting_change();
                on_CROP_general_clicked();
            }
        }else if(c=="3D转深度图"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(16);
                int raw_cloud;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->Deep_raw_cloud->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->Deep_raw_cloud->addItem(QString::number(z));
                        }
                        ui->Deep_raw_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="zoom"){
                        ui->Deep_zoom->setText(s_data.at(1));
                    }else if(s_data.at(0)=="zoom_y"){
                        ui->Deep_zoom_y->setText(s_data.at(1));
                    }else if(s_data.at(0)=="wave"){
                        if(s_data.at(1)=="1"){
                            ui->Deep_wave->setChecked(true);
                            ui->Deep_threshold_l->show();
                            ui->Deep_threshold->show();
                        }else{
                            ui->Deep_wave->setChecked(false);
                            ui->Deep_threshold_l->close();
                            ui->Deep_threshold->close();
                        }
                    }else if(s_data.at(0)=="threshold"){
                        ui->Deep_threshold->setText(s_data.at(1));
                    }
                }
                Deep_setting_change();
                on_Deep_general_clicked();
            }
        }else if(c=="重采样"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(17);
                int raw_cloud;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->sampling_raw_cloud->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->sampling_raw_cloud->addItem(QString::number(z));
                        }
                        ui->sampling_raw_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="type"){
                        ui->sampling_type->setCurrentIndex(s_data.at(1).toInt());
                    }else if(s_data.at(0)=="length"){
                        ui->sampling_length->setText(s_data.at(1));
                    }else if(s_data.at(0)=="radius"){
                        ui->sampling_radius->setText(s_data.at(1));
                    }else if(s_data.at(0)=="step"){
                        ui->sampling_step->setText(s_data.at(1));
                    }
                }
                sampling_setting_change();
                on_sampling_general_clicked();
            }
        }else if(c=="滤波"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(21);
                int raw_cloud;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->wave_raw_cloud->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->wave_raw_cloud->addItem(QString::number(z));
                        }
                        ui->wave_raw_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="type"){
                        ui->wave_type->setCurrentIndex(s_data.at(1).toInt());
                        if(s_data.at(1).toInt()==0){
                            ui->wave_setting->setCurrentIndex(0);
                            ui->wave_save->show();
                        }else if(s_data.at(1).toInt()==1){
                            ui->wave_setting->setCurrentIndex(1);
                            ui->wave_number_l->setText("临近点个数");
                            ui->wave_zoom_l->setText("标准差倍数");
                            ui->wave_save->show();
                        }else if(s_data.at(1).toInt()==2){
                            ui->wave_setting->setCurrentIndex(1);
                            ui->wave_number_l->setText("邻域点集个数");
                            ui->wave_zoom_l->setText("滤波半径");
                            ui->wave_save->close();
                        }
                    }else if(s_data.at(0)=="direction"){
                        ui->wave_direction->setCurrentIndex(s_data.at(1).toInt());
                    }else if(s_data.at(0)=="up"){
                        ui->wave_up->setText(s_data.at(1));
                    }else if(s_data.at(0)=="down"){
                        ui->wave_down->setText(s_data.at(1));
                    }else if(s_data.at(0)=="number"){
                        ui->wave_number->setText(s_data.at(1));
                    }else if(s_data.at(0)=="zoom"){
                        ui->wave_zoom->setText(s_data.at(1));
                    }else if(s_data.at(0)=="save"){
                        if(s_data.at(1)=="0")
                            ui->wave_save->setChecked(false);
                        else
                            ui->wave_save->setChecked(true);
                    }
                }
                wave_setting_change();
                on_wave_general_clicked();
            }
        }else if(c=="裁切"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(22);
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");
                ui->getcloud_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->getcloud_cloud->addItem(QString::number(i));
                }
                ui->getcloud_cloud->setCurrentText(s_data.at(1));
                QStringList a=order_s.at(1).split("=");
                int in=a.at(1).toInt();
                if(in==1)
                    ui->getcloud_in->setChecked(true);
                else
                    ui->getcloud_in->setChecked(false);
                getcloud_setting_change();
                on_getcloud_general_clicked();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                ui->getcloud_x->setText(order_position.at(0));
                ui->getcloud_y->setText(order_position.at(1));
                ui->getcloud_z->setText(order_position.at(2));
                ui->getcloud_l->setText(order_position.at(3));
                ui->getcloud_w->setText(order_position.at(4));
                ui->getcloud_h->setText(order_position.at(5));
                start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                if(start.x==end.x&&start.y==end.y&&start.z==end.z)
                    ui->getcloud_ROI_setting->close();
                else
                    ui->getcloud_ROI_setting->show();
            }
        }else if(c=="拟合圆柱"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(23);
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");
                ui->cylinderSegment_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->cylinderSegment_cloud->addItem(QString::number(i));
                }
                ui->cylinderSegment_cloud->setCurrentText(s_data.at(1));
                cylinderSegment_setting_change();
                on_cylinderSegment_general_clicked();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                ui->cylinderSegment_x->setText(order_position.at(0));
                ui->cylinderSegment_y->setText(order_position.at(1));
                ui->cylinderSegment_z->setText(order_position.at(2));
                ui->cylinderSegment_l->setText(order_position.at(3));
                ui->cylinderSegment_w->setText(order_position.at(4));
                ui->cylinderSegment_h->setText(order_position.at(5));
                start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                if(start.x==end.x&&start.y==end.y&&start.z==end.z)
                    ui->cylinderSegment_ROI_setting->close();
                else
                    ui->cylinderSegment_ROI_setting->show();
            }
        }else if(c=="曲面展开"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(24);
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");
                ui->cylinderToPlane_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
    //                if(ui->ordertable->item(i-1,3)->text()!="拟合圆柱")
    //                    continue;
                    ui->cylinderToPlane_cloud->addItem(QString::number(i));
                }
                ui->cylinderToPlane_cloud->setCurrentText(s_data.at(1));
                cylinderToPlane_setting_change();
                on_cylinderToPlane_general_clicked();
            }
        }else if(c=="锚定"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(31);
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");
                ui->Anchor_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->Anchor_cloud->addItem(QString::number(i));
                }
                ui->Anchor_cloud->setCurrentText(s_data.at(1));
                ui->Anchor_x->setText(order_position.at(0));
                ui->Anchor_y->setText(order_position.at(1));
                ui->Anchor_z->setText(order_position.at(2));
                on_Anchor_general_clicked();
                Anchor_setting_change();
            }
        }else if(c=="矫正"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(32);

                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");

                QStringList a=order_s.at(1).split("=");
                qDebug()<<1;
                int line=a.at(1).toInt();


                ui->correct_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->correct_cloud->addItem(QString::number(i));
                }
                ui->correct_cloud->setCurrentText(s_data.at(1));

                if(ui->ordertable->item(s_data.at(1).toInt()-1,3)->text()=="找线"){
                    ui->correct_line->show();
                    if(line==1){
                        ui->correct_line->setChecked(true);
                        ui->correct_x->setEnabled(false);
                        ui->correct_y->setEnabled(false);
                        ui->correct_z->setEnabled(false);
                    }else{
                        ui->correct_line->setChecked(false);
                        ui->correct_x->setEnabled(true);
                        ui->correct_y->setEnabled(true);
                        ui->correct_z->setEnabled(true);
                    }
                }else{
                    ui->correct_line->close();
                    ui->correct_x->setEnabled(true);
                    ui->correct_y->setEnabled(true);
                    ui->correct_z->setEnabled(true);
                }
                ui->correct_x->setText(order_position.at(0));
                ui->correct_y->setText(order_position.at(1));
                ui->correct_z->setText(order_position.at(2));

                on_correct_general_clicked();
                correct_setting_change();

            }
        }else if(c=="零平面"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(36);
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                int raw_cloud;
                QStringList s_data=order_s.at(0).split("=");
                ui->zeroplane_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->zeroplane_cloud->addItem(QString::number(i));
                }
                ui->zeroplane_cloud->setCurrentText(s_data.at(1));
                raw_cloud=s_data.at(1).toInt();
                for(int z=1;z<order_s.size();z++){
                    QStringList plane=order_s.at(z).split("=");

                    if(plane.at(0)=="plane1"){
                        ui->zeroplane_cloud_plane_1->clear();
                        for(int i=raw_cloud+1;i<=c_row;i++){
                            if(ui->ordertable->item(i-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(i-1,10)->text()=="2D")
                                continue;
                            ui->zeroplane_cloud_plane_1->addItem(QString::number(i));
                        }
                        ui->zeroplane_cloud_plane_1->setCurrentText(plane.at(1));
                    }else if(plane.at(0)=="plane2"){
                        ui->zeroplane_cloud_plane_2->clear();
                        for(int i=raw_cloud+1;i<=c_row;i++){
                            if(ui->ordertable->item(i-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(i-1,10)->text()=="2D")
                                continue;
                            ui->zeroplane_cloud_plane_2->addItem(QString::number(i));
                        }
                        ui->zeroplane_cloud_plane_2->setCurrentText(plane.at(1));
                    }
                }
                on_zeroplane_general_clicked();
                zeroplane_settingchange();
            }
        }else if(c=="轮廓点云"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(38);

                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");

                QStringList a=order_s.at(1).split("=");
//                double y=a.at(1).toDouble();
                ui->Cloudoutline_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->Cloudoutline_cloud->addItem(QString::number(i));
                }
                ui->Cloudoutline_cloud->setCurrentText(s_data.at(1));
                ui->Cloudoutline_y->setText(a.at(1));
                on_Cloudoutline_general_clicked();
                Cloudoutline_setting_change();
            }
        }else if(c=="点到点"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(25);
                int raw_cloud,raw_cloud2;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->point_point_cloud->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->point_point_cloud->addItem(QString::number(z));
                        }
                        ui->point_point_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="raw_cloud2"){
                        raw_cloud2=s_data.at(1).toInt()-1;
                        ui->point_point_cloud_2->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->point_point_cloud_2->addItem(QString::number(z));
                        }
                        ui->point_point_cloud_2->setCurrentText(s_data.at(1));
                    }
                }
                point_point_setting_change();
                on_point_point_general_clicked();
            }
        }else if(c=="点到线"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(26);
                int raw_cloud,raw_cloud2;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->point_line_cloud->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->point_line_cloud->addItem(QString::number(z));
                        }
                        ui->point_line_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="raw_cloud2"){
                        raw_cloud2=s_data.at(1).toInt()-1;
                        ui->point_line_cloud_2->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->point_line_cloud_2->addItem(QString::number(z));
                        }
                        ui->point_line_cloud_2->setCurrentText(s_data.at(1));
                    }
                }
                point_line_setting_change();
                on_point_line_general_clicked();
            }
        }else if(c=="点到面"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(27);
                int raw_cloud,raw_cloud2;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->point_plane_cloud->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->point_plane_cloud->addItem(QString::number(z));
                        }
                        ui->point_plane_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="raw_cloud2"){
                        raw_cloud2=s_data.at(1).toInt()-1;
                        ui->point_plane_cloud_2->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->point_plane_cloud_2->addItem(QString::number(z));
                        }
                        ui->point_plane_cloud_2->setCurrentText(s_data.at(1));
                    }
                }
                point_plane_setting_change();
                on_point_plane_general_clicked();
            }
        }else if(c=="线到线"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(33);
                int raw_cloud,raw_cloud2;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->line_line_cloud->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->line_line_cloud->addItem(QString::number(z));
                        }
                        ui->line_line_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="raw_cloud2"){
                        raw_cloud2=s_data.at(1).toInt()-1;
                        ui->line_line_cloud_2->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->line_line_cloud_2->addItem(QString::number(z));
                        }
                        ui->line_line_cloud_2->setCurrentText(s_data.at(1));
                    }
                }
                line_line_setting_change();
                on_line_line_general_clicked();
            }
        }else if(c=="线到面"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(34);
                int raw_cloud,raw_cloud2;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->line_plane_cloud->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->line_plane_cloud->addItem(QString::number(z));
                        }
                        ui->line_plane_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="raw_cloud2"){
                        raw_cloud2=s_data.at(1).toInt()-1;
                        ui->line_plane_cloud_2->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->line_plane_cloud_2->addItem(QString::number(z));
                        }
                        ui->line_plane_cloud_2->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="direction"){
                        ui->line_plane_direction->setCurrentIndex(s_data.at(1).toInt());
                    }
                }

                ui->line_plane_x->setText(order_position.at(0));
                ui->line_plane_y->setText(order_position.at(1));
                ui->line_plane_z->setText(order_position.at(2));
                line_plane_setting_change();
                on_line_plane_general_clicked();
            }
        }else if(c=="面到面"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(35);
                int raw_cloud,raw_cloud2;
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud1"){
                        raw_cloud=s_data.at(1).toInt()-1;
                        ui->plane_plane_cloud->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->plane_plane_cloud->addItem(QString::number(z));
                        }
                        ui->plane_plane_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="raw_cloud2"){
                        raw_cloud2=s_data.at(1).toInt()-1;
                        ui->plane_plane_cloud_2->clear();
                        for(int z=1;z<=c_row;z++){
                            if(ui->ordertable->item(z-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(z-1,10)->text()=="2D")
                                continue;
                            ui->plane_plane_cloud_2->addItem(QString::number(z));
                        }
                        ui->plane_plane_cloud_2->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="direction"){
                        ui->plane_plane_direction->setCurrentIndex(s_data.at(1).toInt());
                    }
                }
                ui->plane_plane_x->setText(order_position.at(0));
                ui->plane_plane_y->setText(order_position.at(1));
                ui->plane_plane_z->setText(order_position.at(2));
                plane_plane_setting_change();
                on_plane_plane_general_clicked();
            }
        }else if(c=="平整度"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(28);
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");
                ui->planeness_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->planeness_cloud->addItem(QString::number(i));
                }
                ui->planeness_cloud->setCurrentText(s_data.at(1));
                QStringList a=order_s.at(1).split("=");
                double threshold=a.at(1).toDouble();
                ui->planeness_threshold->setText(QString::number(threshold));
                planeness_setting_change();
                on_planeness_general_clicked();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                ui->planeness_x->setText(order_position.at(0));
                ui->planeness_y->setText(order_position.at(1));
                ui->planeness_z->setText(order_position.at(2));
                ui->planeness_l->setText(order_position.at(3));
                ui->planeness_w->setText(order_position.at(4));
                ui->planeness_h->setText(order_position.at(5));
                start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                start.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                if(start.x==end.x&&start.y==end.y&&start.z==end.z)
                    ui->planeness_ROI_setting->close();
                else
                    ui->planeness_ROI_setting->show();
            }
        }else if(c=="截面积"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(29);
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                for(int i=0;i<order_s.size();i++){
                    QStringList s_data=order_s.at(i).split("=");
                    if(s_data.at(0)=="raw_cloud"){
                        ui->outline_cloud->clear();
                        ui->outline_custom_min->clear();
                        ui->outline_custom_max->clear();
                        for(int i=1;i<=c_row;i++){
                            if(ui->ordertable->item(i-1,0)->text()=="off")
                                continue;
                            if(ui->ordertable->item(i-1,10)->text()=="2D")
                                continue;
                            ui->outline_cloud->addItem(QString::number(i));
                            ui->outline_custom_min->addItem(QString::number(i));
                            ui->outline_custom_max->addItem(QString::number(i));
                        }
                        ui->outline_cloud->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="four"){
                        if(s_data.at(1)=="1")
                            ui->outline_four->setChecked(true);
                        else
                            ui->outline_four->setChecked(false);
                    }else if(s_data.at(0)=="custom"){
                        if(s_data.at(1)=="1")
                            ui->outline_custom->setChecked(true);
                        else
                            ui->outline_custom->setChecked(false);
                    }else if(s_data.at(0)=="custom_min"){
                        ui->outline_custom_min->setCurrentText(s_data.at(1));
                    }else if(s_data.at(0)=="custom_max"){
                        ui->outline_custom_max->setCurrentText(s_data.at(1));
                    }
                }
                outline_setting_change();
                on_outline_general_clicked();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                ui->outline_x->setText(order_position.at(0));
                ui->outline_y->setText(order_position.at(1));
                ui->outline_z->setText(order_position.at(2));
                ui->outline_l->setText(order_position.at(3));
                ui->outline_w->setText(order_position.at(4));
                ui->outline_h->setText(order_position.at(5));
                start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                end.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                if(start.x==end.x&&start.y==end.y&&start.z==end.z)
                    ui->outline_ROI_setting->close();
                else
                    ui->outline_ROI_setting->show();
            }
        }else if(c=="3d斑点高度"){
            if(c_row==0){
                QMessageBox::critical(0,QObject::tr("警告"),"请加入点云源");
                ui->settingWidget->close();
                points = vtkSmartPointer<vtkPoints>::New();
                vertices = vtkSmartPointer<vtkCellArray>::New();
                opencloud();
            }else{
                ui->setting->setCurrentIndex(37);
                QStringList order_s=ui->ordertable->item(row,4)->text().split(",");
                QStringList s_data=order_s.at(0).split("=");
                ui->Blob_3d_cloud->clear();
                for(int i=1;i<=c_row;i++){
                    if(ui->ordertable->item(i-1,0)->text()=="off")
                        continue;
                    if(ui->ordertable->item(i-1,10)->text()=="2D")
                        continue;
                    ui->Blob_3d_cloud->addItem(QString::number(i));
                }
                ui->Blob_3d_cloud->setCurrentText(s_data.at(1));
                QStringList a=order_s.at(1).split("=");
                double radius=a.at(1).toDouble();
                QStringList b=order_s.at(2).split("=");
                double number=b.at(1).toDouble();
                ui->Blob_3d_radius->setText(QString::number(radius));
                ui->Blob_3d_number->setText(QString::number(number));
                Blob_3d_setting_change();
                on_Blob_3d_general_clicked();
                QStringList order_position=ui->ordertable->item(row,9)->text().split(",");
                ui->Blob_3d_x->setText(order_position.at(0));
                ui->Blob_3d_y->setText(order_position.at(1));
                ui->Blob_3d_z->setText(order_position.at(2));
                ui->Blob_3d_l->setText(order_position.at(3));
                ui->Blob_3d_w->setText(order_position.at(4));
                ui->Blob_3d_h->setText(order_position.at(5));
                start.setPoint(order_position.at(6).toDouble(),order_position.at(7).toDouble(),order_position.at(8).toDouble());
                start.setPoint(order_position.at(9).toDouble(),order_position.at(10).toDouble(),order_position.at(11).toDouble());
                if(start.x==end.x&&start.y==end.y&&start.z==end.z)
                    ui->Blob_3d_ROI_setting->close();
                else
                    ui->Blob_3d_ROI_setting->show();
            }
        }
    }
}

//选择图像按键事件
void VGRibbonWindow::on_choose_image_clicked()
{

    QString OpenFile;
    OpenFile = QFileDialog::getOpenFileName(this,
        "please choose an image file",
        "./images",
        "Image Files(*.jpg *.png *.bmp *.pgm *.pbm);;All(*.*)");
    if (OpenFile != "")
    {
        if (image[c_row].load(OpenFile))
        {
            QGraphicsScene *scene = new QGraphicsScene;
            graphicsimageitem* bgItem = new graphicsimageitem(image[c_row]);
            n_image=image[c_row];
            connect(bgItem,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
            scene->addItem(bgItem);
            ui->graphicsView->setScene(scene);
            openimagepath=OpenFile;
            QTableWidgetItem *item = new QTableWidgetItem;
            item->setText(openimagepath);
            ui->ordertable->setItem(c_row,4,item->clone());
            item->setText("0");
            ui->ordertable->setItem(c_row,5,item->clone());
            ui->ordertable->setItem(c_row,6,item->clone());
            ui->ordertable->setItem(c_row,7,item->clone());
            ui->choose_image_width->setText(QString::number(image[c_row].width()));
            ui->choose_image_height->setText(QString::number(image[c_row].height()));
            ui->origin_x->setText("0");
            ui->origin_y->setText("0");
            ui->image_rotate->setText("0");
            origin_add(0,ui->ordertable->item(c_row,5)->text().toDouble(),ui->ordertable->item(c_row,6)->text().toDouble());
            //ui->ROI_setting->setEnabled(true);
            //ui->choose_image_height->setEnabled(true);
            //ui->choose_image_width->setEnabled(true);
            ui->image_rotate->setEnabled(true);
            ui->origin_x->setEnabled(true);
            ui->origin_y->setEnabled(true);
            settingchanged();
        }
    }
}
//图像宽度修改事件
void VGRibbonWindow::on_choose_image_width_editingFinished()
{
    settingchanged();
    image[c_row]=image[c_row].scaled(ui->choose_image_width->text().toInt()
                        ,ui->choose_image_height->text().toInt(),
                        Qt::IgnoreAspectRatio,
                        Qt::SmoothTransformation);
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    scene->addItem(raw);
    ui->graphicsView->setScene(scene);
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("image="+openimagepath+",w="+QString::number(image[c_row].width())+",h="+QString::number(image[c_row].height()));
    ui->ordertable->setItem(c_row,4,item->clone());
    item->setText("0");
    ui->ordertable->setItem(c_row,5,item->clone());
    ui->ordertable->setItem(c_row,6,item->clone());
    ui->origin_x->setText("0");
    ui->origin_y->setText("0");
    origin_add(0,ui->ordertable->item(c_row,5)->text().toDouble(),ui->ordertable->item(c_row,6)->text().toDouble());
}
//图像高度修改事件
void VGRibbonWindow::on_choose_image_height_editingFinished()
{
    settingchanged();
    image[c_row]=image[c_row].scaled(ui->choose_image_width->text().toInt()
                        ,ui->choose_image_height->text().toInt(),
                        Qt::IgnoreAspectRatio,
                        Qt::SmoothTransformation);
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    scene->addItem(raw);
    ui->graphicsView->setScene(scene);
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("image="+openimagepath+",w="+QString::number(image[c_row].width())+",h="+QString::number(image[c_row].height()));
    ui->ordertable->setItem(c_row,4,item->clone());
    item->setText("0");
    ui->ordertable->setItem(c_row,5,item->clone());
    ui->ordertable->setItem(c_row,6,item->clone());
    ui->origin_x->setText("0");
    ui->origin_y->setText("0");
    origin_add(0,ui->ordertable->item(c_row,5)->text().toDouble(),ui->ordertable->item(c_row,6)->text().toDouble());
}
//图像旋转事件
void VGRibbonWindow::on_image_rotate_editingFinished()
{
    settingchanged();
//    if(ui->image_rotate->text().toInt()%360==0)
//        return;
    image[c_row].load(openimagepath);
    qreal rat=ui->image_rotate->text().toInt();
    qreal imageWidth = image[c_row].width();
    qreal imageHeight = image[c_row].height();
    qreal rotate=rat/180*M_PI;
    QPointF p[4];
    qreal H=imageHeight;
    qreal W=imageWidth;
    qreal a = qSin(rotate) * 0.5;
    qreal b = qCos(rotate) * 0.5;
    p[0]= QPoint(imageWidth/2 + a * H- b * W, imageHeight/2 - b * H- a * W);
    p[2]= QPoint(2 * imageWidth/2 - p[0].x(), imageHeight - p[0].y());
    p[3]= QPoint(imageWidth/2 - a * H- b * W, imageHeight/2 + b * H- a * W);
    p[1]= QPoint(imageWidth - p[3].x(), imageHeight - p[3].y());
    double y_max,y_min,x_max,x_min;
    y_max=y_min=p[0].y();
    x_max=x_min=p[0].x();
    for(int i=1;i<4;i++){
        if(p[i].x()>x_max)
            x_max=p[i].x();
        else if(p[i].x()<x_min)
            x_min=p[i].x();
        if(p[i].y()>y_max)
            y_max=p[i].y();
        else if(p[i].y()<y_min)
            y_min=p[i].y();
    }
    double height=y_max-y_min,width=x_max-x_min;

    QSize t(width,height);
    QPixmap temp(t);
    temp.fill(Qt::black);
    QPainter  painter(&temp);
//    QPen mPen = QPen(QColor(255,255,255));
//    painter.setPen(mPen);
    painter.setRenderHints(QPainter::Antialiasing | QPainter::SmoothPixmapTransform | QPainter::LosslessImageRendering );
    painter.translate( width/ 2, height / 2); //让图片的中心作为旋转的中心
    painter.rotate(rat); //顺时针旋转1度
    painter.drawPixmap(-imageWidth / 2,-imageHeight / 2, image[c_row]);
    painter.end();
    image[c_row]=temp.copy();
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    scene->addItem(raw);
    ui->graphicsView->setScene(scene);
    QTableWidgetItem *item = new QTableWidgetItem;
    ui->choose_image_width->setText(QString::number(image[c_row].width()));
    ui->choose_image_height->setText(QString::number(image[c_row].height()));
    item->setText("0");
    ui->ordertable->setItem(c_row,5,item->clone());
    ui->ordertable->setItem(c_row,6,item->clone());
    ui->origin_x->setText("0");
    ui->origin_y->setText("0");
    item->setText(ui->image_rotate->text());
    ui->ordertable->setItem(c_row,7,item->clone());
    origin_add(0,ui->ordertable->item(c_row,5)->text().toDouble(),ui->ordertable->item(c_row,6)->text().toDouble());
}
//工具原点x坐标更改事件
void VGRibbonWindow::on_origin_x_editingFinished()
{
    settingchanged();
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(ui->origin_x->text());
    ui->ordertable->setItem(c_row,5,item->clone());
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    scene->addItem(raw);
    ui->graphicsView->setScene(scene);
    origin_add(0,ui->ordertable->item(c_row,5)->text().toDouble(),ui->ordertable->item(c_row,6)->text().toDouble());
}
//工具原点y坐标更改事件
void VGRibbonWindow::on_origin_y_editingFinished()
{
    settingchanged();
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(ui->origin_y->text());
    ui->ordertable->setItem(c_row,6,item->clone());
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    scene->addItem(raw);
    ui->graphicsView->setScene(scene);
    origin_add(0,ui->ordertable->item(c_row,5)->text().toDouble(),ui->ordertable->item(c_row,6)->text().toDouble());
}

//二值化general按键事件
void VGRibbonWindow::on_binary_image_General_clicked()
{
    ui->binary_image_setting->setCurrentIndex(0);
    ui->binary_image_General->setEnabled(false);
    if(!image[ui->binary_image_raw_image->currentText().toInt()-1].isNull()){
        ui->binary_image_ROI->setEnabled(true);
        ui->binary_image_preview->setEnabled(true);
        binary_image_ROI_check();
    }else{
        ui->binary_image_ROI->setEnabled(false);
        ui->binary_image_preview->setEnabled(false);
    }
}
//二值化roi按键事件
void VGRibbonWindow::on_binary_image_ROI_clicked()
{
    ui->binary_image_General->setEnabled(true);
    ui->binary_image_ROI->setEnabled(false);
    ui->binary_image_ROI_setting->show();
    if(ui->binary_image_width->text().toInt()==image[ui->binary_image_raw_image->currentText().toInt()-1].width()
     &&ui->binary_image_height->text().toInt()==image[ui->binary_image_raw_image->currentText().toInt()-1].height()){
        ui->binary_image_x->setText("1");
        ui->binary_image_y->setText("1");
        ui->binary_image_height->setText("100");
        ui->binary_image_width->setText("100");
    }
    binary_image_ROI_check();
}
//二值化预览事件
void VGRibbonWindow::on_binary_image_preview_clicked()
{
    ui->binary_image_General->setEnabled(true);
    ui->binary_image_ROI->setEnabled(true);

    QString order_type=ui->ordertable->item(c_row,8)->text();
    QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
    int type;
    YZVision::Basic2D::PointXY bounary[4];
    if(order_type=="矩形")
        type=1;
    else
        type=2;
    int x,y,height,width,rotate;
    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
    width=order_position.at(2).toInt();
    if(width==0)
        width=image[ui->binary_image_raw_image->currentText().toInt()-1].width();
    height=order_position.at(3).toInt();
    if(height==0)
        height=image[ui->binary_image_raw_image->currentText().toInt()-1].height();
    rotate=order_position.at(4).toInt();
    boundary_position(type,x,y,width,height,rotate);
    for(int j=0;j<4;j++){
        bounary[j]=boundary[j];
    }

    int result;
    QElapsedTimer  mstimer;
    mstimer.start();
    Mat raw=Image2cvMat(image[ui->binary_image_raw_image->currentText().toInt()-1].toImage());
    YZVision::Binary_2D binary;
    YZVision::Binary_2D::InputParam input= YZVision::Binary_2D::InputParam();
    YZVision::Binary_2D::OutputParam output= YZVision::Binary_2D::OutputParam();
    input.raw=raw;
    input.Adaptive=ui->binary_image_adaptive->isChecked();
    input.upper=ui->binary_image_upper_threshold->text().toInt();
    input.lower=ui->binary_image_lower_threshold->text().toInt();
    input.forecolor=ui->binary_image_forecolor->text().toInt();
    input.backcolor=ui->binary_image_backcolor->text().toInt();
    input.type=type;
    for(int j=0;j<4;j++){
        input.position[j]=bounary[j];
    }

    result=binary.Binary(input,&output);
    image[c_row]=QPixmap::fromImage(cvMat2Image(output.res));
    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* praw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    scene->addItem(praw);
    connect(praw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}
//二值化设置保存事件
void VGRibbonWindow::binary_image_setting_changed()
{
    settingchanged();
    QString Adaptive;
    if(ui->binary_image_adaptive->isChecked())
        Adaptive="true";
    else
        Adaptive="false";
    QString height,width,a;
    if(ui->binary_image_height->text().toInt()==image[ui->binary_image_raw_image->currentText().toInt()-1].height()){
        height="0";
    }else{
        height=ui->binary_image_height->text();
    }
    if(ui->binary_image_width->text().toInt()==image[ui->binary_image_raw_image->currentText().toInt()-1].width()){
        width="0";
    }else{
        width=ui->binary_image_width->text();
    }
    a=QString::number(ui->binary_image_a->text().toInt()%360);
    QTableWidgetItem *item = new QTableWidgetItem;
     item->setText("raw_image="+ui->binary_image_raw_image->currentText()+
                   ",Adaptive="+Adaptive+
                   ",upper_threshold="+ui->binary_image_upper_threshold->text()+
                   ",lower_threshold="+ui->binary_image_lower_threshold->text()+
                   ",forecolor="+ui->binary_image_forecolor->text()+
                   ",backcolor="+ui->binary_image_backcolor->text());
     ui->ordertable->setItem(c_row,4,item->clone());
     if(ui->binary_image_type->currentIndex()==0)
         item->setText("矩形");
     else
         item->setText("圆形");
     ui->ordertable->setItem(c_row,8,item->clone());
     item->setText(ui->binary_image_x->text()+","+ui->binary_image_y->text()+","+width+","+height+","+a);
     ui->ordertable->setItem(c_row,9,item->clone());
}
//二值化自适应事件
void VGRibbonWindow::on_binary_image_adaptive_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    if(ui->binary_image_adaptive->isChecked()){
        ui->binary_image_upper_threshold->setEnabled(false);
        ui->binary_image_lower_threshold->setEnabled(false);
        ui->binary_image_forecolor->setEnabled(false);
        ui->binary_image_backcolor->setEnabled(false);
    }else{
        ui->binary_image_upper_threshold->setEnabled(true);
        ui->binary_image_lower_threshold->setEnabled(true);
        ui->binary_image_forecolor->setEnabled(true);
        ui->binary_image_backcolor->setEnabled(true);
    }
    binary_image_setting_changed();
}
//二值化图源修改事件
void VGRibbonWindow::on_binary_image_raw_image_currentIndexChanged(int index)
{
    if(index>=0){
        QGraphicsScene *scene = new QGraphicsScene;
        graphicsimageitem* raw = new graphicsimageitem(image[ui->binary_image_raw_image->currentText().toInt()-1]);
        n_image=image[ui->binary_image_raw_image->currentText().toInt()-1];
        scene->addItem(raw);
        connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
        ui->graphicsView->setScene(scene);

        if(!image[ui->binary_image_raw_image->currentText().toInt()-1].isNull()){
            ui->binary_image_ROI->setEnabled(true);
            ui->binary_image_preview->setEnabled(true);
            binary_image_ROI_check();
        }else{
            ui->binary_image_ROI->setEnabled(false);
            ui->binary_image_preview->setEnabled(false);
        }
        binary_image_setting_changed();
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(ui->binary_image_raw_image->currentText().toInt()-1,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(ui->binary_image_raw_image->currentText().toInt()-1,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(ui->binary_image_raw_image->currentText().toInt()-1,7)->clone());
    }else{
        ui->binary_image_ROI->setEnabled(false);
    }
}
//二值化上阈限修改事件
void VGRibbonWindow::on_binary_image_upper_threshold_editingFinished()
{
    if(ui->binary_image_upper_threshold->text().toInt()>255){
        ui->binary_image_upper_threshold->setText("255");
        QMessageBox::warning(0, "警告","阈限请在0~255范围内");
    }
    if(ui->binary_image_upper_threshold->text().toInt()<ui->binary_image_lower_threshold->text().toInt()){
        ui->binary_image_upper_threshold->setText(ui->binary_image_lower_threshold->text());
        QMessageBox::warning(0, "警告","上阈限请大于下阈限");
    }
    binary_image_setting_changed();
}
//二值化下阈限修改事件
void VGRibbonWindow::on_binary_image_lower_threshold_editingFinished()
{
    if(ui->binary_image_lower_threshold->text().toInt()>255){
        ui->binary_image_lower_threshold->setText("255");
        QMessageBox::warning(0, "警告","阈限请在0~255范围内");
        return;
    }
    if(ui->binary_image_upper_threshold->text().toInt()<ui->binary_image_lower_threshold->text().toInt()){
        ui->binary_image_lower_threshold->setText(ui->binary_image_upper_threshold->text());
        QMessageBox::warning(0, "警告","下阈限请小于上阈限");
        return;
    }
    binary_image_setting_changed();
}
//二值化前景色修改事件
void VGRibbonWindow::on_binary_image_forecolor_editingFinished()
{
    if(ui->binary_image_forecolor->text().toInt()>255){
        ui->binary_image_forecolor->setText("255");
        QMessageBox::warning(0, "警告","前景色请在0~255范围内");
        return;
    }
    binary_image_setting_changed();
}
//二值化背景色修改事件
void VGRibbonWindow::on_binary_image_backcolor_editingFinished()
{
    if(ui->binary_image_backcolor->text().toInt()>255){
        ui->binary_image_backcolor->setText("255");
        QMessageBox::warning(0, "警告","背景色请在0~255范围内");
        return;
    }
    binary_image_setting_changed();
}
//二值化roi x坐标修改事件
void VGRibbonWindow::on_binary_image_x_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    binary_image_setting_changed();
}
//二值化roi y坐标修改事件
void VGRibbonWindow::on_binary_image_y_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    binary_image_setting_changed();
}
//二值化roi 高度修改事件
void VGRibbonWindow::on_binary_image_height_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    if(ui->binary_image_height->text()=="0")
        ui->binary_image_height->setText(QString::number(image[ui->binary_image_raw_image->currentText().toInt()-1].size().height()));
    binary_image_setting_changed();
}
//二值化roi 宽度修改事件
void VGRibbonWindow::on_binary_image_width_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    if(ui->binary_image_width->text()=="0")
        ui->binary_image_width->setText(QString::number(image[ui->binary_image_raw_image->currentText().toInt()-1].size().width()));
    binary_image_setting_changed();
}
//二值化roi 角度修改事件
void VGRibbonWindow::on_binary_image_a_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    ui->binary_image_a->setText(QString::number(ui->binary_image_a->text().toInt()%360));
    binary_image_setting_changed();
}
//二值化roi x坐标输入修改事件
void VGRibbonWindow::on_binary_image_x_editingFinished()
{
    binary_image_ROI_check();
}
//二值化roi y坐标输入修改事件
void VGRibbonWindow::on_binary_image_y_editingFinished()
{
    binary_image_ROI_check();
}
//二值化roi 高度输入修改事件
void VGRibbonWindow::on_binary_image_height_editingFinished()
{
    binary_image_ROI_check();
}
//二值化roi 宽度输入修改事件
void VGRibbonWindow::on_binary_image_width_editingFinished()
{
    binary_image_ROI_check();
}
//二值化roi 角度输入修改事件
void VGRibbonWindow::on_binary_image_a_editingFinished()
{
    binary_image_ROI_check();
}
//二值化roi取消事件
void VGRibbonWindow::on_binary_image_ROI_cancel_clicked()
{
    on_binary_image_General_clicked();
    ui->binary_image_ROI_setting->close();
    ui->binary_image_x->setText("0");
    ui->binary_image_y->setText("0");
    ui->binary_image_width->setText("0");
    ui->binary_image_height->setText("0");
    ui->binary_image_a->setText("0");
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->binary_image_raw_image->currentText().toInt()-1]);
    n_image=image[ui->binary_image_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}
//二值化roi形状修改事件
void VGRibbonWindow::on_binary_image_type_currentIndexChanged(int index)
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->binary_image_raw_image->currentText().toInt()-1]);
    n_image=image[ui->binary_image_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(index==0){
        ui->binary_image_a_l->show();
        ui->binary_image_a->show();
        ui->binary_image_w_l->show();
        ui->binary_image_width->setText(ui->binary_image_height->text());
        ui->binary_image_width->show();
        ui->binary_image_h_l->setText("高");
        ui->binary_image_x->setText(QString::number(ui->binary_image_x->text().toInt()-ui->binary_image_height->text().toInt()/2));
        ui->binary_image_y->setText(QString::number(ui->binary_image_y->text().toInt()-ui->binary_image_height->text().toInt()/2));
    }else{
        ui->binary_image_a_l->close();
        ui->binary_image_a->close();
        ui->binary_image_w_l->close();
        ui->binary_image_width->setText("1");
        ui->binary_image_width->close();
        ui->binary_image_x->setText(QString::number(ui->binary_image_x->text().toInt()+ui->binary_image_height->text().toInt()/2));
        ui->binary_image_y->setText(QString::number(ui->binary_image_y->text().toInt()+ui->binary_image_height->text().toInt()/2));
        //ui->binary_image_height->setText(QString::number(ui->binary_image_height->text().toInt()/2));
        ui->binary_image_h_l->setText("直径");
    }
    binary_image_setting_changed();
    binary_image_ROI_check();
}
//二值化roi范围检查并显示
void VGRibbonWindow::binary_image_ROI_check()
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->binary_image_raw_image->currentText().toInt()-1]);
    n_image=image[ui->binary_image_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(ui->binary_image_type->currentIndex()==0){
        QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
        int x,y,height,width,rotate;
        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
        width=order_position.at(2).toInt();
        if(width==0)
            width=image[ui->binary_image_raw_image->currentText().toInt()-1].width();
        height=order_position.at(3).toInt();
        if(height==0)
            height=image[ui->binary_image_raw_image->currentText().toInt()-1].height();
        if(width==image[ui->binary_image_raw_image->currentText().toInt()-1].width()&&height==image[ui->binary_image_raw_image->currentText().toInt()-1].height())
            return;
        rotate=order_position.at(4).toInt();
        boundary_position(1,x,y,width,height,rotate);
        qreal y_max,y_min,x_max,x_min;
        y_max=y_min=boundary[0].y;
        x_max=x_min=boundary[0].x;
        for(int j=1;j<4;j++){
            if(boundary[j].x>x_max)
                x_max=boundary[j].x;
            else if(boundary[j].x<x_min)
                x_min=boundary[j].x;
            if(boundary[j].y>y_max)
                y_max=boundary[j].y;
            else if(boundary[j].y<y_min)
                y_min=boundary[j].y;
        }

        if(x_min>=0
         &&x_max<=image[ui->binary_image_raw_image->currentText().toInt()-1].width()
         &&y_min>=0
         &&y_max<=image[ui->binary_image_raw_image->currentText().toInt()-1].height()){
            ROI_add(1,ui->binary_image_x->text().toInt(),ui->binary_image_y->text().toInt(),ui->binary_image_width->text().toInt(),ui->binary_image_height->text().toInt(),ui->binary_image_a->text().toInt());
        }else{
            ROI_add(1,0,0,100,100,0);
            ui->binary_image_x->setText("0");
            ui->binary_image_y->setText("0");
            ui->binary_image_height->setText("100");
            ui->binary_image_width->setText("100");
            ui->binary_image_a->setText("0");
        }
    }else{
        if(ui->binary_image_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()-ui->binary_image_height->text().toDouble()/2>=0
         &&ui->binary_image_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()+ui->binary_image_height->text().toDouble()/2<=image[ui->binary_image_raw_image->currentText().toInt()-1].width()
         &&ui->binary_image_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()-ui->binary_image_height->text().toDouble()/2>=0
         &&ui->binary_image_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()+ui->binary_image_height->text().toDouble()/2<=image[ui->binary_image_raw_image->currentText().toInt()-1].height()){
            ROI_add(2,ui->binary_image_x->text().toInt(),ui->binary_image_y->text().toInt(),ui->binary_image_width->text().toInt(),ui->binary_image_height->text().toInt(),0);
        }else{
            ROI_add(2,100,100,100,200,0);
            ui->binary_image_x->setText("100");
            ui->binary_image_y->setText("100");
            ui->binary_image_height->setText("200");
            ui->binary_image_width->setText("100");
        }
    }
}

//膨胀腐蚀
void VGRibbonWindow::on_Expansion_corrosion_General_clicked()
{
    ui->Expansion_corrosion_setting->setCurrentIndex(0);
    ui->Expansion_corrosion_General->setEnabled(false);
    if(!image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].isNull()){
            ui->Expansion_corrosion_ROI->setEnabled(true);
            ui->Expansion_corrosion_preview->setEnabled(true);
            Expansion_corrosion_ROI_check();
        }else{
            ui->Expansion_corrosion_ROI->setEnabled(false);
            ui->Expansion_corrosion_preview->setEnabled(false);
        }
}

void VGRibbonWindow::on_Expansion_corrosion_ROI_clicked()
{
    ui->Expansion_corrosion_General->setEnabled(true);
    ui->Expansion_corrosion_ROI_setting->show();
    ui->Expansion_corrosion_ROI->setEnabled(false);

    if(ui->Expansion_corrosion_width->text().toInt()==image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width()
     &&ui->Expansion_corrosion_height->text().toInt()==image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height()){
        ui->Expansion_corrosion_x->setText("1");
        ui->Expansion_corrosion_y->setText("1");

        ui->Expansion_corrosion_height->setText("100");
        ui->Expansion_corrosion_width->setText("100");
    }
    Expansion_corrosion_ROI_check();
}

void VGRibbonWindow::on_Expansion_corrosion_preview_clicked()
{
    ui->Expansion_corrosion_General->setEnabled(true);
    ui->Expansion_corrosion_ROI->setEnabled(true);
    QString order_type=ui->ordertable->item(c_row,8)->text();
    QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
    int type;
    YZVision::Basic2D::PointXY bounary[4];
    if(order_type=="矩形")
        type=1;
    else
        type=2;
    int x,y,height,width,rotate;
    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
    width=order_position.at(2).toInt();
    if(width==0)
        width=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width();
    height=order_position.at(3).toInt();
    if(height==0)
        height=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height();
    rotate=order_position.at(4).toInt();
    boundary_position(type,x,y,width,height,rotate);
    for(int j=0;j<4;j++){
        bounary[j]=boundary[j];
    }
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();
    Mat raw=Image2cvMat(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].toImage());
    YZVision::Morphology_2D Expansion;
    YZVision::Morphology_2D::InputParam input= YZVision::Morphology_2D::InputParam();
    YZVision::Morphology_2D::OutputParam output= YZVision::Morphology_2D::OutputParam();
    input.raw=raw;
    input.Iteration_time=ui->Expansion_corrosion_Iteration_time->text().toInt();
    input.type=type;
    for(int j=0;j<4;j++){
        input.position[j]=bounary[j];
    }

    if(ui->Expansion->isChecked()){
        result=Expansion.Expansion(input,&output);
    }else{
        result=Expansion.Corrosion(input,&output);
    }
    image[c_row]=QPixmap::fromImage(cvMat2Image(output.res));

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);

    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* praw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    scene->addItem(praw);
    connect(praw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}

void VGRibbonWindow::Expansion_corrosion_setting_changed()
{
    settingchanged();
    QString Expansion,height,width,a;
    if(ui->Expansion->isChecked()){
        Expansion="true";
    }else{
        Expansion="false";
    }
    if(ui->Expansion_corrosion_height->text().toInt()==image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height()){
        height="0";
    }else{
        height=ui->Expansion_corrosion_height->text();
    }
    if(ui->Expansion_corrosion_width->text().toInt()==image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width()){
        width="0";
    }else{
        width=ui->Expansion_corrosion_width->text();
    }
    a=QString::number(ui->Expansion_corrosion_a->text().toInt()%360);
    QTableWidgetItem *item = new QTableWidgetItem;
     item->setText("raw_image="+ui->Expansion_corrosion_raw_image->currentText()+
                   ",Iteration_time="+ui->Expansion_corrosion_Iteration_time->text()+
                   ",Expansion="+Expansion);
     ui->ordertable->setItem(c_row,4,item->clone());
     if(ui->Expansion_corrosion_type->currentIndex()==0)
         item->setText("矩形");
     else
         item->setText("圆形");
     ui->ordertable->setItem(c_row,8,item->clone());
     item->setText(ui->Expansion_corrosion_x->text()+","+ui->Expansion_corrosion_y->text()+","+width+","+height+","+a);
     ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_Expansion_corrosion_raw_image_currentIndexChanged(int index)
{
    if(index>=0){
        QGraphicsScene *scene = new QGraphicsScene;
        graphicsimageitem* raw = new graphicsimageitem(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1]);
        n_image=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1];
        scene->addItem(raw);
        connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
        ui->graphicsView->setScene(scene);
        if(!image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].isNull()){
            ui->Expansion_corrosion_ROI->setEnabled(true);
            ui->Expansion_corrosion_preview->setEnabled(true);
            Expansion_corrosion_ROI_check();
        }else{
            ui->Expansion_corrosion_ROI->setEnabled(false);
            ui->Expansion_corrosion_preview->setEnabled(false);
        }
        Expansion_corrosion_setting_changed();
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(ui->Expansion_corrosion_raw_image->currentText().toInt()-1,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(ui->Expansion_corrosion_raw_image->currentText().toInt()-1,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(ui->Expansion_corrosion_raw_image->currentText().toInt()-1,7)->clone());
    }else{
        ui->Expansion_corrosion_ROI->setEnabled(false);
    }
}

void VGRibbonWindow::on_Expansion_corrosion_Iteration_time_editingFinished()
{
    if(ui->Expansion_corrosion_Iteration_time->text().toInt()==0){
        ui->Expansion_corrosion_Iteration_time->setText("1");
        QMessageBox::warning(0, "警告","迭代次数请大于0");
        return;
    }
    Expansion_corrosion_setting_changed();
}

void VGRibbonWindow::on_Expansion_corrosion_x_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Expansion_corrosion_setting_changed();
}

void VGRibbonWindow::on_Expansion_corrosion_y_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Expansion_corrosion_setting_changed();
}

void VGRibbonWindow::on_Expansion_corrosion_height_textChanged(const QString &arg1)
{
    if(arg1.toInt()>image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height())
        ui->Expansion_corrosion_height->setText(QString::number(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height()));
    if(ui->Expansion_corrosion_height->text()=="0")
        ui->Expansion_corrosion_height->setText(QString::number(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].size().height()));
    Expansion_corrosion_setting_changed();
}

void VGRibbonWindow::on_Expansion_corrosion_width_textChanged(const QString &arg1)
{
    if(arg1.toInt()>image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width())
        ui->Expansion_corrosion_width->setText(QString::number(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width()));
    if(ui->Expansion_corrosion_width->text()=="0")
     ui->Expansion_corrosion_width->setText(QString::number(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].size().width()));
    Expansion_corrosion_setting_changed();
}

void VGRibbonWindow::on_Expansion_corrosion_a_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    ui->Expansion_corrosion_a->setText(QString::number(ui->Expansion_corrosion_a->text().toInt()%360));
    Expansion_corrosion_setting_changed();
}

void VGRibbonWindow::on_Expansion_corrosion_x_editingFinished()
{
    Expansion_corrosion_ROI_check();
}

void VGRibbonWindow::on_Expansion_corrosion_y_editingFinished()
{
    Expansion_corrosion_ROI_check();
}

void VGRibbonWindow::on_Expansion_corrosion_height_editingFinished()
{
    Expansion_corrosion_ROI_check();
}

void VGRibbonWindow::on_Expansion_corrosion_width_editingFinished()
{
    Expansion_corrosion_ROI_check();
}

void VGRibbonWindow::on_Expansion_corrosion_a_editingFinished()
{
    Expansion_corrosion_ROI_check();
}

void VGRibbonWindow::on_Expansion_corrosion_ROI_cancel_clicked()
{
    on_Expansion_corrosion_General_clicked();
    ui->Expansion_corrosion_ROI_setting->close();
    ui->Expansion_corrosion_x->setText("0");
    ui->Expansion_corrosion_y->setText("0");
    ui->Expansion_corrosion_width->setText("0");
    ui->Expansion_corrosion_height->setText("0");
    ui->Expansion_corrosion_a->setText("0");
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1]);
    n_image=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}

void VGRibbonWindow::on_Expansion_corrosion_type_currentIndexChanged(int index)
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1]);
    n_image=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(index==0){
        ui->Expansion_corrosion_a_l->show();
        ui->Expansion_corrosion_a->show();
        ui->Expansion_corrosion_w_l->show();
        ui->Expansion_corrosion_width->setText(ui->Expansion_corrosion_height->text());
        ui->Expansion_corrosion_width->show();
        ui->Expansion_corrosion_h_l->setText("高");
        ui->Expansion_corrosion_x->setText(QString::number(ui->Expansion_corrosion_x->text().toInt()-ui->Expansion_corrosion_height->text().toInt()/2));
        ui->Expansion_corrosion_y->setText(QString::number(ui->Expansion_corrosion_y->text().toInt()-ui->Expansion_corrosion_height->text().toInt()/2));
    }else{
        ui->Expansion_corrosion_a_l->close();
        ui->Expansion_corrosion_a->close();
        ui->Expansion_corrosion_w_l->close();
        ui->Expansion_corrosion_width->setText("1");
        ui->Expansion_corrosion_width->close();
        ui->Expansion_corrosion_x->setText(QString::number(ui->Expansion_corrosion_x->text().toInt()+ui->Expansion_corrosion_height->text().toInt()/2));
        ui->Expansion_corrosion_y->setText(QString::number(ui->Expansion_corrosion_y->text().toInt()+ui->Expansion_corrosion_height->text().toInt()/2));
        //ui->Expansion_corrosion_height->setText(QString::number(ui->Expansion_corrosion_height->text().toInt()/2));
        ui->Expansion_corrosion_h_l->setText("直径");
    }
    Expansion_corrosion_setting_changed();
    Expansion_corrosion_ROI_check();
}

void VGRibbonWindow::Expansion_corrosion_ROI_check()
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1]);
    n_image=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(ui->Expansion_corrosion_type->currentIndex()==0){
        QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
        int x,y,height,width,rotate;
        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
        width=order_position.at(2).toInt();
        if(width==0)
            width=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width();
        height=order_position.at(3).toInt();
        if(height==0)
            height=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height();
        if(width==image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width()&&height==image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height())
            return;
        rotate=order_position.at(4).toInt();
        boundary_position(1,x,y,width,height,rotate);
        qreal y_max,y_min,x_max,x_min;
        y_max=y_min=boundary[0].y;
        x_max=x_min=boundary[0].x;
        for(int j=1;j<4;j++){
            if(boundary[j].x>x_max)
                x_max=boundary[j].x;
            else if(boundary[j].x<x_min)
                x_min=boundary[j].x;
            if(boundary[j].y>y_max)
                y_max=boundary[j].y;
            else if(boundary[j].y<y_min)
                y_min=boundary[j].y;
        }
        if(x_min>=0
         &&x_max<=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width()
         &&y_min>=0
         &&y_max<=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height()){
            ROI_add(1,ui->Expansion_corrosion_x->text().toInt(),ui->Expansion_corrosion_y->text().toInt(),ui->Expansion_corrosion_width->text().toInt(),ui->Expansion_corrosion_height->text().toInt(),ui->Expansion_corrosion_a->text().toInt());
        }else{
            ROI_add(1,0,0,100,100,0);
            ui->Expansion_corrosion_x->setText("0");
            ui->Expansion_corrosion_y->setText("0");
            ui->Expansion_corrosion_height->setText("100");
            ui->Expansion_corrosion_width->setText("100");
            ui->Expansion_corrosion_a->setText("0");
        }
    }else{
        if(ui->Expansion_corrosion_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()-ui->Expansion_corrosion_height->text().toDouble()/2>=0
         &&ui->Expansion_corrosion_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()+ui->Expansion_corrosion_height->text().toDouble()/2<=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].width()
         &&ui->Expansion_corrosion_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()-ui->Expansion_corrosion_height->text().toDouble()/2>=0
         &&ui->Expansion_corrosion_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()+ui->Expansion_corrosion_height->text().toDouble()/2<=image[ui->Expansion_corrosion_raw_image->currentText().toInt()-1].height()){
            ROI_add(2,ui->Expansion_corrosion_x->text().toInt(),ui->Expansion_corrosion_y->text().toInt(),ui->Expansion_corrosion_width->text().toInt(),ui->Expansion_corrosion_height->text().toInt(),0);
        }else{
            ROI_add(2,100,100,100,200,0);
            ui->Expansion_corrosion_x->setText("100");
            ui->Expansion_corrosion_y->setText("100");
            ui->Expansion_corrosion_height->setText("200");
            ui->Expansion_corrosion_width->setText("100");
        }
    }
}

//图像运算
void VGRibbonWindow::on_image_math_general_clicked()
{
    ui->image_math_setting->setCurrentIndex(0);
    ui->image_math_general->setEnabled(false);
    if(!image[ui->image_math_raw_image_1->currentText().toInt()-1].isNull()){
        ui->image_math_ROI->setEnabled(true);
        ui->image_math_preview->setEnabled(true);
        image_math_ROI_1_check();
    }else{
        ui->image_math_ROI->setEnabled(false);
        ui->image_math_preview->setEnabled(false);
    }
    if(!image[ui->image_math_raw_image_2->currentText().toInt()-1].isNull()){
        ui->image_math_ROI_2->setEnabled(true);
        ui->image_math_preview->setEnabled(true);
        if(ui->image_math_operation->currentText()=="NOT"){
            ui->image_math_ROI_2->setEnabled(false);
            ui->image_math_preview->setEnabled(true);
        }
    }else{
        ui->image_math_ROI_2->setEnabled(false);
        ui->image_math_preview->setEnabled(false);
        if(ui->image_math_operation->currentText()=="NOT")
            ui->image_math_preview->setEnabled(true);
        else
            ui->image_math_preview->setEnabled(false);
    }
}


void VGRibbonWindow::on_image_math_ROI_clicked()
{
    roi=1;
    ui->image_math_ROI->setEnabled(false);
    ui->image_math_ROI_2->setEnabled(true);
    ui->image_math_general->setEnabled(true);
    ui->image_math_ROI_setting->show();
    if(ui->image_math_width->text().toInt()==image[ui->image_math_raw_image_1->currentText().toInt()-1].width()
     &&ui->image_math_height->text().toInt()==image[ui->image_math_raw_image_1->currentText().toInt()-1].height()&&
            ui->image_math_width->text().toInt()==0
                 &&ui->image_math_height->text().toInt()==0){
        ui->image_math_x->setText("1");
        ui->image_math_y->setText("1");
        ui->image_math_2_x->setText("1");
        ui->image_math_2_y->setText("1");
        ui->image_math_height->setText("100");
        ui->image_math_width->setText("100");
    }
    image_math_ROI_1_check();
}

void VGRibbonWindow::on_image_math_ROI_2_clicked()
{
    roi=2;
    ui->image_math_ROI->setEnabled(true);
    ui->image_math_ROI_2->setEnabled(false);
    ui->image_math_general->setEnabled(true);
    ui->image_math_ROI_setting_2->show();

    image_math_ROI_2_check();
}

void VGRibbonWindow::on_image_math_preview_clicked()
{
    ui->image_math_general->setEnabled(true);
    ui->image_math_ROI->setEnabled(true);

    QString order_type=ui->ordertable->item(c_row,8)->text();
    QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
    int type;
    YZVision::Basic2D::PointXY bounary[8];
    if(order_type=="矩形")
        type=1;
    else
        type=2;
    int x,y,height,width,rotate,x2,y2,a2;
    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
    x2=order_position.at(5).toInt()+ui->ordertable->item(ui->image_math_raw_image_2->currentText().toInt()-1,5)->text().toInt();
    y2=order_position.at(6).toInt()+ui->ordertable->item(ui->image_math_raw_image_2->currentText().toInt()-1,6)->text().toInt();
    width=order_position.at(2).toInt();
    if(width==0)
        width=image[ui->image_math_raw_image_1->currentText().toInt()-1].width();
    height=order_position.at(3).toInt();
    if(height==0)
        height=image[ui->image_math_raw_image_1->currentText().toInt()-1].height();
    rotate=order_position.at(4).toInt();
    a2=order_position.at(7).toInt();
    boundary_position(type,x,y,width,height,rotate);
    for(int j=0;j<4;j++){
        bounary[j]=boundary[j];
    }
    boundary_position(type,x2,y2,width,height,a2);
    for(int j=0;j<4;j++){
        bounary[4+j]=boundary[j];
    }
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();
    Mat raw1=Image2cvMat(image[ui->image_math_raw_image_1->currentText().toInt()-1].toImage());
    Mat raw2=Image2cvMat(image[ui->image_math_raw_image_2->currentText().toInt()-1].toImage());
    YZVision::Math_2D image_math;
    YZVision::Math_2D::InputParam input= YZVision::Math_2D::InputParam();
    YZVision::Math_2D::OutputParam output= YZVision::Math_2D::OutputParam();
    input.Operands=raw1;
    input.Operand=raw2;
    input.add_1=ui->image_math_add_1->text().toFloat();
    input.add_2=ui->image_math_add_2->text().toFloat();
    input.operation=ui->image_math_operation->currentText().toStdString();
    input.type=type;
    for(int j=0;j<8;j++){
        input.position[j]=bounary[j];
    }

    result=image_math.imageMath(input,&output);
    image[c_row]=QPixmap::fromImage(cvMat2Image(output.res));
    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* praw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    scene->addItem(praw);
    connect(praw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}

void VGRibbonWindow::image_math_setting_changed()
{
    settingchanged();
    QString height,width,a;
    if(ui->image_math_height->text().toInt()==image[ui->image_math_raw_image_1->currentText().toInt()-1].height()){
        height="0";
    }else{
        height=ui->image_math_height->text();
    }
    if(ui->image_math_width->text().toInt()==image[ui->image_math_raw_image_1->currentText().toInt()-1].width()){
        width="0";
    }else{
        width=ui->image_math_width->text();
    }
    a=QString::number(ui->image_math_a->text().toInt()%360);
    QTableWidgetItem *item = new QTableWidgetItem;
     item->setText("raw_image_1="+QString::number(ui->image_math_raw_image_1->currentText().toInt())+
                   ",raw_image_2="+QString::number(ui->image_math_raw_image_2->currentText().toInt())+
                   ",add_1="+ui->image_math_add_1->text()+
                   ",add_2="+ui->image_math_add_2->text()+
                   ",operation="+ui->image_math_operation->currentText());
     ui->ordertable->setItem(c_row,4,item->clone());
     if(ui->image_math_type->currentIndex()==0)
        item->setText("矩形");
     else
        item->setText("圆形");
     ui->ordertable->setItem(c_row,8,item->clone());
     item->setText(ui->image_math_x->text()+","+ui->image_math_y->text()+","+width+","+height+","+a+","+ui->image_math_2_x->text()+","+ui->image_math_2_y->text()+","+a);
     ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_image_math_raw_image_1_currentIndexChanged(int index)
{
    if(index>=0){
        QGraphicsScene *scene = new QGraphicsScene;
        graphicsimageitem* raw = new graphicsimageitem(image[ui->image_math_raw_image_1->currentText().toInt()-1]);
        n_image=image[ui->image_math_raw_image_1->currentText().toInt()-1];
        scene->addItem(raw);
        connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
        ui->graphicsView->setScene(scene);
        if(!image[ui->image_math_raw_image_1->currentText().toInt()-1].isNull()){
            ui->image_math_ROI->setEnabled(true);
            ui->image_math_preview->setEnabled(true);
            image_math_ROI_1_check();
        }else{
            ui->image_math_ROI->setEnabled(false);
            ui->image_math_preview->setEnabled(false);
        }
        image_math_setting_changed();
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(ui->image_math_raw_image_1->currentText().toInt()-1,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(ui->image_math_raw_image_1->currentText().toInt()-1,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(ui->image_math_raw_image_1->currentText().toInt()-1,7)->clone());
    }else{
        ui->image_math_ROI->setEnabled(false);
    }
}

void VGRibbonWindow::on_image_math_raw_image_2_currentIndexChanged(int index)
{
    if(index>=0){
        QGraphicsScene *scene = new QGraphicsScene;
        graphicsimageitem* raw = new graphicsimageitem(image[ui->image_math_raw_image_2->currentText().toInt()-1]);
        n_image=image[ui->image_math_raw_image_2->currentText().toInt()-1];
        scene->addItem(raw);
        connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
        ui->graphicsView->setScene(scene);
        if(!image[ui->image_math_raw_image_2->currentText().toInt()-1].isNull()){
            ui->image_math_ROI_2->setEnabled(true);
            ui->image_math_preview->setEnabled(true);
            image_math_ROI_2_check();
        }else{
            ui->image_math_ROI_2->setEnabled(false);
            ui->image_math_preview->setEnabled(false);
        }
        image_math_setting_changed();
    }else{
        ui->image_math_ROI_2->setEnabled(false);
    }
}

void VGRibbonWindow::on_image_math_operation_currentTextChanged(const QString &arg1)
{
    if(arg1=="+"){
        ui->label_23->show();
        ui->label_24->show();
        ui->image_math_add_1->show();
        ui->image_math_add_2->show();
    }else{
        ui->label_23->close();
        ui->label_24->close();
        ui->image_math_add_1->close();
        ui->image_math_add_2->close();
    }
    if(arg1=="not"){
        ui->label_18->close();
        ui->image_math_raw_image_2->close();
        ui->image_math_ROI_2->setEnabled(false);
    }else{
        ui->label_18->show();
        ui->image_math_raw_image_2->show();
        ui->image_math_ROI_2->setEnabled(true);
    }
    image_math_setting_changed();
}

void VGRibbonWindow::on_image_math_add_1_editingFinished()
{
    image_math_setting_changed();
}


void VGRibbonWindow::on_image_math_add_2_editingFinished()
{
    image_math_setting_changed();
}


void VGRibbonWindow::on_image_math_x_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    image_math_setting_changed();
}


void VGRibbonWindow::on_image_math_y_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    image_math_setting_changed();
}

void VGRibbonWindow::on_image_math_height_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    image_math_setting_changed();
}

void VGRibbonWindow::on_image_math_width_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    image_math_setting_changed();
}

void VGRibbonWindow::on_image_math_a_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    image_math_setting_changed();
}

void VGRibbonWindow::on_image_math_x_editingFinished()
{
    image_math_ROI_1_check();
}

void VGRibbonWindow::on_image_math_y_editingFinished()
{
    image_math_ROI_1_check();
}

void VGRibbonWindow::on_image_math_height_editingFinished()
{
    image_math_ROI_1_check();
}

void VGRibbonWindow::on_image_math_width_editingFinished()
{
    image_math_ROI_1_check();
}

void VGRibbonWindow::on_image_math_a_editingFinished()
{
    image_math_ROI_1_check();
}

void VGRibbonWindow::on_image_math_ROI_cancel_clicked()
{
    on_image_math_general_clicked();
    ui->image_math_ROI_setting->close();
    ui->image_math_ROI_setting_2->close();
    ui->image_math_x->setText("0");
    ui->image_math_y->setText("0");
    ui->image_math_width->setText("0");
    ui->image_math_height->setText("0");
    ui->image_math_a->setText("0");
    ui->image_math_2_x->setText("0");
    ui->image_math_2_y->setText("0");
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->image_math_raw_image_1->currentText().toInt()-1]);
    n_image=image[ui->image_math_raw_image_1->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);

}

void VGRibbonWindow::on_image_math_type_currentIndexChanged(int index)
{
    if(index==0){
        ui->image_math_a_l->show();
        ui->image_math_a->show();
        ui->image_math_w_l->show();
        ui->image_math_width->setText(ui->image_math_height->text());
        ui->image_math_width->show();
        ui->image_math_h_l->setText("高");
        ui->image_math_x->setText(QString::number(ui->image_math_x->text().toInt()-ui->image_math_height->text().toInt()/2));
        ui->image_math_y->setText(QString::number(ui->image_math_y->text().toInt()-ui->image_math_height->text().toInt()/2));
        ui->image_math_2_x->setText(QString::number(ui->image_math_2_x->text().toInt()-ui->image_math_height->text().toInt()/2));
        ui->image_math_2_y->setText(QString::number(ui->image_math_2_y->text().toInt()-ui->image_math_height->text().toInt()/2));
    }else{
        ui->image_math_a_l->close();
        ui->image_math_a->close();
        ui->image_math_w_l->close();
        ui->image_math_width->setText("1");
        ui->image_math_width->close();
        ui->image_math_x->setText(QString::number(ui->image_math_x->text().toInt()+ui->image_math_height->text().toInt()/2));
        ui->image_math_y->setText(QString::number(ui->image_math_y->text().toInt()+ui->image_math_height->text().toInt()/2));
        ui->image_math_2_x->setText(QString::number(ui->image_math_2_x->text().toInt()+ui->image_math_height->text().toInt()/2));
        ui->image_math_2_y->setText(QString::number(ui->image_math_2_y->text().toInt()+ui->image_math_height->text().toInt()/2));
        //ui->image_math_height->setText(QString::number(ui->image_math_height->text().toInt()/2));
        ui->image_math_h_l->setText("直径");
    }
    image_math_setting_changed();
    image_math_ROI_2_check();
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->image_math_raw_image_1->currentText().toInt()-1]);
    n_image=image[ui->image_math_raw_image_1->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    image_math_ROI_1_check();
}

void VGRibbonWindow::image_math_ROI_1_check()
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->image_math_raw_image_1->currentText().toInt()-1]);
    n_image=image[ui->image_math_raw_image_1->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(ui->image_math_type->currentIndex()==0){
        QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
        int x,y,height,width,rotate;
        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
        width=order_position.at(2).toInt();
        if(width==0)
            width=image[ui->image_math_raw_image_1->currentText().toInt()-1].width();
        height=order_position.at(3).toInt();
        if(height==0)
            height=image[ui->image_math_raw_image_1->currentText().toInt()-1].height();
        if(width==image[ui->image_math_raw_image_1->currentText().toInt()-1].width()&&height==image[ui->image_math_raw_image_1->currentText().toInt()-1].height())
            return;
        rotate=order_position.at(4).toInt();
        boundary_position(1,x,y,width,height,rotate);
        qreal y_max,y_min,x_max,x_min;
        y_max=y_min=boundary[0].y;
        x_max=x_min=boundary[0].x;
        for(int j=1;j<4;j++){
            if(boundary[j].x>x_max)
                x_max=boundary[j].x;
            else if(boundary[j].x<x_min)
                x_min=boundary[j].x;
            if(boundary[j].y>y_max)
                y_max=boundary[j].y;
            else if(boundary[j].y<y_min)
                y_min=boundary[j].y;
        }

        if(x_min>=0
         &&x_max<=image[ui->image_math_raw_image_1->currentText().toInt()-1].width()
         &&y_min>=0
         &&y_max<=image[ui->image_math_raw_image_1->currentText().toInt()-1].height()){
            ROI_add(1,ui->image_math_x->text().toInt(),ui->image_math_y->text().toInt(),ui->image_math_width->text().toInt(),ui->image_math_height->text().toInt(),ui->image_math_a->text().toInt());
        }else{
            ROI_add(1,0,0,100,100,0);
            ui->image_math_x->setText("0");
            ui->image_math_y->setText("0");
            ui->image_math_height->setText("100");
            ui->image_math_width->setText("100");
            ui->image_math_a->setText("0");
        }
    }else{
        if(ui->image_math_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()-ui->image_math_height->text().toDouble()/2>=0
         &&ui->image_math_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()+ui->image_math_height->text().toDouble()/2<=image[ui->image_math_raw_image_1->currentText().toInt()-1].width()
         &&ui->image_math_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()-ui->image_math_height->text().toDouble()/2>=0
         &&ui->image_math_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()+ui->image_math_height->text().toDouble()/2<=image[ui->image_math_raw_image_1->currentText().toInt()-1].height()){
            ROI_add(2,ui->image_math_x->text().toInt(),ui->image_math_y->text().toInt(),ui->image_math_width->text().toInt(),ui->image_math_height->text().toInt(),0);
        }else{
            ROI_add(2,100,100,100,200,0);
            ui->image_math_x->setText("100");
            ui->image_math_y->setText("100");
            ui->image_math_height->setText("200");
            ui->image_math_width->setText("100");
        }
    }
}

void VGRibbonWindow::on_image_math_2_x_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    image_math_setting_changed();
}


void VGRibbonWindow::on_image_math_2_y_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    image_math_setting_changed();
}

void VGRibbonWindow::on_image_math_2_x_editingFinished()
{
    image_math_ROI_2_check();
}


void VGRibbonWindow::on_image_math_2_y_editingFinished()
{
    image_math_ROI_2_check();
}

void VGRibbonWindow::image_math_ROI_2_check()
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->image_math_raw_image_2->currentText().toInt()-1]);
    n_image=image[ui->image_math_raw_image_2->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(ui->image_math_type->currentIndex()==0){
        QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
        int x,y,height,width,rotate;
        x=order_position.at(5).toInt()+ui->ordertable->item(ui->image_math_raw_image_2->currentText().toInt()-1,5)->text().toInt();
        y=order_position.at(6).toInt()+ui->ordertable->item(ui->image_math_raw_image_2->currentText().toInt()-1,6)->text().toInt();
        width=order_position.at(2).toInt();
        if(width==0)
            width=image[ui->image_math_raw_image_1->currentText().toInt()-1].width();
        height=order_position.at(3).toInt();
        if(height==0)
            height=image[ui->image_math_raw_image_1->currentText().toInt()-1].height();
        if(width==image[ui->image_math_raw_image_2->currentText().toInt()-1].width()&&height==image[ui->image_math_raw_image_2->currentText().toInt()-1].height())
            return;
        rotate=order_position.at(7).toInt();
        boundary_position(1,x,y,width,height,rotate);
        qreal y_max,y_min,x_max,x_min;
        y_max=y_min=boundary[0].y;
        x_max=x_min=boundary[0].x;
        for(int j=1;j<4;j++){
            if(boundary[j].x>x_max)
                x_max=boundary[j].x;
            else if(boundary[j].x<x_min)
                x_min=boundary[j].x;
            if(boundary[j].y>y_max)
                y_max=boundary[j].y;
            else if(boundary[j].y<y_min)
                y_min=boundary[j].y;
        }

        if(x_min>=0
         &&x_max<=image[ui->image_math_raw_image_2->currentText().toInt()-1].width()
         &&y_min>=0
         &&y_max<=image[ui->image_math_raw_image_2->currentText().toInt()-1].height()){
            ROI_add(1,ui->image_math_2_x->text().toInt(),ui->image_math_2_y->text().toInt(),ui->image_math_width->text().toInt(),ui->image_math_height->text().toInt(),ui->image_math_a->text().toInt());
        }else{
            ROI_add(1,ui->image_math_x->text().toInt(),ui->image_math_y->text().toInt(),ui->image_math_width->text().toInt(),ui->image_math_height->text().toInt(),rotate);
            ui->image_math_2_x->setText(ui->image_math_x->text());
            ui->image_math_2_y->setText(ui->image_math_y->text());
        }
    }else{
        if(ui->image_math_x->text().toDouble()+ui->ordertable->item(ui->image_math_raw_image_2->currentText().toInt()-1,5)->text().toDouble()-ui->image_math_height->text().toDouble()/2>=0
         &&ui->image_math_x->text().toDouble()+ui->ordertable->item(ui->image_math_raw_image_2->currentText().toInt()-1,5)->text().toDouble()+ui->image_math_height->text().toDouble()/2<=image[ui->image_math_raw_image_1->currentText().toInt()-1].width()
         &&ui->image_math_y->text().toDouble()+ui->ordertable->item(ui->image_math_raw_image_2->currentText().toInt()-1,6)->text().toDouble()-ui->image_math_height->text().toDouble()/2>=0
         &&ui->image_math_y->text().toDouble()+ui->ordertable->item(ui->image_math_raw_image_2->currentText().toInt()-1,6)->text().toDouble()+ui->image_math_height->text().toDouble()/2<=image[ui->image_math_raw_image_1->currentText().toInt()-1].height()){
            ROI_add(2,ui->image_math_2_x->text().toInt(),ui->image_math_2_y->text().toInt(),ui->image_math_width->text().toInt(),ui->image_math_height->text().toInt(),0);
        }else{
            ROI_add(2,ui->image_math_height->text().toDouble()/2,ui->image_math_height->text().toDouble()/2,1,ui->image_math_height->text().toDouble(),0);
            ui->image_math_2_x->setText(QString::number(ui->image_math_height->text().toDouble()/2));
            ui->image_math_2_y->setText(QString::number(ui->image_math_height->text().toDouble()/2));
        }
    }
}

//斑点查找
void VGRibbonWindow::on_blob_general_clicked()
{
    ui->blob_setting->setCurrentIndex(0);
    ui->blob_general->setEnabled(false);
    if(!image[ui->blob_raw_image->currentText().toInt()-1].isNull()){
        ui->blob_ROI->setEnabled(true);
        blob_ROI_check();
    }else{
        ui->blob_ROI->setEnabled(false);
    }
}

void VGRibbonWindow::on_blob_ROI_clicked()
{
    ui->blob_general->setEnabled(true);
    ui->blob_ROI->setEnabled(false);
    ui->blob_ROI_setting->show();

    if(ui->blob_ROI_width->text().toInt()==image[ui->blob_raw_image->currentText().toInt()-1].width()
     &&ui->blob_ROI_height->text().toInt()==image[ui->blob_raw_image->currentText().toInt()-1].height()){
        ui->blob_ROI_x->setText("1");
        ui->blob_ROI_y->setText("1");

        ui->blob_ROI_height->setText("100");
        ui->blob_ROI_width->setText("100");
    }
    blob_ROI_check();
}

void VGRibbonWindow::on_blob_preview_clicked()
{
    ui->blob_general->setEnabled(true);
    ui->blob_ROI->setEnabled(true);
    ui->blob_setting->setCurrentIndex(2);

    QString order_type=ui->ordertable->item(c_row,8)->text();
    QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
    int type;
    YZVision::Basic2D::PointXY bounary[4];
    if(order_type=="矩形")
        type=1;
    else
        type=2;
    int x,y,height,width,rotate;
    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
    width=order_position.at(2).toInt();
    if(width==0)
        width=image[ui->blob_raw_image->currentText().toInt()-1].width();
    height=order_position.at(3).toInt();
    if(height==0)
        height=image[ui->blob_raw_image->currentText().toInt()-1].height();
    rotate=order_position.at(4).toInt();
    boundary_position(type,x,y,width,height,rotate);
    for(int j=0;j<4;j++){
        bounary[j]=boundary[j];
    }
    int resu;
    QElapsedTimer  mstimer;
    mstimer.start();
    Mat raw=Image2cvMat(image[ui->blob_raw_image->currentText().toInt()-1].toImage());
    YZVision::FindBlob_2D blob;
    YZVision::FindBlob_2D::InputParam input= YZVision::FindBlob_2D::InputParam();
    YZVision::FindBlob_2D::OutputParam result= YZVision::FindBlob_2D::OutputParam();
    input.raw=raw;
    input.threshold_lower=ui->blob_threshold_lower->text().toInt();
    input.threshold_upper=ui->blob_threshold_upper->text().toInt();
    input.type=ui->blob_type->currentIndex();
    input.border=ui->blob_exclude_borders->isChecked();
    input.fill=ui->blob_fill->isChecked();
    input.type_p=type;
    for(int j=0;j<4;j++){
        input.position[j]=bounary[j];
    }
    input.width_f=ui->blob_width->isChecked();
    input.width_f_min=ui->blob_width_min->text().toInt();
    input.width_f_max=ui->blob_width_max->text().toInt();
    input.height_f=ui->blob_height->isChecked();
    input.height_f_min=ui->blob_height_min->text().toInt();
    input.height_f_max=ui->blob_height_max->text().toInt();
    input.area=ui->blob_area->isChecked();
    input.area_min=ui->blob_area_min->text().toInt();
    input.area_max=ui->blob_area_max->text().toInt();
    input.number=ui->blob_number->isChecked();
    input.number_min=ui->blob_number_min->text().toInt();
    input.number_max=ui->blob_number_max->text().toInt();

    resu=blob.FindBlob(input,&result);
    image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);

    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* praw = new graphicsimageitem(image[c_row]);
    connect(praw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    n_image=image[c_row];
    scene->addItem(praw);
    ui->graphicsView->setScene(scene);
    ui->blob_number_now->setText(QString::number(result.areas.size()));
    if(result.areas.size()>0){
        ui->blob_preview_data->show();
        ui->blob_preview_data->setRowCount(0);
        std::vector<std::vector <float>> temp;
        for(unsigned long long i=0;i<result.areas.size();i++){
            ui->blob_preview_data->setRowCount(i+1);

            item->setText(QString::number(result.widths[i]));
            ui->blob_preview_data->setItem(i,0,item->clone());
            item->setText(QString::number(result.heights[i]));
            ui->blob_preview_data->setItem(i,1,item->clone());
            item->setText(QString::number(result.areas[i]));
            ui->blob_preview_data->setItem(i,2,item->clone());
            std::vector <float> temp_widths;
            temp_widths.push_back(result.widths[i]);
            temp_widths.push_back(result.heights[i]);
            temp_widths.push_back(result.areas[i]);
            temp.push_back(temp_widths);
            std::vector <float> temp_points;
            for(unsigned long long z=0;z<result.resContours[i].size();z++){
                temp_points.push_back(result.resContours[i][z].x);
                temp_points.push_back(result.resContours[i][z].y);
            }
            temp.push_back(temp_points);
        }
        res[c_row]=temp;
        if(ui->blob_number->isChecked()==true)
            if(result.areas.size()<ui->blob_number_min->text().toInt()||result.areas.size()>ui->blob_number_max->text().toInt()){
                ui->blob_passorfail->setText("失败");
                ui->blob_passorfail->setStyleSheet("color: rgb(170, 0, 0)");
                ui->blob_number_now->setStyleSheet("color: rgb(170, 0, 0)");
                ui->blob_preview_data->close();
                return;
            }
        ui->blob_passorfail->setText("通过");
        ui->blob_passorfail->setStyleSheet("color: rgb(0, 170, 0)");
        ui->blob_number_now->setStyleSheet("color: rgb(0, 170, 0)");
    }else{
        ui->blob_passorfail->setText("失败");
        ui->blob_passorfail->setStyleSheet("color: rgb(170, 0, 0)");
        ui->blob_number_now->setStyleSheet("color: rgb(170, 0, 0)");
        ui->blob_preview_data->close();
    }
}

void VGRibbonWindow::blob_setting_changed()
{
    settingchanged();
    QString border,fill,width,height,a,area,number;
    if(ui->blob_exclude_borders->isChecked())
        border="true";
    else
        border="false";
    if(ui->blob_fill->isChecked())
        fill="true";
    else
        fill="false";
    if(ui->blob_width->isChecked())
        width="true";
    else
        width="false";
    if(ui->blob_height->isChecked())
        height="true";
    else
        height="false";
    if(ui->blob_area->isChecked())
        area="true";
    else
        area="false";
    if(ui->blob_number->isChecked())
        number="true";
    else
        number="false";
    QString ROI_height,ROI_width,ROI_a;
    if(ui->blob_ROI_height->text().toInt()==image[ui->blob_raw_image->currentText().toInt()-1].height()){
        ROI_height="0";
    }else{
        ROI_height=ui->blob_ROI_height->text();
    }
    if(ui->blob_ROI_width->text().toInt()==image[ui->blob_raw_image->currentText().toInt()-1].width()){
        ROI_width="0";
    }else{
        ROI_width=ui->blob_ROI_width->text();
    }
    ROI_a=QString::number(ui->blob_ROI_a->text().toInt()%360);
    QTableWidgetItem *item = new QTableWidgetItem;
     item->setText("raw_image="+ui->blob_raw_image->currentText()+
                   ",type="+QString::number(ui->blob_type->currentIndex())+
                   ",threshold_lower="+ui->blob_threshold_lower->text()+
                   ",threshold_upper="+ui->blob_threshold_upper->text()+
                   ",border="+border+
                   ",fill="+fill+
                   ",width_f="+width+",width_f_min="+ui->blob_width_min->text()+",width_f_max="+ui->blob_width_max->text()+
                   ",height_f="+height+",height_f_min="+ui->blob_height_min->text()+",height_f_max="+ui->blob_height_max->text()+
                   ",area="+area+",area_min="+ui->blob_area_min->text()+",area_max="+ui->blob_area_max->text()+
                   ",number="+number+",number_min="+ui->blob_number_min->text()+",number_max="+ui->blob_number_max->text());
     ui->ordertable->setItem(c_row,4,item->clone());
     if(ui->blob_ROI_type->currentIndex()==0)
        item->setText("矩形");
     else
        item->setText("圆形");
     ui->ordertable->setItem(c_row,8,item->clone());
     item->setText(ui->blob_ROI_x->text()+","+ui->blob_ROI_y->text()+","+ROI_width+","+ROI_height+","+ROI_a);
     ui->ordertable->setItem(c_row,9,item->clone());

}

void VGRibbonWindow::on_blob_raw_image_currentIndexChanged(int index)
{
    if(index>=0){
            QGraphicsScene *scene = new QGraphicsScene;
            graphicsimageitem* raw = new graphicsimageitem(image[ui->blob_raw_image->currentText().toInt()-1]);
            n_image=image[ui->blob_raw_image->currentText().toInt()-1];
            scene->addItem(raw);
            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
            ui->graphicsView->setScene(scene);
            if(!image[ui->blob_raw_image->currentText().toInt()-1].isNull()){
                ui->blob_ROI->setEnabled(true);
                ui->blob_preview->setEnabled(true);
                blob_ROI_check();
            }else{
                ui->blob_ROI->setEnabled(false);
                ui->blob_preview->setEnabled(false);
            }
            blob_setting_changed();
            ui->ordertable->setItem(c_row,5,ui->ordertable->item(ui->blob_raw_image->currentText().toInt()-1,5)->clone());
            ui->ordertable->setItem(c_row,6,ui->ordertable->item(ui->blob_raw_image->currentText().toInt()-1,6)->clone());
            ui->ordertable->setItem(c_row,7,ui->ordertable->item(ui->blob_raw_image->currentText().toInt()-1,7)->clone());
    }else{
            ui->blob_ROI->setEnabled(false);
    }
}

void VGRibbonWindow::on_blob_type_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    blob_setting_changed();
}

void VGRibbonWindow::on_blob_threshold_lower_editingFinished()
{
    if(ui->blob_threshold_upper->text().toInt()<ui->blob_threshold_lower->text().toInt()){
        ui->blob_threshold_lower->setText(ui->blob_threshold_upper->text());
        QMessageBox::warning(0, "警告","上阈值请大于下阈值");
    }
    if(ui->blob_threshold_upper->text().toInt()>255){
        ui->blob_threshold_lower->setText(ui->blob_threshold_upper->text());
        QMessageBox::warning(0, "警告","阈限请在0~255范围内");
    }
    blob_setting_changed();
}

void VGRibbonWindow::on_blob_threshold_upper_editingFinished()
{
    if(ui->blob_threshold_upper->text().toInt()<ui->blob_threshold_lower->text().toInt()){
        ui->blob_threshold_upper->setText(ui->blob_threshold_lower->text());
        QMessageBox::warning(0, "警告","上阈值请大于下阈值");
    }
    if(ui->blob_threshold_upper->text().toInt()>255){
        ui->blob_threshold_upper->setText(ui->blob_threshold_lower->text());
        QMessageBox::warning(0, "警告","阈限请在0~255范围内");
    }
    blob_setting_changed();
}

void VGRibbonWindow::on_blob_exclude_borders_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    blob_setting_changed();
}

void VGRibbonWindow::on_blob_fill_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    blob_setting_changed();
}

void VGRibbonWindow::on_blob_ROI_x_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    blob_setting_changed();
}

void VGRibbonWindow::on_blob_ROI_y_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    blob_setting_changed();
}

void VGRibbonWindow::on_blob_ROI_height_textChanged(const QString &arg1)
{
    if(arg1.toInt()>image[ui->blob_raw_image->currentText().toInt()-1].height())
        ui->blob_ROI_height->setText(QString::number(image[ui->blob_raw_image->currentText().toInt()-1].height()));
    if(ui->blob_ROI_height->text()=="0")
        ui->blob_ROI_height->setText(QString::number(image[ui->blob_raw_image->currentText().toInt()-1].height()));
    blob_setting_changed();
}

void VGRibbonWindow::on_blob_ROI_width_textChanged(const QString &arg1)
{
    if(arg1.toInt()>image[ui->blob_raw_image->currentText().toInt()-1].width())
        ui->blob_ROI_width->setText(QString::number(image[ui->blob_raw_image->currentText().toInt()-1].width()));
    if(ui->blob_ROI_width->text()=="0")
        ui->blob_ROI_width->setText(QString::number(image[ui->blob_raw_image->currentText().toInt()-1].width()));
    blob_setting_changed();
}

void VGRibbonWindow::on_blob_ROI_a_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    ui->blob_ROI_a->setText(QString::number(ui->blob_ROI_a->text().toInt()%360));
    blob_setting_changed();
}

void VGRibbonWindow::on_blob_ROI_x_editingFinished()
{
    blob_ROI_check();
}

void VGRibbonWindow::on_blob_ROI_y_editingFinished()
{
    blob_ROI_check();
}

void VGRibbonWindow::on_blob_ROI_height_editingFinished()
{
    blob_ROI_check();
}

void VGRibbonWindow::on_blob_ROI_width_editingFinished()
{
    blob_ROI_check();
}

void VGRibbonWindow::on_blob_ROI_a_editingFinished()
{
    blob_ROI_check();
}

void VGRibbonWindow::on_blob_ROI_cancel_clicked()
{
    on_blob_general_clicked();
    ui->blob_ROI_setting->close();
    ui->blob_ROI_x->setText("0");
    ui->blob_ROI_y->setText("0");
    ui->blob_ROI_width->setText("0");
    ui->blob_ROI_height->setText("0");
    ui->blob_ROI_a->setText("0");
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->blob_raw_image->currentText().toInt()-1]);
    n_image=image[ui->blob_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}

void VGRibbonWindow::on_blob_ROI_type_currentIndexChanged(int index)
{
    if(index==0){
        ui->blob_ROI_a_l->show();
        ui->blob_ROI_a->show();
        ui->blob_ROI_w_l->show();
        ui->blob_ROI_width->setText(ui->blob_ROI_height->text());
        ui->blob_ROI_width->show();
        ui->blob_ROI_h_l->setText("高");
        ui->blob_ROI_x->setText(QString::number(ui->blob_ROI_x->text().toInt()-ui->blob_ROI_height->text().toInt()/2));
        ui->blob_ROI_y->setText(QString::number(ui->blob_ROI_y->text().toInt()-ui->blob_ROI_height->text().toInt()/2));
    }else{
        ui->blob_ROI_a_l->close();
        ui->blob_ROI_a->close();
        ui->blob_ROI_w_l->close();
        ui->blob_ROI_width->setText("1");
        ui->blob_ROI_width->close();
        ui->blob_ROI_x->setText(QString::number(ui->blob_ROI_x->text().toInt()+ui->blob_ROI_height->text().toInt()/2));
        ui->blob_ROI_y->setText(QString::number(ui->blob_ROI_y->text().toInt()+ui->blob_ROI_height->text().toInt()/2));
        //ui->blob_ROI_height->setText(QString::number(ui->blob_ROI_height->text().toInt()/2));
        ui->blob_ROI_h_l->setText("直径");
    }
    blob_setting_changed();
    blob_ROI_check();
}

void VGRibbonWindow::blob_ROI_check()
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->blob_raw_image->currentText().toInt()-1]);
    n_image=image[ui->blob_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(ui->blob_ROI_type->currentIndex()==0){
        QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
        int x,y,height,width,rotate;
        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
        width=order_position.at(2).toInt();
        if(width==0)
            width=image[ui->blob_raw_image->currentText().toInt()-1].width();
        height=order_position.at(3).toInt();
        if(height==0)
            height=image[ui->blob_raw_image->currentText().toInt()-1].height();
        if(width==image[ui->blob_raw_image->currentText().toInt()-1].width()&&height==image[ui->blob_raw_image->currentText().toInt()-1].height())
            return;
        rotate=order_position.at(4).toInt();
        boundary_position(1,x,y,width,height,rotate);
        qreal y_max,y_min,x_max,x_min;
        y_max=y_min=boundary[0].y;
        x_max=x_min=boundary[0].x;
        for(int j=1;j<4;j++){
            if(boundary[j].x>x_max)
                x_max=boundary[j].x;
            else if(boundary[j].x<x_min)
                x_min=boundary[j].x;
            if(boundary[j].y>y_max)
                y_max=boundary[j].y;
            else if(boundary[j].y<y_min)
                y_min=boundary[j].y;
        }

        if(x_min>=0
         &&x_max<=image[ui->blob_raw_image->currentText().toInt()-1].width()
         &&y_min>=0
         &&y_max<=image[ui->blob_raw_image->currentText().toInt()-1].height()){
            ROI_add(1,ui->blob_ROI_x->text().toInt(),ui->blob_ROI_y->text().toInt(),ui->blob_ROI_width->text().toInt(),ui->blob_ROI_height->text().toInt(),ui->blob_ROI_a->text().toInt());
        }else{
            ROI_add(1,0,0,100,100,0);
            ui->blob_ROI_x->setText("0");
            ui->blob_ROI_y->setText("0");
            ui->blob_ROI_height->setText("100");
            ui->blob_ROI_width->setText("100");
            ui->blob_ROI_a->setText("0");
        }
    }else{
        if(ui->blob_ROI_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()-ui->blob_ROI_height->text().toDouble()/2>=0
         &&ui->blob_ROI_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()+ui->blob_ROI_height->text().toDouble()/2<=image[ui->blob_raw_image->currentText().toInt()-1].width()
         &&ui->blob_ROI_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()-ui->blob_ROI_height->text().toDouble()/2>=0
         &&ui->blob_ROI_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()+ui->blob_ROI_height->text().toDouble()/2<=image[ui->blob_raw_image->currentText().toInt()-1].height()){
            ROI_add(2,ui->blob_ROI_x->text().toInt(),ui->blob_ROI_y->text().toInt(),ui->blob_ROI_width->text().toInt(),ui->blob_ROI_height->text().toInt(),0);
        }else{
            ROI_add(2,100,100,100,200,0);
            ui->blob_ROI_x->setText("100");
            ui->blob_ROI_y->setText("100");
            ui->blob_ROI_height->setText("200");
            ui->blob_ROI_width->setText("100");
        }
    }
}

void VGRibbonWindow::on_blob_width_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    blob_setting_changed();
    if(ui->blob_width->isChecked()==true){
        ui->blob_width_min->setEnabled(true);
        ui->blob_width_max->setEnabled(true);
    }else{
        ui->blob_width_min->setEnabled(false);
        ui->blob_width_max->setEnabled(false);
    }
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_width_min_editingFinished()
{
    if(ui->blob_width_min->text().toInt()>ui->blob_width_max->text().toInt()){
        ui->blob_width_min->setText(ui->blob_width_max->text());
        QMessageBox::warning(0, "警告","最大值请大于最小值");
    }
    blob_setting_changed();
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_width_max_editingFinished()
{
    if(ui->blob_width_min->text().toInt()>ui->blob_width_max->text().toInt()){
        ui->blob_width_max->setText(ui->blob_width_min->text());
        QMessageBox::warning(0, "警告","最大值请大于最小值");
    }
    blob_setting_changed();
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_height_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    blob_setting_changed();
    if(ui->blob_height->isChecked()==true){
        ui->blob_height_min->setEnabled(true);
        ui->blob_height_max->setEnabled(true);
    }else{
        ui->blob_height_min->setEnabled(false);
        ui->blob_height_max->setEnabled(false);
    }
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_height_min_editingFinished()
{
    if(ui->blob_height_min->text().toInt()>ui->blob_height_max->text().toInt()){
        ui->blob_height_min->setText(ui->blob_height_max->text());
        QMessageBox::warning(0, "警告","最大值请大于最小值");
    }
    blob_setting_changed();
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_height_max_editingFinished()
{
    if(ui->blob_height_min->text().toInt()>ui->blob_height_max->text().toInt()){
        ui->blob_height_max->setText(ui->blob_height_min->text());
        QMessageBox::warning(0, "警告","最大值请大于最小值");
    }
    blob_setting_changed();
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_area_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    blob_setting_changed();
    if(ui->blob_area->isChecked()==true){
        ui->blob_area_min->setEnabled(true);
        ui->blob_area_max->setEnabled(true);
    }else{
        ui->blob_area_min->setEnabled(false);
        ui->blob_area_max->setEnabled(false);
    }
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_area_min_editingFinished()
{
    if(ui->blob_area_min->text().toInt()>ui->blob_area_max->text().toInt()){
        ui->blob_area_min->setText(ui->blob_area_max->text());
        QMessageBox::warning(0, "警告","最大值请大于最小值");
    }
    blob_setting_changed();
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_area_max_editingFinished()
{
    if(ui->blob_area_min->text().toInt()>ui->blob_area_max->text().toInt()){
        ui->blob_area_max->setText(ui->blob_area_min->text());
        QMessageBox::warning(0, "警告","最大值请大于最小值");
    }
    blob_setting_changed();
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_number_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    blob_setting_changed();
    if(ui->blob_number->isChecked()==true){
        ui->blob_number_min->setEnabled(true);
        ui->blob_number_max->setEnabled(true);
    }else{
        ui->blob_number_min->setEnabled(false);
        ui->blob_number_max->setEnabled(false);
    }
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_number_min_editingFinished()
{
    if(ui->blob_number_min->text().toInt()>ui->blob_number_max->text().toInt()){
        ui->blob_number_min->setText(ui->blob_number_max->text());
        QMessageBox::warning(0, "警告","最大值请大于最小值");
    }
    if(ui->blob_number_min->text().toInt()<=0){
        ui->blob_number_min->setText(ui->blob_number_max->text());
        QMessageBox::warning(0, "警告","数量限制请大于0");
    }
    blob_setting_changed();
    on_blob_preview_clicked();
}

void VGRibbonWindow::on_blob_number_max_editingFinished()
{
    if(ui->blob_number_min->text().toInt()>ui->blob_number_max->text().toInt()){
        ui->blob_number_max->setText(ui->blob_number_min->text());
        QMessageBox::warning(0, "警告","最大值请大于最小值");
    }
    if(ui->blob_number_max->text().toInt()<=0){
        ui->blob_number_max->setText(ui->blob_number_min->text());
        QMessageBox::warning(0, "警告","数量限制请大于0");
    }
    blob_setting_changed();
    on_blob_preview_clicked();
}

//线查找
void VGRibbonWindow::on_line_find_general_clicked()
{
    ui->line_find_general->setEnabled(false);
    ui->line_find_setting->setCurrentIndex(0);
    if(!image[ui->line_find_raw_image->currentText().toInt()-1].isNull()){
        ui->line_find_ROI->setEnabled(true);
        ui->line_find_preview->setEnabled(true);
        line_find_ROI_check();
    }else{
        ui->line_find_ROI->setEnabled(false);
        ui->line_find_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_line_find_ROI_clicked()
{
    ui->line_find_general->setEnabled(true);
    ui->line_find_ROI->setEnabled(false);
    ui->line_find_ROI_setting->show();
    line_find_ROI_check();
}

void VGRibbonWindow::on_line_find_preview_clicked()
{
    ui->line_find_general->setEnabled(true);
    ui->line_find_ROI->setEnabled(true);
    ui->line_find_setting->setCurrentIndex(2);
    QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
    YZVision::Basic2D::PointXY bounary[4];
    int x,y,height,width,rotate;
    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
    width=order_position.at(2).toInt();
    if(width==0)
        width=image[ui->line_find_raw_image->currentText().toInt()-1].width();
    height=order_position.at(3).toInt();
    if(height==0)
        height=image[ui->line_find_raw_image->currentText().toInt()-1].height();
    rotate=order_position.at(4).toInt();
    boundary_position(1,x,y,width,height,rotate);
    for(int j=0;j<4;j++){
        bounary[j]=boundary[j];
    }
    int resu;
    QElapsedTimer  mstimer;
    mstimer.start();
    Mat raw=Image2cvMat(image[ui->line_find_raw_image->currentText().toInt()-1].toImage());
    YZVision::FindLine_2D line_find;
    YZVision::FindLine_2D::InputParam input= YZVision::FindLine_2D::InputParam();
    YZVision::FindLine_2D::OutputParam result= YZVision::FindLine_2D::OutputParam();
    input.raw=raw;
    input.threshold_lower=ui->line_find_threshold_lower->text().toInt();
    input.threshold_upper=ui->line_find_threshold_upper->text().toInt();
    input.type=ui->line_find_type->currentIndex();
    input.border=ui->line_find_border->currentIndex();
    input.ratio=ui->line_find_ratio->text().toInt();
    input.subpixel=ui->line_find_Subpixel->text().toInt();
    for(int j=0;j<4;j++){
        input.position[j]=bounary[j];
    }
    resu=line_find.FindLine(input,&result);
    image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));
    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* praw = new graphicsimageitem(image[c_row]);
    connect(praw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    n_image=image[c_row];
    scene->addItem(praw);
    ui->graphicsView->setScene(scene);
    ui->line_find_setting->setCurrentIndex(2);
    if(result.code){
        ui->line_find_pass->setText("失败");
        ui->line_find_pass->setStyleSheet("color: rgb(170, 0, 0)");
        ui->line_find_start_point->setText("");
        ui->line_find_end_point->setText("");
        ui->line_find_length->setText("");
        ui->line_find_rotate->setText("");
    }else{
        ui->line_find_pass->setText("成功");
        ui->line_find_pass->setStyleSheet("color: rgb(0, 170, 0)");
        double x1,x2,y1,y2,t,a;
        x1=result.l.a.x;
        y1=result.l.a.y;
        x2=result.l.b.x;
        y2=result.l.b.y;
        t=sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
        a=atan2((y1-y2),(x2-x1));
        a=a*180/M_PI;
        ui->line_find_start_point->setText("("+QString::number(x1)+","+QString::number(y1)+")");
        ui->line_find_end_point->setText("("+QString::number(x2)+","+QString::number(y2)+")");
        ui->line_find_length->setText(QString::number(t));
        ui->line_find_rotate->setText(QString::number(a));
        std::vector<std::vector <float>> temp;
        std::vector <float> temp_start;
        temp_start.push_back(result.l.a.x);
        temp_start.push_back(result.l.a.y);
        temp.push_back(temp_start);
        std::vector <float> temp_end;
        temp_end.push_back(result.l.b.x);
        temp_end.push_back(result.l.b.y);
        temp.push_back(temp_end);
        std::vector <float> samplePts;
        for(unsigned long long z=0;z<result.samplePts.size();z++){
            samplePts.push_back(result.samplePts[z].x);
            samplePts.push_back(result.samplePts[z].y);
        }
        temp.push_back(samplePts);
        res[c_row]=temp;
    }
}

void VGRibbonWindow::line_find_setting_changed()
{
    settingchanged();
    QString height,width,a;
    if(ui->line_find_height->text().toInt()==image[ui->line_find_raw_image->currentText().toInt()-1].height()){
        height="0";
    }else{
        height=ui->line_find_height->text();
    }
    if(ui->line_find_width->text().toInt()==image[ui->line_find_raw_image->currentText().toInt()-1].width()){
        width="0";
    }else{
        width=ui->line_find_width->text();
    }
    a=QString::number(ui->line_find_a->text().toInt()%360);
    QTableWidgetItem *item = new QTableWidgetItem;
     item->setText("raw_image="+QString::number(ui->line_find_raw_image->currentText().toInt())+
                   ",threshold_lower="+ui->line_find_threshold_lower->text()+
                   ",threshold_upper="+ui->line_find_threshold_upper->text()+
                   ",type="+QString::number(ui->line_find_type->currentIndex())+
                   ",border="+QString::number(ui->line_find_border->currentIndex())+
                   ",ratio="+ui->line_find_ratio->text()+
                   ",Subpixel="+ui->line_find_Subpixel->text());
     ui->ordertable->setItem(c_row,4,item->clone());
     item->setText(ui->line_find_x->text()+","+ui->line_find_y->text()+","+width+","+height+","+a);
     ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_line_find_raw_image_currentIndexChanged(int index)
{
    if(index>=0){
            QGraphicsScene *scene = new QGraphicsScene;
            graphicsimageitem* raw = new graphicsimageitem(image[ui->line_find_raw_image->currentText().toInt()-1]);
            n_image=image[ui->line_find_raw_image->currentText().toInt()-1];
            scene->addItem(raw);
            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
            ui->graphicsView->setScene(scene);
            if(!image[ui->line_find_raw_image->currentText().toInt()-1].isNull()){
                ui->line_find_ROI->setEnabled(true);
                ui->line_find_preview->setEnabled(true);
                line_find_ROI_check();
            }else{
                ui->line_find_ROI->setEnabled(false);
                ui->line_find_preview->setEnabled(false);
            }
            line_find_setting_changed();
            ui->ordertable->setItem(c_row,5,ui->ordertable->item(ui->line_find_raw_image->currentText().toInt()-1,5)->clone());
            ui->ordertable->setItem(c_row,6,ui->ordertable->item(ui->line_find_raw_image->currentText().toInt()-1,6)->clone());
            ui->ordertable->setItem(c_row,7,ui->ordertable->item(ui->line_find_raw_image->currentText().toInt()-1,7)->clone());
    }else{
            ui->line_find_ROI->setEnabled(false);
    }
}

void VGRibbonWindow::on_line_find_threshold_lower_editingFinished()
{
    if(ui->line_find_threshold_upper->text().toInt()<ui->line_find_threshold_lower->text().toInt()){
        ui->line_find_threshold_lower->setText(ui->line_find_threshold_upper->text());
        QMessageBox::warning(0, "警告","上阈值请大于下阈值");
    }
    if(ui->line_find_threshold_upper->text().toInt()>255){
        ui->line_find_threshold_lower->setText(ui->line_find_threshold_upper->text());
        QMessageBox::warning(0, "警告","阈限请在0~255范围内");
    }
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_threshold_upper_editingFinished()
{
    if(ui->line_find_threshold_upper->text().toInt()<ui->line_find_threshold_lower->text().toInt()){
        ui->line_find_threshold_upper->setText(ui->line_find_threshold_lower->text());
        QMessageBox::warning(0, "警告","上阈值请大于下阈值");
    }
    if(ui->line_find_threshold_upper->text().toInt()>255){
        ui->line_find_threshold_upper->setText(ui->line_find_threshold_lower->text());
        QMessageBox::warning(0, "警告","阈限请在0~255范围内");
    }
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_type_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_border_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_ratio_editingFinished()
{
    if(ui->line_find_ratio->text().toInt()>100){
        QMessageBox::warning(0, "警告","采样比率最大值为100");
        ui->line_find_ratio->setText("100");
    }
    if(ui->line_find_ratio->text().toInt()<1){
        QMessageBox::warning(0, "警告","采样比率最小值为1");
        ui->line_find_ratio->setText("1");
    }
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_Subpixel_editingFinished()
{
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_x_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_y_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_height_textChanged(const QString &arg1)
{
    if(arg1.toInt()>image[ui->line_find_raw_image->currentText().toInt()-1].height())
        ui->line_find_height->setText(QString::number(image[ui->line_find_raw_image->currentText().toInt()-1].height()));
    if(ui->line_find_height->text()=="0")
        ui->line_find_height->setText(QString::number(image[ui->line_find_raw_image->currentText().toInt()-1].height()));
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_width_textChanged(const QString &arg1)
{
    if(arg1.toInt()>image[ui->line_find_raw_image->currentText().toInt()-1].width())
        ui->line_find_width->setText(QString::number(image[ui->line_find_raw_image->currentText().toInt()-1].width()));
    if(ui->line_find_width->text()=="0")
        ui->line_find_width->setText(QString::number(image[ui->line_find_raw_image->currentText().toInt()-1].width()));
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_a_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    ui->line_find_a->setText(QString::number(ui->line_find_a->text().toInt()%360));
    line_find_setting_changed();
}

void VGRibbonWindow::on_line_find_x_editingFinished()
{
    line_find_ROI_check();
}

void VGRibbonWindow::on_line_find_y_editingFinished()
{
    line_find_ROI_check();
}

void VGRibbonWindow::on_line_find_height_editingFinished()
{
    line_find_ROI_check();
}

void VGRibbonWindow::on_line_find_width_editingFinished()
{
    line_find_ROI_check();
}

void VGRibbonWindow::on_line_find_a_editingFinished()
{
    line_find_ROI_check();
}

void VGRibbonWindow::line_find_ROI_check()
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->Circle_find_raw_image->currentText().toInt()-1]);
    n_image=image[ui->line_find_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);

    QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
    int x,y,height,width,rotate;
    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
    width=order_position.at(2).toInt();
    if(width==0)
        width=image[ui->line_find_raw_image->currentText().toInt()-1].width();
    height=order_position.at(3).toInt();
    if(height==0)
        height=image[ui->line_find_raw_image->currentText().toInt()-1].height();
    rotate=order_position.at(4).toInt();
    boundary_position(1,x,y,width,height,rotate);
    qreal y_max,y_min,x_max,x_min;
    y_max=y_min=boundary[0].y;
    x_max=x_min=boundary[0].x;
    for(int j=1;j<4;j++){
        if(boundary[j].x>x_max)
            x_max=boundary[j].x;
        else if(boundary[j].x<x_min)
            x_min=boundary[j].x;
        if(boundary[j].y>y_max)
            y_max=boundary[j].y;
        else if(boundary[j].y<y_min)
            y_min=boundary[j].y;
    }

    if(x_min>=0
     &&x_max<=image[ui->line_find_raw_image->currentText().toInt()-1].width()
     &&y_min>=0
     &&y_max<=image[ui->line_find_raw_image->currentText().toInt()-1].height()){
        ROI_add(1,ui->line_find_x->text().toInt(),ui->line_find_y->text().toInt(),ui->line_find_width->text().toInt(),ui->line_find_height->text().toInt(),ui->line_find_a->text().toInt());
    }else{
        ROI_add(1,0,0,100,100,0);
        ui->line_find_x->setText("0");
        ui->line_find_y->setText("0");
        ui->line_find_height->setText("100");
        ui->line_find_width->setText("100");
        ui->line_find_a->setText("0");
    }
}

//圆查找
void VGRibbonWindow::on_Circle_find_general_clicked()
{
    ui->Circle_find_general->setEnabled(false);
    ui->Circle_find_setting->setCurrentIndex(0);
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->Circle_find_raw_image->currentText().toInt()-1]);
    n_image=image[ui->line_find_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(!image[ui->Circle_find_raw_image->currentText().toInt()-1].isNull()){
        ui->Circle_find_ROI->setEnabled(true);
        ui->Circle_find_preview->setEnabled(true);
        Circle_find_ROI_check();
    }else{
        ui->Circle_find_ROI->setEnabled(false);
        ui->Circle_find_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_Circle_find_ROI_clicked()
{
    ui->Circle_find_general->setEnabled(true);
    ui->Circle_find_ROI->setEnabled(false);
    ui->Circle_find_ROI_setting->show();
    Circle_find_ROI_check();
}

void VGRibbonWindow::on_Circle_find_preview_clicked()
{
    ui->Circle_find_general->setEnabled(true);
    ui->Circle_find_ROI->setEnabled(true);
    ui->Circle_find_setting->setCurrentIndex(2);
    QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
    YZVision::Basic2D::PointXY bounary[4];
    int x,y,height,width;
    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
    width=order_position.at(2).toInt();
    if(width==0)
        width=image[ui->Circle_find_raw_image->currentText().toInt()-1].width();
    height=order_position.at(3).toInt();
    if(height==0)
        height=image[ui->Circle_find_raw_image->currentText().toInt()-1].height();
    boundary_position(2,x,y,width,height,0);
    for(int j=0;j<3;j++){
        bounary[j]=boundary[j];
    }
    int resu;
    float c1,c2;
    c1=bounary[0].x-bounary[2].x;
    c2=bounary[0].x-bounary[1].x;
    QElapsedTimer  mstimer;
    mstimer.start();
    Mat raw=Image2cvMat(image[ui->Circle_find_raw_image->currentText().toInt()-1].toImage());
    YZVision::FindCircle_2D Circle_find;
    YZVision::FindCircle_2D::InputParam input= YZVision::FindCircle_2D::InputParam();
    YZVision::FindCircle_2D::OutputParam result= YZVision::FindCircle_2D::OutputParam();
    input.raw=raw;
    input.threshold_lower=ui->Circle_find_threshold_lower->text().toInt();
    input.threshold_upper=ui->Circle_find_threshold_upper->text().toInt();
    input.type=ui->Circle_find_type->currentIndex();
    input.border=ui->Circle_find_border->currentIndex();
    input.ratio=ui->Circle_find_ratio->text().toInt();
    input.radius_min=ui->Circle_find_radius_min->text().toInt();
    input.radius_max=ui->Circle_find_radius_max->text().toInt();
    input.circleCenter=bounary[0];
    input.innerRadius=c1;
    input.outerRadius=c2;

    resu=Circle_find.FindCircle(input,&result);
    image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* praw = new graphicsimageitem(image[c_row]);
    connect(praw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    n_image=image[c_row];
    scene->addItem(praw);
    ui->graphicsView->setScene(scene);
    if(result.code){
        ui->Circle_find_pass->setText("失败");
        ui->Circle_find_pass->setStyleSheet("color: rgb(170, 0, 0)");
        ui->Circle_find_c_point->setText("");
        ui->Circle_find_c_r->setText("");
        ui->Circle_find_c_point_2->setText("");
        ui->Circle_find_c_r_2->setText("");
    }else{
        ui->Circle_find_pass->setText("成功");
        ui->Circle_find_pass->setStyleSheet("color: rgb(0, 170, 0)");
        ui->Circle_find_c_point->setText("("+QString::number(result.circle1.x)+","+QString::number(result.circle1.y)+")");
        ui->Circle_find_c_r->setText(QString::number(result.circle1.r));
        std::vector<std::vector <float>> temp;
        std::vector <float> temp_cir1;
        temp_cir1.push_back(result.circle1.x);
        temp_cir1.push_back(result.circle1.y);
        temp_cir1.push_back(result.circle1.r);
        temp.push_back(temp_cir1);
        std::vector <float> temp_samplePts;
        for(long long z=0;z<result.samplePts.size();z++){
            temp_samplePts.push_back(result.samplePts[z].x());
            temp_samplePts.push_back(result.samplePts[z].y());
        }
        temp.push_back(temp_samplePts);
        if(ui->Circle_find_type->currentIndex()>3){
            ui->Circle_find_c_point_2->show();
            ui->Circle_find_c_r_2->show();
            ui->Circle_find_c_point_2->setText("("+QString::number(result.circle2.x)+","+QString::number(result.circle2.y)+")");
            ui->Circle_find_c_r_2->setText(QString::number(result.circle2.r));
            std::vector <float> temp_cir2;
            temp_cir2.push_back(result.circle2.x);
            temp_cir2.push_back(result.circle2.y);
            temp_cir2.push_back(result.circle2.r);
            temp.push_back(temp_cir2);
            std::vector <float> temp_samplePts2;
            for(long long z=0;z<result.samplePts2.size();z++){
                temp_samplePts2.push_back(result.samplePts2[z].x());
                temp_samplePts2.push_back(result.samplePts2[z].y());
            }
            temp.push_back(temp_samplePts2);
        }else{
            ui->Circle_find_c_point_2->setText("");
            ui->Circle_find_c_r_2->setText("");
            ui->Circle_find_c_point_2->close();
            ui->Circle_find_c_r_2->close();
        }
        res[c_row]=temp;
    }
}

void VGRibbonWindow::Circle_find_setting_changed()
{
    settingchanged();
    QString x,y,height,width;
    x=ui->Circle_find_x->text();
    y=ui->Circle_find_y->text();
    height=ui->Circle_find_height->text();
    width=ui->Circle_find_width->text();

    QTableWidgetItem *item = new QTableWidgetItem;
     item->setText("raw_image="+QString::number(ui->Circle_find_raw_image->currentText().toInt())+
                   ",threshold_lower="+ui->Circle_find_threshold_lower->text()+
                   ",threshold_upper="+ui->Circle_find_threshold_upper->text()+
                   ",type="+QString::number(ui->Circle_find_type->currentIndex())+
                   ",border="+QString::number(ui->Circle_find_border->currentIndex())+
                   ",ratio="+ui->Circle_find_ratio->text()+
                   ",radius_min="+ui->Circle_find_radius_min->text()+
                   ",radius_max="+ui->Circle_find_radius_max->text());
     ui->ordertable->setItem(c_row,4,item->clone());
     item->setText(x+","+y+","+width+","+height+",0");
     ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_Circle_find_raw_image_currentIndexChanged(int index)
{
    if(index>=0){
        QGraphicsScene *scene = new QGraphicsScene;
        graphicsimageitem* raw = new graphicsimageitem(image[ui->Circle_find_raw_image->currentText().toInt()-1]);
        n_image=image[ui->Circle_find_raw_image->currentText().toInt()-1];
        scene->addItem(raw);
        connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
        ui->graphicsView->setScene(scene);
        if(!image[ui->Circle_find_raw_image->currentText().toInt()-1].isNull()){
            ui->Circle_find_ROI->setEnabled(true);
            ui->Circle_find_preview->setEnabled(true);
            Circle_find_ROI_check();
        }else{
            ui->Circle_find_ROI->setEnabled(false);
            ui->Circle_find_preview->setEnabled(false);
        }
        Circle_find_setting_changed();
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(ui->Circle_find_raw_image->currentText().toInt()-1,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(ui->Circle_find_raw_image->currentText().toInt()-1,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(ui->Circle_find_raw_image->currentText().toInt()-1,7)->clone());
    }else{
        ui->Circle_find_ROI->setEnabled(false);
    }
}

void VGRibbonWindow::on_Circle_find_threshold_lower_editingFinished()
{
    if(ui->Circle_find_threshold_upper->text().toInt()<ui->Circle_find_threshold_lower->text().toInt()){
        ui->Circle_find_threshold_lower->setText(ui->Circle_find_threshold_upper->text());
        QMessageBox::warning(0, "警告","上阈值请大于下阈值");
    }
    if(ui->Circle_find_threshold_upper->text().toInt()>255){
        ui->Circle_find_threshold_lower->setText(ui->Circle_find_threshold_upper->text());
        QMessageBox::warning(0, "警告","阈限请在0~255范围内");
    }
    Circle_find_setting_changed();

}

void VGRibbonWindow::on_Circle_find_threshold_upper_editingFinished()
{
    if(ui->Circle_find_threshold_upper->text().toInt()<ui->Circle_find_threshold_lower->text().toInt()){
        ui->Circle_find_threshold_upper->setText(ui->Circle_find_threshold_lower->text());
        QMessageBox::warning(0, "警告","上阈值请大于下阈值");
    }
    if(ui->Circle_find_threshold_upper->text().toInt()>255){
        ui->Circle_find_threshold_upper->setText(ui->Circle_find_threshold_lower->text());
        QMessageBox::warning(0, "警告","阈限请在0~255范围内");
    }
    Circle_find_setting_changed();
}

void VGRibbonWindow::on_Circle_find_type_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    Circle_find_setting_changed();
}

void VGRibbonWindow::on_Circle_find_border_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    Circle_find_setting_changed();
}

void VGRibbonWindow::on_Circle_find_ratio_editingFinished()
{
    if(ui->Circle_find_ratio->text().toInt()>100){
        QMessageBox::warning(0, "警告","采样比率最大值为100");
        ui->Circle_find_ratio->setText("100");
    }
    if(ui->Circle_find_ratio->text().toInt()<1){
        QMessageBox::warning(0, "警告","采样比率最小值为1");
        ui->Circle_find_ratio->setText("1");
    }
    Circle_find_setting_changed();
}

void VGRibbonWindow::on_Circle_find_radius_min_returnPressed()
{
    if(ui->Circle_find_radius_min->text().toInt()>ui->Circle_find_radius_max->text().toInt()){
        ui->Circle_find_radius_min->setText(ui->Circle_find_radius_max->text());
        QMessageBox::warning(0, "警告","下限值请小于上限值");
    }
    Circle_find_setting_changed();
    on_Circle_find_preview_clicked();
}

void VGRibbonWindow::on_Circle_find_radius_max_returnPressed()
{
    if(ui->Circle_find_radius_min->text().toInt()>ui->Circle_find_radius_max->text().toInt()){
        ui->Circle_find_radius_min->setText(ui->Circle_find_radius_max->text());
        QMessageBox::warning(0, "警告","下限值请小于上限值");
    }
    Circle_find_setting_changed();
    on_Circle_find_preview_clicked();
}

void VGRibbonWindow::on_Circle_find_x_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Circle_find_setting_changed();
}

void VGRibbonWindow::on_Circle_find_y_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Circle_find_setting_changed();
}

void VGRibbonWindow::on_Circle_find_height_textChanged(const QString &arg1)
{
    if(arg1.toInt()>image[ui->Circle_find_raw_image->currentText().toInt()-1].height())
        ui->Circle_find_height->setText(QString::number(image[ui->Circle_find_raw_image->currentText().toInt()-1].height()));
    if(ui->Circle_find_height->text()=="0")
        ui->Circle_find_height->setText(QString::number(image[ui->Circle_find_raw_image->currentText().toInt()-1].height()));
    Circle_find_setting_changed();
}

void VGRibbonWindow::on_Circle_find_width_textChanged(const QString &arg1)
{
    if(arg1.toInt()>image[ui->Circle_find_raw_image->currentText().toInt()-1].width())
        ui->Circle_find_width->setText(QString::number(image[ui->Circle_find_raw_image->currentText().toInt()-1].width()));
    if(ui->Circle_find_width->text()=="0")
        ui->Circle_find_width->setText(QString::number(image[ui->Circle_find_raw_image->currentText().toInt()-1].width()));
    Circle_find_setting_changed();
}

void VGRibbonWindow::on_Circle_find_x_editingFinished()
{
    Circle_find_ROI_check();
}

void VGRibbonWindow::on_Circle_find_y_editingFinished()
{
    Circle_find_ROI_check();
}

void VGRibbonWindow::on_Circle_find_height_editingFinished()
{
    Circle_find_ROI_check();
}

void VGRibbonWindow::on_Circle_find_width_editingFinished()
{
    Circle_find_ROI_check();
}

void VGRibbonWindow::Circle_find_ROI_check()
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->Circle_find_raw_image->currentText().toInt()-1]);
    n_image=image[ui->Circle_find_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(ui->Circle_find_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()-ui->Circle_find_height->text().toDouble()/2>=0
     &&ui->Circle_find_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()+ui->Circle_find_height->text().toDouble()/2<=image[ui->Circle_find_raw_image->currentText().toInt()-1].width()
     &&ui->Circle_find_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()-ui->Circle_find_height->text().toDouble()/2>=0
     &&ui->Circle_find_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()+ui->Circle_find_height->text().toDouble()/2<=image[ui->Circle_find_raw_image->currentText().toInt()-1].height()){
        ROI_add(2,ui->Circle_find_x->text().toInt(),ui->Circle_find_y->text().toInt(),ui->Circle_find_width->text().toInt(),ui->Circle_find_height->text().toInt(),0);
    }else{
        ROI_add(2,100,100,100,200,0);
        ui->Circle_find_x->setText("100");
        ui->Circle_find_y->setText("100");
        ui->Circle_find_height->setText("200");
        ui->Circle_find_width->setText("100");
    }
}



//模板匹配
void VGRibbonWindow::on_Pattern_find_general_clicked()
{
    ui->Pattern_find_setting->setCurrentIndex(0);
    ui->Pattern_find_general->setEnabled(false);

    roi=1;

    if(!image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].isNull()){
        ui->Pattern_find_search_ROI->setEnabled(true);
        ui->Pattern_find_preview->setEnabled(true);
//        Pattern_find_ROI_2_check();
    }else{
        ui->Pattern_find_train_ROI->setEnabled(false);
        ui->Pattern_find_preview->setEnabled(false);
    }

    if(!image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].isNull()){
        ui->Pattern_find_train_ROI->setEnabled(true);
//        Pattern_find_ROI_check();
    }else{
        ui->Pattern_find_train_ROI->setEnabled(false);
        ui->Pattern_find_preview->setEnabled(false);
    }
    if(ui->Pattern_find_rotate->currentIndex()!=1){
        ui->Pattern_find_rotate_max->close();
        ui->Pattern_find_rotate_min->close();
        if(ui->Pattern_find_zoom->currentIndex()!=3){
            ui->Pattern_find_begin->close();
            ui->Pattern_find_end->close();
        }
    }else{
        ui->Pattern_find_rotate_max->show();
        ui->Pattern_find_rotate_min->show();
        ui->Pattern_find_begin->show();
        ui->Pattern_find_end->show();
    }
    if(ui->Pattern_find_zoom->currentIndex()!=3){
        ui->Pattern_find_zoom_max->close();
        ui->Pattern_find_zoom_min->close();
        if(ui->Pattern_find_rotate->currentIndex()!=1){
            ui->Pattern_find_begin->close();
            ui->Pattern_find_end->close();
        }
    }else{
        ui->Pattern_find_zoom_max->show();
        ui->Pattern_find_zoom_min->show();
        ui->Pattern_find_begin->show();
        ui->Pattern_find_end->show();
    }
}

void VGRibbonWindow::on_Pattern_find_train_ROI_clicked()
{
    roi=1;
    ui->Pattern_find_setting->setCurrentIndex(0);
    ui->Pattern_find_train_ROI_setting->show();
    ui->Pattern_find_train_ROI->setEnabled(false);
    ui->Pattern_find_general->setEnabled(true);
    if(!image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].isNull()){
        ui->Pattern_find_search_ROI->setEnabled(true);
    }
    if(ui->Pattern_find_ROI_width->text().toInt()==image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].width()
     &&ui->Pattern_find_ROI_height->text().toInt()==image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].height()
            &&ui->Pattern_find_ROI_width->text().toInt()==0
            &&ui->Pattern_find_ROI_height->text().toInt()==0){
        ui->Pattern_find_ROI_x->setText("1");
        ui->Pattern_find_ROI_y->setText("1");

        ui->Pattern_find_ROI_height->setText("100");
        ui->Pattern_find_ROI_width->setText("100");
        pattern_changed=true;
    }
    Pattern_find_ROI_check();
}

void VGRibbonWindow::on_Pattern_find_search_ROI_clicked()
{
    roi=3;
    ui->Pattern_find_setting->setCurrentIndex(0);
    ui->Pattern_find_search_ROI_setting->show();
    ui->Pattern_find_search_ROI->setEnabled(false);
    ui->Pattern_find_general->setEnabled(true);
    if(!image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].isNull()){
        ui->Pattern_find_train_ROI->setEnabled(true);
    }
    if(ui->Pattern_find_ROI_2_width->text().toInt()==image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].width()
     &&ui->Pattern_find_ROI_2_height->text().toInt()==image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].height()
            &&ui->Pattern_find_ROI_2_width->text().toInt()==0
            &&ui->Pattern_find_ROI_2_height->text().toInt()==0){
        ui->Pattern_find_ROI_2_x->setText("1");
        ui->Pattern_find_ROI_2_y->setText("1");
        ui->Pattern_find_ROI_2_height->setText("100");
        ui->Pattern_find_ROI_2_width->setText("100");
    }
    Pattern_find_ROI_2_check();
}

void VGRibbonWindow::on_Pattern_find_preview_clicked()
{
    ui->Pattern_find_setting->setCurrentIndex(3);
    ui->Pattern_find_general->setEnabled(true);
    ui->Pattern_find_train_ROI->setEnabled(true);
    ui->Pattern_find_search_ROI->setEnabled(true);
    QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
    int type1,type2;
    int number;
    if(ui->Pattern_find_all_number->isChecked())
        number=0;
    else
        number=ui->Pattern_find_max_number->text().toInt();
    if(ui->Pattern_find_ROI_type->currentIndex()==0)
        type1=1;
    else
        type1=2;
    if(ui->Pattern_find_ROI_2_type->currentIndex()==0)
        type2=1;
    else
        type2=2;
    YZVision::Basic2D::PointXY bounary[8];
    int x,y,height,width,a,x2,y2,height2,width2,a2;
    x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
    y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
    width=order_position.at(2).toInt();
    if(width==0)
        width=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].width();
    height=order_position.at(3).toInt();
    if(height==0)
        height=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].height();
    a=order_position.at(4).toInt();
    x2=order_position.at(5).toInt()+ui->ordertable->item(ui->Pattern_find_search_raw_image->currentText().toInt()-1,5)->text().toInt();
    y2=order_position.at(6).toInt()+ui->ordertable->item(ui->Pattern_find_search_raw_image->currentText().toInt()-1,6)->text().toInt();
    width2=order_position.at(7).toInt();
    if(width2==0)
        width2=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].width();
    height2=order_position.at(8).toInt();
    if(height2==0)
        height2=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].height();
    a2=order_position.at(9).toInt();
    boundary_position(type1,x,y,width,height,a);
    for(int j=0;j<4;j++){
        bounary[j]=boundary[j];
    }
    boundary_position(type2,x2,y2,width2,height2,a2);
    for(int j=0;j<4;j++){
        bounary[4+j]=boundary[j];
    }
    int resu;
    QElapsedTimer  mstimer;
    mstimer.start();
    Mat raw1=Image2cvMat(image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].toImage());
    Mat raw2=Image2cvMat(image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].toImage());
    YZVision::MatchTemplate_2D Pattern;
    YZVision::MatchTemplate_2D::InputParam input= YZVision::MatchTemplate_2D::InputParam();
    YZVision::MatchTemplate_2D::OutputParam result= YZVision::MatchTemplate_2D::OutputParam();
    input.train_changed=pattern_changed;
    input.train=raw1;
    input.search=raw2;
    input.rotate=ui->Pattern_find_rotate->currentIndex();
    input.rotate_min=ui->Pattern_find_rotate_min->text().toInt();
    input.rotate_max=ui->Pattern_find_rotate_max->text().toInt();
    input.zoom=ui->Pattern_find_zoom->currentIndex();
    input.zoom_min=ui->Pattern_find_zoom_min->text().toDouble();
    input.zoom_max=ui->Pattern_find_zoom_max->text().toInt();
    input.type=ui->Pattern_find_type->currentIndex();
    input.scores=ui->Pattern_find_min_search->text().toInt();
    input.number=number;
    input.type1=type1;
    input.type2=type2;
    for(int j=0;j<8;j++){
        input.position[j]=bounary[j];
    }
    resu=Pattern.MatchTemplate(input,&result);
    image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));
    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* praw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    connect(praw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    scene->addItem(praw);
    ui->graphicsView->setScene(scene);
    pattern_changed=false;
    if(result.code){
        ui->Pattern_find_pass_or_fail->setText("失败");
        ui->Pattern_find_pass_or_fail->setStyleSheet("color: rgb(170, 0, 0)");
        ui->pattern_find_preview_number->setText(QString::number(0));
        ui->Pattern_find_result->close();
    }else{
        ui->Pattern_find_pass_or_fail->setText("成功");
        ui->Pattern_find_pass_or_fail->setStyleSheet("color: rgb(0, 170, 0)");
        ui->pattern_find_preview_number->setText(QString::number(result.tems.size()));
        ui->Pattern_find_result->show();
        ui->Pattern_find_result->setRowCount(0);
        std::vector<std::vector <float>> temp;
        for(int i=0;i<result.tems.size();i++){
            ui->Pattern_find_result->setRowCount(i+1);
            QTableWidgetItem *info = new QTableWidgetItem;
            info->setText(QString::number(result.tems[i].x)+","+QString::number(result.tems[i].y));
            ui->Pattern_find_result->setItem(i,0,info->clone());
            info->setText(QString::number(result.tems[i].similarity));
            ui->Pattern_find_result->setItem(i,1,info->clone());
//            info->setText(QString::number(result.tems[i].w)+"X"+QString::number(result.tems[i].h));
//            ui->Pattern_find_result->setItem(i,2,info->clone());
            info->setText(QString::number(result.tems[i].angle));
            ui->Pattern_find_result->setItem(i,2,info->clone());
            info->setText(QString::number(result.tems[i].scale));
            ui->Pattern_find_result->setItem(i,3,info->clone());
            std::vector <float> temp_size;
            temp_size.push_back(result.tems[i].x);
            temp_size.push_back(result.tems[i].y);
            temp_size.push_back(result.tems[i].similarity);
            temp_size.push_back(result.tems[i].w);
            temp_size.push_back(result.tems[i].h);
            temp_size.push_back(result.tems[i].angle);
            temp_size.push_back(result.tems[i].scale);
            temp.push_back(temp_size);
            std::vector <float> features;
            for(long long z=0;z<result.tems[i].features.size();z++){
                features.push_back(result.tems[i].features[z].x);
                features.push_back(result.tems[i].features[z].y);
                features.push_back(result.tems[i].features[z].lbl);
            }
            temp.push_back(features);
        }
//        ui->Pattern_find_result->horizontalHeader()->setStretchLastSection(true);
        res[c_row]=temp;
        //设置表格列宽自适应
        ui->Pattern_find_result->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);
    }
}

void VGRibbonWindow::Pattern_find_setting_change()
{
    settingchanged();
    QString type,type_1,type_2;
    int number;
    if(ui->Pattern_find_all_number->isChecked())
        number=0;
    else
        number=ui->Pattern_find_max_number->text().toInt();
    if(ui->Pattern_find_ROI_type->currentIndex()==0)
        type_1="矩形";
    else
        type_1="圆形";
    if(ui->Pattern_find_ROI_2_type->currentIndex()==0)
        type_2="矩形";
    else
        type_2="圆形";
    QString height,width,height2,width2;
    if(ui->Pattern_find_ROI_width->text().toInt()==image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].width())
        width="0";
    else
        width=ui->Pattern_find_ROI_width->text();
    if(ui->Pattern_find_ROI_height->text().toInt()==image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].height())
        height="0";
    else
        height=ui->Pattern_find_ROI_height->text();
    if(ui->Pattern_find_ROI_2_width->text().toInt()==image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].width())
        width2="0";
    else
        width2=ui->Pattern_find_ROI_2_width->text();
    if(ui->Pattern_find_ROI_2_height->text().toInt()==image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].height())
        height2="0";
    else
        height2=ui->Pattern_find_ROI_2_height->text();
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_image_1="+ui->Pattern_find_train_raw_image->currentText()+
                  ",raw_image_2="+ui->Pattern_find_search_raw_image->currentText()+
                  ",rotate="+QString::number(ui->Pattern_find_rotate->currentIndex())+
                  ",rotate_min="+ui->Pattern_find_rotate_min->text()+
                  ",rotate_max="+ui->Pattern_find_rotate_max->text()+
                  ",zoom="+QString::number(ui->Pattern_find_zoom->currentIndex())+
                  ",zoom_min="+ui->Pattern_find_zoom_min->text()+
                  ",zoom_max="+ui->Pattern_find_zoom_max->text()+
                  ",type="+QString::number(ui->Pattern_find_type->currentIndex())+
                  ",search="+ui->Pattern_find_min_search->text()+
                  ",number="+QString::number(number));
    ui->ordertable->setItem(c_row,4,item->clone());
    item->setText(type_1+","+type_2);
    ui->ordertable->setItem(c_row,8,item->clone());
    item->setText(ui->Pattern_find_ROI_x->text()+","+ui->Pattern_find_ROI_y->text()+","+width+","+height+","+ui->Pattern_find_ROI_a->text()+","+
                  ui->Pattern_find_ROI_2_x->text()+","+ui->Pattern_find_ROI_2_y->text()+","+width2+","+height2+","+ui->Pattern_find_ROI_2_a->text());
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_Pattern_find_train_raw_image_currentIndexChanged(int index)
{
    if(index>=0){
            QGraphicsScene *scene = new QGraphicsScene;
            graphicsimageitem* raw = new graphicsimageitem(image[ui->Pattern_find_train_raw_image->currentText().toInt()-1]);
            n_image=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1];
            scene->addItem(raw);
            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
            ui->graphicsView->setScene(scene);
            if(!image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].isNull()){
                ui->Pattern_find_train_ROI->setEnabled(true);
                Pattern_find_ROI_check();
                if(!image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].isNull())
                    ui->Pattern_find_preview->setEnabled(true);
            }else{
                ui->Pattern_find_train_ROI->setEnabled(false);
                ui->Pattern_find_preview->setEnabled(false);
            }
            Pattern_find_setting_change();
            ui->ordertable->setItem(c_row,5,ui->ordertable->item(ui->Pattern_find_train_raw_image->currentText().toInt()-1,5)->clone());
            ui->ordertable->setItem(c_row,6,ui->ordertable->item(ui->Pattern_find_train_raw_image->currentText().toInt()-1,6)->clone());
            ui->ordertable->setItem(c_row,7,ui->ordertable->item(ui->Pattern_find_train_raw_image->currentText().toInt()-1,7)->clone());
            pattern_changed=true;
    }else{
            ui->blob_ROI->setEnabled(false);
    }
}


void VGRibbonWindow::on_Pattern_find_search_raw_image_currentIndexChanged(int index)
{
    if(index>=0){
            QGraphicsScene *scene = new QGraphicsScene;
            graphicsimageitem* raw = new graphicsimageitem(image[ui->Pattern_find_search_raw_image->currentText().toInt()-1]);
            n_image=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1];
            scene->addItem(raw);
            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
            ui->graphicsView->setScene(scene);
            if(!image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].isNull()){
                ui->Pattern_find_search_ROI->setEnabled(true);
                Pattern_find_ROI_2_check();
                if(!image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].isNull())
                    ui->Pattern_find_preview->setEnabled(true);
            }else{
                ui->Pattern_find_search_ROI->setEnabled(false);
                ui->Pattern_find_preview->setEnabled(false);
            }
            Pattern_find_setting_change();
    }else{
            ui->blob_ROI->setEnabled(false);
    }
}

void VGRibbonWindow::on_Pattern_find_rotate_currentIndexChanged(int index)
{
    if(index==0){
        ui->Pattern_find_rotate_max->close();
        ui->Pattern_find_rotate_min->close();
        ui->Pattern_find_rotate_max->setText("0");
        ui->Pattern_find_rotate_min->setText("0");
        if(ui->Pattern_find_zoom->currentIndex()!=3){
            ui->Pattern_find_begin->close();
            ui->Pattern_find_end->close();
        }
    }else if(index==3){
        ui->Pattern_find_rotate_max->close();
        ui->Pattern_find_rotate_min->close();
        ui->Pattern_find_rotate_max->setText("180");
        ui->Pattern_find_rotate_min->setText("-180");
        if(ui->Pattern_find_zoom->currentIndex()!=3){
            ui->Pattern_find_begin->close();
            ui->Pattern_find_end->close();
        }
    }else{
        ui->Pattern_find_rotate_max->show();
        ui->Pattern_find_rotate_min->show();
        ui->Pattern_find_begin->show();
        ui->Pattern_find_end->show();
    }
    Pattern_find_setting_change();
    pattern_changed=true;
}

void VGRibbonWindow::on_Pattern_find_rotate_min_editingFinished()
{
    if (ui->Pattern_find_rotate_min->text()=="-") {
        ui->Pattern_find_rotate_min->setText(ui->Pattern_find_rotate_max->text());
    }
    if(ui->Pattern_find_rotate_max->text().toInt()<ui->Pattern_find_rotate_min->text().toInt()){
        ui->Pattern_find_rotate_min->setText(ui->Pattern_find_rotate_max->text());
        QMessageBox::warning(0, "警告","请确保旋转最大值大于最小值");
    }
    if (ui->Pattern_find_rotate_min->text().toInt()<-180) {
        ui->Pattern_find_rotate_min->setText("-180");
        QMessageBox::warning(0, "警告","请确保旋转范围在-180°~180°内");
    }
    if (ui->Pattern_find_rotate_min->text().toInt()>180) {
        ui->Pattern_find_rotate_min->setText(ui->Pattern_find_rotate_max->text());
        QMessageBox::warning(0, "警告","请确保旋转范围在-180°~180°内");
    }
    Pattern_find_setting_change();
    pattern_changed=true;
}

void VGRibbonWindow::on_Pattern_find_rotate_max_editingFinished()
{
    if (ui->Pattern_find_rotate_max->text()=="-") {
        ui->Pattern_find_rotate_max->setText(ui->Pattern_find_rotate_min->text());
    }
    if(ui->Pattern_find_rotate_max->text().toInt()<ui->Pattern_find_rotate_min->text().toInt()){
        ui->Pattern_find_rotate_max->setText(ui->Pattern_find_rotate_min->text());
        QMessageBox::warning(0, "警告","请确保旋转最大值大于最小值");
    }
    if (ui->Pattern_find_rotate_max->text().toInt()<-180) {
        ui->Pattern_find_rotate_max->setText(ui->Pattern_find_rotate_min->text());
        QMessageBox::warning(0, "警告","请确保旋转范围在-180°~180°内");
    }
    if (ui->Pattern_find_rotate_max->text().toInt()>180) {
        ui->Pattern_find_rotate_max->setText("180");
        QMessageBox::warning(0, "警告","请确保旋转范围在-180°~180°内");
    }
    Pattern_find_setting_change();
    pattern_changed=true;
}

void VGRibbonWindow::on_Pattern_find_zoom_currentIndexChanged(int index)
{
    if(index==0){
        ui->Pattern_find_zoom_max->close();
        ui->Pattern_find_zoom_min->close();
        ui->Pattern_find_zoom_max->setText("0");
        ui->Pattern_find_zoom_min->setText("0");
        if(ui->Pattern_find_rotate->currentIndex()!=1||ui->Pattern_find_rotate->currentIndex()!=2){
            ui->Pattern_find_begin->close();
            ui->Pattern_find_end->close();
        }
    }else if(index==1){
        ui->Pattern_find_zoom_max->close();
        ui->Pattern_find_zoom_min->close();
        ui->Pattern_find_zoom_max->setText("1.1");
        ui->Pattern_find_zoom_min->setText("0.9");
        if(ui->Pattern_find_rotate->currentIndex()!=1||ui->Pattern_find_rotate->currentIndex()!=2){
            ui->Pattern_find_begin->close();
            ui->Pattern_find_end->close();
        }
    }else if(index==2){
        ui->Pattern_find_zoom_max->close();
        ui->Pattern_find_zoom_min->close();
        ui->Pattern_find_zoom_max->setText("2.0");
        ui->Pattern_find_zoom_min->setText("0.5");
        if(ui->Pattern_find_rotate->currentIndex()!=1||ui->Pattern_find_rotate->currentIndex()!=2){
            ui->Pattern_find_begin->close();
            ui->Pattern_find_end->close();
        }
    }else{
        ui->Pattern_find_zoom_max->show();
        ui->Pattern_find_zoom_min->show();
        ui->Pattern_find_begin->show();
        ui->Pattern_find_end->show();
    }
    Pattern_find_setting_change();
    pattern_changed=true;
}

void VGRibbonWindow::on_Pattern_find_zoom_min_editingFinished()
{
    if(ui->Pattern_find_zoom_max->text().toDouble()<ui->Pattern_find_zoom_min->text().toDouble()){
        ui->Pattern_find_zoom_min->setText(ui->Pattern_find_zoom_max->text());
        QMessageBox::warning(0, "警告","请确保缩放最大值大于最小值");
    }
    if(ui->Pattern_find_zoom_min->text().toDouble()<0){
        ui->Pattern_find_zoom_min->setText("0.1");
        QMessageBox::warning(0, "警告","请确保缩放比例大于0");
    }
    Pattern_find_setting_change();
    pattern_changed=true;
}


void VGRibbonWindow::on_Pattern_find_zoom_max_editingFinished()
{
    if(ui->Pattern_find_zoom_max->text().toDouble()<ui->Pattern_find_zoom_min->text().toDouble()){
        ui->Pattern_find_zoom_max->setText(ui->Pattern_find_zoom_min->text());
        QMessageBox::warning(0, "警告","请确保缩放最大值大于最小值");
    }
    if(ui->Pattern_find_zoom_min->text().toDouble()>3){
        ui->Pattern_find_zoom_min->setText("3");
        QMessageBox::warning(0, "警告","请确保缩放比例小于3");
    }
    Pattern_find_setting_change();
    pattern_changed=true;
}


void VGRibbonWindow::on_Pattern_find_type_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_x_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_y_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_height_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_width_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_a_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_a_editingFinished()
{
    pattern_changed=true;
    Pattern_find_ROI_check();
}


void VGRibbonWindow::on_Pattern_find_ROI_x_editingFinished()
{
    pattern_changed=true;
    Pattern_find_ROI_check();
}


void VGRibbonWindow::on_Pattern_find_ROI_y_editingFinished()
{
    pattern_changed=true;
    Pattern_find_ROI_check();
}


void VGRibbonWindow::on_Pattern_find_ROI_height_editingFinished()
{
    pattern_changed=true;
    Pattern_find_ROI_check();
}


void VGRibbonWindow::on_Pattern_find_ROI_width_editingFinished()
{
    pattern_changed=true;
    Pattern_find_ROI_check();
}

void VGRibbonWindow::on_Pattern_find_ROI_type_currentIndexChanged(int index)
{
    if(index==0){
        ui->Pattern_find_ROI_a_l->show();
        ui->Pattern_find_ROI_a->show();
        ui->Pattern_find_ROI_w_l->show();
        ui->Pattern_find_ROI_width->setText(ui->Pattern_find_ROI_height->text());
        ui->Pattern_find_ROI_width->show();
        ui->Pattern_find_ROI_h_l->setText("高");
        ui->Pattern_find_ROI_x->setText(QString::number(ui->Pattern_find_ROI_x->text().toInt()-ui->Pattern_find_ROI_height->text().toInt()/2));
        ui->Pattern_find_ROI_y->setText(QString::number(ui->Pattern_find_ROI_y->text().toInt()-ui->Pattern_find_ROI_height->text().toInt()/2));
    }else{
        ui->Pattern_find_ROI_a_l->close();
        ui->Pattern_find_ROI_a->close();
        ui->Pattern_find_ROI_w_l->close();
        ui->Pattern_find_ROI_width->setText("1");
        ui->Pattern_find_ROI_width->close();
        ui->Pattern_find_ROI_x->setText(QString::number(ui->Pattern_find_ROI_x->text().toInt()+ui->Pattern_find_ROI_height->text().toInt()/2));
        ui->Pattern_find_ROI_y->setText(QString::number(ui->Pattern_find_ROI_y->text().toInt()+ui->Pattern_find_ROI_height->text().toInt()/2));
        //ui->Pattern_find_ROI_height->setText(QString::number(ui->Pattern_find_ROI_height->text().toInt()/2));
        ui->Pattern_find_ROI_h_l->setText("直径");
    }
    Pattern_find_setting_change();
    Pattern_find_ROI_check();
    pattern_changed=true;
}


void VGRibbonWindow::on_Pattern_find_ROI_cancel_clicked()
{
    on_Pattern_find_general_clicked();
    ui->Pattern_find_train_ROI_setting->close();
    ui->Pattern_find_ROI_x->setText("0");
    ui->Pattern_find_ROI_y->setText("0");
    ui->Pattern_find_ROI_width->setText("0");
    ui->Pattern_find_ROI_height->setText("0");
    ui->Pattern_find_ROI_a->setText("0");
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->Pattern_find_train_raw_image->currentText().toInt()-1]);
    n_image=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    pattern_changed=true;
}

void VGRibbonWindow::Pattern_find_ROI_check()
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->Pattern_find_train_raw_image->currentText().toInt()-1]);
    n_image=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(ui->Pattern_find_ROI_type->currentIndex()==0){
        QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
        int x,y,height,width,rotate;
        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
        width=order_position.at(2).toInt();
        if(width==0)
            width=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].width();
        height=order_position.at(3).toInt();
        if(height==0)
            height=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].height();
        if(width==image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].width()&&height==image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].height())
            return;
        rotate=order_position.at(4).toInt();
        boundary_position(1,x,y,width,height,rotate);
        qreal y_max,y_min,x_max,x_min;
        y_max=y_min=boundary[0].y;
        x_max=x_min=boundary[0].x;
        for(int j=1;j<4;j++){
            if(boundary[j].x>x_max)
                x_max=boundary[j].x;
            else if(boundary[j].x<x_min)
                x_min=boundary[j].x;
            if(boundary[j].y>y_max)
                y_max=boundary[j].y;
            else if(boundary[j].y<y_min)
                y_min=boundary[j].y;
        }

        if(x_min>=0
         &&x_max<=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].width()
         &&y_min>=0
         &&y_max<=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].height()){
            ROI_add(1,ui->Pattern_find_ROI_x->text().toInt(),ui->Pattern_find_ROI_y->text().toInt(),ui->Pattern_find_ROI_width->text().toInt(),ui->Pattern_find_ROI_height->text().toInt(),ui->Pattern_find_ROI_a->text().toInt());
        }else{
            ROI_add(1,0,0,100,100,0);
            ui->Pattern_find_ROI_x->setText("0");
            ui->Pattern_find_ROI_y->setText("0");
            ui->Pattern_find_ROI_height->setText("100");
            ui->Pattern_find_ROI_width->setText("100");
            ui->Pattern_find_ROI_a->setText("0");
        }
    }else{
        if(ui->Pattern_find_ROI_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()-ui->Pattern_find_ROI_height->text().toDouble()/2>=0
         &&ui->Pattern_find_ROI_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()+ui->Pattern_find_ROI_height->text().toDouble()/2<=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].width()
         &&ui->Pattern_find_ROI_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()-ui->Pattern_find_ROI_height->text().toDouble()/2>=0
         &&ui->Pattern_find_ROI_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()+ui->Pattern_find_ROI_height->text().toDouble()/2<=image[ui->Pattern_find_train_raw_image->currentText().toInt()-1].height()){
            ROI_add(2,ui->Pattern_find_ROI_x->text().toInt(),ui->Pattern_find_ROI_y->text().toInt(),ui->Pattern_find_ROI_width->text().toInt(),ui->Pattern_find_ROI_height->text().toInt(),0);
        }else{
            ROI_add(2,100,100,1,200,0);
            ui->Pattern_find_ROI_x->setText("100");
            ui->Pattern_find_ROI_y->setText("100");
            ui->Pattern_find_ROI_height->setText("200");
            ui->Pattern_find_ROI_width->setText("1");
        }
    }
}

void VGRibbonWindow::on_Pattern_find_ROI_2_x_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_2_y_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_2_height_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_2_width_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_2_a_textChanged(const QString &arg1)
{
    Q_UNUSED(arg1);
    Pattern_find_setting_change();
}


void VGRibbonWindow::on_Pattern_find_ROI_2_a_editingFinished()
{
    Pattern_find_ROI_2_check();
}


void VGRibbonWindow::on_Pattern_find_ROI_2_x_editingFinished()
{
    Pattern_find_ROI_2_check();
}


void VGRibbonWindow::on_Pattern_find_ROI_2_y_editingFinished()
{
    Pattern_find_ROI_2_check();
}


void VGRibbonWindow::on_Pattern_find_ROI_2_height_editingFinished()
{
    Pattern_find_ROI_2_check();
}


void VGRibbonWindow::on_Pattern_find_ROI_2_width_editingFinished()
{
    Pattern_find_ROI_2_check();
}

void VGRibbonWindow::on_Pattern_find_ROI_2_cancel_clicked()
{
    on_Pattern_find_general_clicked();
    ui->Pattern_find_search_ROI_setting->close();
    ui->Pattern_find_ROI_2_x->setText("0");
    ui->Pattern_find_ROI_2_y->setText("0");
    ui->Pattern_find_ROI_2_width->setText("0");
    ui->Pattern_find_ROI_2_height->setText("0");
    ui->Pattern_find_ROI_2_a->setText("0");
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->Pattern_find_search_raw_image->currentText().toInt()-1]);
    n_image=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}

void VGRibbonWindow::on_Pattern_find_ROI_2_type_currentIndexChanged(int index)
{
    if(index==0){
        ui->Pattern_find_ROI_2_a_l->show();
        ui->Pattern_find_ROI_2_a->show();
        ui->Pattern_find_ROI_2_w_l->show();
        ui->Pattern_find_ROI_2_width->setText(ui->Pattern_find_ROI_2_height->text());
        ui->Pattern_find_ROI_2_width->show();
        ui->Pattern_find_ROI_2_h_l->setText("高");
        ui->Pattern_find_ROI_2_x->setText(QString::number(ui->Pattern_find_ROI_2_x->text().toInt()-ui->Pattern_find_ROI_2_height->text().toInt()/2));
        ui->Pattern_find_ROI_2_y->setText(QString::number(ui->Pattern_find_ROI_2_y->text().toInt()-ui->Pattern_find_ROI_2_height->text().toInt()/2));
    }else{
        ui->Pattern_find_ROI_2_a_l->close();
        ui->Pattern_find_ROI_2_a->close();
        ui->Pattern_find_ROI_2_w_l->close();
        ui->Pattern_find_ROI_2_width->setText("1");
        ui->Pattern_find_ROI_2_width->close();
        ui->Pattern_find_ROI_2_x->setText(QString::number(ui->Pattern_find_ROI_2_x->text().toInt()+ui->Pattern_find_ROI_2_height->text().toInt()/2));
        ui->Pattern_find_ROI_2_y->setText(QString::number(ui->Pattern_find_ROI_2_y->text().toInt()+ui->Pattern_find_ROI_2_height->text().toInt()/2));
        //ui->Pattern_find_ROI_2_height->setText(QString::number(ui->Pattern_find_ROI_2_height->text().toInt()/2));
        ui->Pattern_find_ROI_2_h_l->setText("直径");
    }
    Pattern_find_setting_change();
    Pattern_find_ROI_2_check();
}

void VGRibbonWindow::Pattern_find_ROI_2_check()
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->Pattern_find_search_raw_image->currentText().toInt()-1]);
    n_image=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
    if(ui->Pattern_find_ROI_2_type->currentIndex()==0){
        QStringList order_position=ui->ordertable->item(c_row,9)->text().split(",");
        int x,y,height,width,rotate;
        x=order_position.at(0).toInt()+ui->ordertable->item(c_row,5)->text().toDouble();
        y=order_position.at(1).toInt()+ui->ordertable->item(c_row,6)->text().toDouble();
        width=order_position.at(2).toInt();
        if(width==0)
            width=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].width();
        height=order_position.at(3).toInt();
        if(height==0)
            height=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].height();
        if(width==image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].width()&&height==image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].height())
            return;
        rotate=order_position.at(4).toInt();
        boundary_position(1,x,y,width,height,rotate);
        qreal y_max,y_min,x_max,x_min;
        y_max=y_min=boundary[0].y;
        x_max=x_min=boundary[0].x;
        for(int j=1;j<4;j++){
            if(boundary[j].x>x_max)
                x_max=boundary[j].x;
            else if(boundary[j].x<x_min)
                x_min=boundary[j].x;
            if(boundary[j].y>y_max)
                y_max=boundary[j].y;
            else if(boundary[j].y<y_min)
                y_min=boundary[j].y;
        }

        if(x_min>=0
         &&x_max<=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].width()
         &&y_min>=0
         &&y_max<=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].height()){
            ROI_add(1,ui->Pattern_find_ROI_2_x->text().toInt(),ui->Pattern_find_ROI_2_y->text().toInt(),ui->Pattern_find_ROI_2_width->text().toInt(),ui->Pattern_find_ROI_2_height->text().toInt(),ui->Pattern_find_ROI_2_a->text().toInt());
        }else{
            ROI_add(1,0,0,100,100,0);
            ui->Pattern_find_ROI_2_x->setText("0");
            ui->Pattern_find_ROI_2_y->setText("0");
            ui->Pattern_find_ROI_2_height->setText("100");
            ui->Pattern_find_ROI_2_width->setText("100");
            ui->Pattern_find_ROI_2_a->setText("0");
        }
    }else{
        if(ui->Pattern_find_ROI_2_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()-ui->Pattern_find_ROI_2_height->text().toDouble()/2>=0
         &&ui->Pattern_find_ROI_2_x->text().toDouble()+ui->ordertable->item(c_row,5)->text().toDouble()+ui->Pattern_find_ROI_2_height->text().toDouble()/2<=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].width()
         &&ui->Pattern_find_ROI_2_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()-ui->Pattern_find_ROI_2_height->text().toDouble()/2>=0
         &&ui->Pattern_find_ROI_2_y->text().toDouble()+ui->ordertable->item(c_row,6)->text().toDouble()+ui->Pattern_find_ROI_2_height->text().toDouble()/2<=image[ui->Pattern_find_search_raw_image->currentText().toInt()-1].height()){
            ROI_add(2,ui->Pattern_find_ROI_2_x->text().toInt(),ui->Pattern_find_ROI_2_y->text().toInt(),ui->Pattern_find_ROI_2_width->text().toInt(),ui->Pattern_find_ROI_2_height->text().toInt(),0);
        }else{
            ROI_add(2,100,100,100,200,0);
            ui->Pattern_find_ROI_2_x->setText("100");
            ui->Pattern_find_ROI_2_y->setText("100");
            ui->Pattern_find_ROI_2_height->setText("200");
            ui->Pattern_find_ROI_2_width->setText("100");
        }
    }
}

void VGRibbonWindow::on_Pattern_find_min_search_editingFinished()
{
    if(ui->Pattern_find_min_search->text().toInt()<=0||ui->Pattern_find_min_search->text().toInt()>100){
        ui->Pattern_find_min_search->setText("1");
        QMessageBox::warning(0, "警告","请确保搜索得分在1~100范围内");
    }
    Pattern_find_setting_change();
    on_Pattern_find_preview_clicked();
}


void VGRibbonWindow::on_Pattern_find_max_number_editingFinished()
{
    if(ui->Pattern_find_max_number->text().toInt()<=0){
        ui->Pattern_find_min_search->setText("1");
        QMessageBox::warning(0, "警告","请确保最大搜索数量大于0");
    }
    Pattern_find_setting_change();
    on_Pattern_find_preview_clicked();
}


void VGRibbonWindow::on_Pattern_find_all_number_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    if(ui->Pattern_find_all_number->isChecked())
        ui->Pattern_find_max_number->setEnabled(false);
    else
        ui->Pattern_find_max_number->setEnabled(true);
    Pattern_find_setting_change();
    on_Pattern_find_preview_clicked();
}

//测距
void VGRibbonWindow::on_length_General_clicked()
{
    ui->length_setting->setCurrentIndex(0);
    int raw_image=ui->length_raw_image->currentText().toInt()-1;
    int raw_image_2=ui->length_raw_image_2->currentText().toInt()-1;
    if(!image[raw_image].isNull()&&!image[raw_image_2].isNull()){
        if(ui->ordertable->item(raw_image,3)->text()=="圆查找"&&
                ui->ordertable->item(raw_image_2,3)->text()=="圆查找")
            ui->length_preview->setEnabled(true);
        else
            ui->length_preview->setEnabled(false);
    }else{
        ui->length_preview->setEnabled(false);
    }
    length_redraw();
}

void VGRibbonWindow::on_length_preview_clicked()
{
    YZVision::Basic2D::PointXY start,end;
    int raw_image=ui->length_raw_image->currentText().toInt()-1;
    int raw_image_2=ui->length_raw_image_2->currentText().toInt()-1;
    ui->length_setting->setCurrentIndex(1);
    start.x=res[raw_image][0][0];
    start.y=res[raw_image][0][1];
    end.x=res[raw_image_2][0][0];
    end.y=res[raw_image_2][0][1];
    int resu;
    QElapsedTimer  mstimer;
    mstimer.start();
    Mat raw=Image2cvMat(image[ui->length_raw_image->currentText().toInt()-1].toImage());
    YZVision::CalcDistance_2D length;
    YZVision::CalcDistance_2D::InputParam input= YZVision::CalcDistance_2D::InputParam();
    YZVision::CalcDistance_2D::OutputParam result= YZVision::CalcDistance_2D::OutputParam();
    input.raw=raw;
    input.startpoint=start;
    input.endpoint=end;
    resu=length.calc_distance(input,&result);
    image[c_row]=QPixmap::fromImage(cvMat2Image(result.res));
    ui->length_result->setText(QString::number(result.l));
    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* praw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    scene->addItem(praw);
    connect(praw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}

void VGRibbonWindow::length_setting_change()
{
    settingchanged();
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_image="+QString::number(ui->length_raw_image->currentText().toInt())+","+
                  "raw_image_2="+QString::number(ui->length_raw_image_2->currentText().toInt()));
    ui->ordertable->setItem(c_row,4,item->clone());
    ui->ordertable->setItem(c_row,5,ui->ordertable->item(ui->length_raw_image->currentText().toInt()-1,5)->clone());
    ui->ordertable->setItem(c_row,6,ui->ordertable->item(ui->length_raw_image->currentText().toInt()-1,6)->clone());
}

void VGRibbonWindow::on_length_raw_image_currentIndexChanged(int index)
{
    if(index>=0){
        QGraphicsScene *scene = new QGraphicsScene;
        graphicsimageitem* raw = new graphicsimageitem(image[ui->length_raw_image->currentText().toInt()-1]);
        n_image=image[ui->length_raw_image->currentText().toInt()-1];
        scene->addItem(raw);
        connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
        ui->graphicsView->setScene(scene);
        length_setting_change();
        on_length_General_clicked();
    }
}

void VGRibbonWindow::on_length_raw_image_2_currentIndexChanged(int index)
{
    if(index>=0){
        length_setting_change();
        on_length_General_clicked();
    }
}

void VGRibbonWindow::length_redraw()
{
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->length_raw_image->currentText().toInt()-1]);
    n_image=image[ui->length_raw_image->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}

//面积计算
void VGRibbonWindow::on_area_General_clicked()
{
    ui->area_setting->setCurrentIndex(0);
    if(!image[ui->area_raw_image->currentText().toInt()-1].isNull()){
        if(ui->ordertable->item(ui->area_raw_image->currentText().toInt()-1,3)->text()=="斑点查找"){
            ui->area_preview->setEnabled(true);
            ui->area_blob->setEnabled(true);
        }else{
            ui->area_preview->setEnabled(false);
            ui->area_blob->setEnabled(false);
        }
    }else{
        ui->area_preview->setEnabled(false);
        ui->area_blob->setEnabled(false);
    }
}

void VGRibbonWindow::on_area_preview_clicked()
{
    YZVision::Pts blob;
    ui->area_setting->setCurrentIndex(1);
    int raw_image=ui->area_raw_image->currentText().toInt()-1;
    int raw_blob=ui->area_blob->currentIndex();
    for(long long z=0;z<res[raw_image][raw_blob*2+1].size()/2;z++){
        YZVision::pt a(res[raw_image][raw_blob*2+1][z*2],res[raw_image][raw_blob*2+1][z*2+1]);
        blob.push_back(a);
    }
    int resu;
    YZVision::CalcArea_2D area;
    YZVision::CalcArea_2D::InputParam input= YZVision::CalcArea_2D::InputParam();
    YZVision::CalcArea_2D::OutputParam output= YZVision::CalcArea_2D::OutputParam();
    input.contour=blob;
    resu=area.calc_area(input,&output);
    double result=output.area;
    ui->area_result->setText(QString::number(result));
}

void VGRibbonWindow::area_setting_change()
{
    settingchanged();
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_image="+QString::number(ui->area_raw_image->currentText().toInt())+","+
                  "blob="+QString::number(ui->area_blob->currentIndex()));
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_area_raw_image_currentIndexChanged(int index)
{
    if(index>=0){
        QGraphicsScene *scene = new QGraphicsScene;
        int raw_image=ui->area_raw_image->currentText().toInt()-1;
        graphicsimageitem* raw = new graphicsimageitem(image[ui->area_raw_image->currentText().toInt()-1]);
        n_image=image[ui->area_raw_image->currentText().toInt()-1];
        scene->addItem(raw);
        connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
        ui->graphicsView->setScene(scene);
        if(!image[raw_image].isNull()){
            ui->area_blob->clear();
            ui->graphicsView->setScene(scene);
            for(int i=1;i<=res[raw_image].size()/2;i++){
                ui->area_blob->addItem(QString::number(i));
            }
            ui->area_blob->setCurrentIndex(0);
            if(ui->ordertable->item(raw_image,3)->text()=="斑点查找"){
                ui->area_preview->setEnabled(true);
                ui->area_blob->setEnabled(true);
            }else{
                ui->area_blob->setEnabled(false);
                ui->area_preview->setEnabled(false);
            }
        }else{
            ui->area_blob->setEnabled(false);
            ui->area_preview->setEnabled(false);
        }
        area_setting_change();
    }
}

void VGRibbonWindow::on_area_blob_currentIndexChanged(int index)
{
    if(index>=0){
        area_setting_change();
    }
}

//图片拼接
void VGRibbonWindow::on_image_Splicing_general_clicked()
{
    if(!(image[ui->image_Splicing_raw->currentText().toInt()-1].isNull()||
         image[ui->image_Splicing_raw_2->currentText().toInt()-1].isNull())){
        ui->image_Splicing_preview->setEnabled(true);
    }else{
        ui->image_Splicing_preview->setEnabled(false);
    }
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[ui->image_Splicing_raw->currentText().toInt()-1]);
    n_image=image[ui->image_Splicing_raw->currentText().toInt()-1];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}

void VGRibbonWindow::on_image_Splicing_preview_clicked()
{
    int r1,r2;
    bool black=ui->image_Splicing_black->isChecked();
    r1=ui->image_Splicing_raw->currentText().toInt()-1;
    r2=ui->image_Splicing_raw_2->currentText().toInt()-1;
    Mat raw1,raw2;
    raw1=Image2cvMat(image[r1].toImage());
    raw2=Image2cvMat(image[r2].toImage());
    int upper,lower;
    upper=ui->image_Splicing_upper_threshold->text().toInt();
    lower=ui->image_Splicing_lower_threshold->text().toInt();
    int number=ui->image_Splicing_number->text().toInt();
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();
    YZVision::Imagesplicing_2D Imagesplicing;
    YZVision::Imagesplicing_2D::InputParam input= YZVision::Imagesplicing_2D::InputParam();
    YZVision::Imagesplicing_2D::OutputParam output= YZVision::Imagesplicing_2D::OutputParam();
    input.srcImage1=raw1;
    input.srcImage2=raw2;
    input.min_0=number;
    input.x_0=black;
    input.down=lower;
    input.up=upper;
    result =Imagesplicing.imagesplicing(input,&output);
    image[c_row]=QPixmap::fromImage(cvMat2Image(output.outImage));

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);

    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    scene->addItem(raw);
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    ui->graphicsView->setScene(scene);
}

void VGRibbonWindow::image_Splicing_setting_change()
{
    QString black;
    if(ui->image_Splicing_black->isChecked())
        black="1";
    else
        black="0";
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw="+ui->image_Splicing_raw->currentText()+","+
                  "raw_2="+ui->image_Splicing_raw_2->currentText()+","+
                  "upper_threshold="+ui->image_Splicing_upper_threshold->text()+","+
                  "lower_threshold="+ui->image_Splicing_lower_threshold->text()+","+
                  "black="+black+","+
                  "number="+ui->image_Splicing_number->text());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_image_Splicing_raw_2_currentIndexChanged(int index)
{
    if(index>=0){
            QGraphicsScene *scene = new QGraphicsScene;
            graphicsimageitem* raw = new graphicsimageitem(image[ui->image_Splicing_raw_2->currentText().toInt()-1]);
            n_image=image[ui->image_Splicing_raw_2->currentText().toInt()-1];
            scene->addItem(raw);
            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
            ui->graphicsView->setScene(scene);
            if(!(image[ui->image_Splicing_raw->currentText().toInt()-1].isNull()||
                 image[ui->image_Splicing_raw_2->currentText().toInt()-1].isNull())){
                ui->image_Splicing_preview->setEnabled(true);
            }else{
                ui->image_Splicing_preview->setEnabled(false);
            }
            image_Splicing_setting_change();
    }
}

void VGRibbonWindow::on_image_Splicing_raw_currentIndexChanged(int index)
{
    if(index>=0){
            QGraphicsScene *scene = new QGraphicsScene;
            graphicsimageitem* raw = new graphicsimageitem(image[ui->image_Splicing_raw->currentText().toInt()-1]);
            n_image=image[ui->image_Splicing_raw->currentText().toInt()-1];
            scene->addItem(raw);
            connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
            ui->graphicsView->setScene(scene);
            if(!(image[ui->image_Splicing_raw->currentText().toInt()-1].isNull()||
                 image[ui->image_Splicing_raw_2->currentText().toInt()-1].isNull())){
                ui->image_Splicing_preview->setEnabled(true);
            }else{
                ui->image_Splicing_preview->setEnabled(false);
            }
            image_Splicing_setting_change();
    }
}

void VGRibbonWindow::on_image_Splicing_upper_threshold_editingFinished()
{
    if(ui->image_Splicing_upper_threshold->text().toInt()>255){
        ui->image_Splicing_upper_threshold->setText("255");
        QMessageBox::warning(0, "警告","阈限请在0~255范围内");
    }
    if(ui->image_Splicing_upper_threshold->text().toInt()<ui->image_Splicing_lower_threshold->text().toInt()){
        ui->image_Splicing_upper_threshold->setText(ui->image_Splicing_lower_threshold->text());
        QMessageBox::warning(0, "警告","上阈限请大于下阈限");
    }
    image_Splicing_setting_change();
}

void VGRibbonWindow::on_image_Splicing_lower_threshold_editingFinished()
{
    if(ui->image_Splicing_lower_threshold->text().toInt()>255){
        ui->image_Splicing_lower_threshold->setText("255");
        QMessageBox::warning(0, "警告","阈限请在0~255范围内");
        return;
    }
    if(ui->image_Splicing_upper_threshold->text().toInt()<ui->image_Splicing_lower_threshold->text().toInt()){
        ui->image_Splicing_lower_threshold->setText(ui->image_Splicing_upper_threshold->text());
        QMessageBox::warning(0, "警告","下阈限请小于上阈限");
        return;
    }
    image_Splicing_setting_change();
}

void VGRibbonWindow::on_image_Splicing_black_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    image_Splicing_setting_change();
}

void VGRibbonWindow::on_image_Splicing_number_editingFinished()
{
    image_Splicing_setting_change();
}

//选择点云
void VGRibbonWindow::opencloud()
{
    qvtkWidget->deleteLater();
    qvtkWidget = new QVTKWidget(ui->cameraWidget);
    renderer = vtkSmartPointer<vtkRenderer>::New();
    renderWindow = vtkSmartPointer<vtkRenderWindow>::New();
    polyData = vtkSmartPointer<vtkPolyData>::New();
    pointMapper = vtkSmartPointer<vtkPolyDataMapper>::New();
    pointActor = vtkSmartPointer<vtkActor>::New();
    axesActor = vtkSmartPointer<vtkAxesActor>::New();
    widgetAxes = vtkSmartPointer<vtkOrientationMarkerWidget>::New();
    //渲染
    elevationFilter=vtkSmartPointer<vtkElevationFilter>::New();
    // Add points and vertices to polyData
    polyData->SetPoints(points);
    polyData->SetVerts(vertices);
    //pointMapper->SetInputData(polyData);
    elevationFilter->SetInputData(polyData);
    elevationFilter->SetLowPoint(0,0,z_min);
    elevationFilter->SetHighPoint(0,0,z_max);
    pointMapper->SetInputConnection(elevationFilter->GetOutputPort());
    pointMapper->Update();
    // Add pointMapper to pointActor & set properties
    pointActor->SetMapper(pointMapper);
    pointActor->GetProperty()->SetColor(1.0,1.0,1.0);
    pointActor->GetProperty()->SetPointSize(1);
    pointActor->GetProperty()->SetAmbient(0.5);
    pointActor->GetProperty()->SetRepresentationToPoints();
    // Add pointActor to renderer and set properties
    renderer->AddActor(pointActor);
    renderer->SetBackground(0,0,0);
    renderer->ResetCamera();
    renderer->UpdateLightsGeometryToFollowCamera();
    // set qvtkWidget's interactor to renderWindowInteractor
    renderWindowInteractor = this->qvtkWidget->GetRenderWindow()->GetInteractor();
    // set qvtkWidget's renderWindow to renderWindowInteractor
    renderWindowInteractor->SetRenderWindow(this->qvtkWidget->GetRenderWindow());
    // set qvtkWidget's render
    this->qvtkWidget->GetRenderWindow()->AddRenderer(renderer);
    ui->cameraWidget->setWidget(qvtkWidget);
    // Add axes to qvtkWidget
    widgetAxes->SetOrientationMarker(axesActor);
    widgetAxes->SetInteractor(this->qvtkWidget->GetRenderWindow()->GetInteractor());
    widgetAxes->SetEnabled(1);
    widgetAxes->SetInteractive(0);

    ROI_add_3D(0,0,0,0,0,0);
}

void VGRibbonWindow::openrawcloud(YZVision::vPointsXYZ pts)
{
    qvtkWidget->deleteLater();
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    for(unsigned long long z=0;z<pts.size();z++ ){
        points->InsertPoint(z,pts[z].x,pts[z].y,pts[z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
    }
    qvtkWidget = new QVTKWidget(ui->cameraWidget);
    renderer = vtkSmartPointer<vtkRenderer>::New();
    renderWindow = vtkSmartPointer<vtkRenderWindow>::New();
    polyData = vtkSmartPointer<vtkPolyData>::New();
    pointMapper = vtkSmartPointer<vtkPolyDataMapper>::New();
    pointActor = vtkSmartPointer<vtkActor>::New();
    axesActor = vtkSmartPointer<vtkAxesActor>::New();
    widgetAxes = vtkSmartPointer<vtkOrientationMarkerWidget>::New();
    //渲染
    polyData->SetPoints(points);
    polyData->SetVerts(vertices);
    pointMapper->SetInputData(polyData);
    pointMapper->Update();
    // Add pointMapper to pointActor & set properties
    pointActor->SetMapper(pointMapper);
    pointActor->GetProperty()->SetColor(1.0,1.0,1.0);
    pointActor->GetProperty()->SetPointSize(1);
    pointActor->GetProperty()->SetAmbient(0.5);
    pointActor->GetProperty()->SetRepresentationToPoints();
    // Add pointActor to renderer and set properties
    renderer->AddActor(pointActor);
    renderer->SetBackground(0,0,0);
    renderer->ResetCamera();
    renderer->UpdateLightsGeometryToFollowCamera();
    // set qvtkWidget's interactor to renderWindowInteractor
    renderWindowInteractor = this->qvtkWidget->GetRenderWindow()->GetInteractor();
    // set qvtkWidget's renderWindow to renderWindowInteractor
    renderWindowInteractor->SetRenderWindow(this->qvtkWidget->GetRenderWindow());
    // set qvtkWidget's render
    this->qvtkWidget->GetRenderWindow()->AddRenderer(renderer);
    // set the qvtkWidget to be the mainwindow's central widget
    ui->cameraWidget->setWidget(qvtkWidget);
    // Add axes to qvtkWidget
    widgetAxes->SetOrientationMarker(axesActor);
    widgetAxes->SetInteractor(this->qvtkWidget->GetRenderWindow()->GetInteractor());
    widgetAxes->SetEnabled(1);
    widgetAxes->SetInteractive(0);
    ROI_add_3D(0,0,0,0,0,0);
}

void VGRibbonWindow::highLight(YZVision::vPointsXYZ pts)
{
    vtkPoints *points = vtkPoints::New();
    vtkCellArray *cells = vtkCellArray::New();
    vtkIdType idtype;
    for(int i=0;i<pts.size();i++){
        idtype = points->InsertNextPoint(pts[i].x,pts[i].y,pts[i].z);
        cells->InsertNextCell(1, &idtype);
    }
    vtkPolyData *polyData = vtkPolyData::New();
    polyData->SetPoints(points);
    polyData->SetVerts(cells);
    vtkPolyDataMapper *mapper = vtkPolyDataMapper::New();
    mapper->SetInputData(polyData);
    vtkActor *actor = vtkActor::New();
    actor->SetMapper(mapper);
    actor->GetProperty()->SetColor(0.194,0.562, 0.75);
    actor->GetProperty()->SetPointSize(5);
    renderer->AddActor(actor);
}

void VGRibbonWindow::highLightblob(YZVision::vPointsXYZ pts)
{
    vtkPoints *points = vtkPoints::New();
    vtkCellArray *cells = vtkCellArray::New();
    vtkIdType idtype;
    for(int i=0;i<pts.size();i++){
        idtype = points->InsertNextPoint(pts[i].x,pts[i].y,pts[i].z);
        cells->InsertNextCell(1, &idtype);
    }
    vtkPolyData *polyData = vtkPolyData::New();
    polyData->SetPoints(points);
    polyData->SetVerts(cells);
    vtkPolyDataMapper *mapper = vtkPolyDataMapper::New();
    mapper->SetInputData(polyData);
    vtkActor *actor = vtkActor::New();
    actor->SetMapper(mapper);
    actor->GetProperty()->SetColor(color_r,color_g,color_b);
    actor->GetProperty()->SetPointSize(2);
    renderer->AddActor(actor);
    color_r+=0.03;
    if(color_r>1)
        color_r=0;
    color_g+=0.1;
    if(color_g>1)
        color_g=0;
    color_b+=0.3;
    if(color_b>1)
        color_b=0;
}

void VGRibbonWindow::highLighthistory(YZVision::vPointsXYZ pts)
{
    vtkPoints *points = vtkPoints::New();
    vtkCellArray *cells = vtkCellArray::New();
    vtkIdType idtype;
    for(int i=0;i<pts.size();i++){
        idtype = points->InsertNextPoint(pts[i].x,pts[i].y,pts[i].z);
        cells->InsertNextCell(1, &idtype);
    }
    vtkPolyData *polyData = vtkPolyData::New();
    polyData->SetPoints(points);
    polyData->SetVerts(cells);
    vtkPolyDataMapper *mapper = vtkPolyDataMapper::New();
    mapper->SetInputData(polyData);
    vtkActor *actor = vtkActor::New();
    actor->SetMapper(mapper);
    actor->GetProperty()->SetColor(1,0, 0);
    actor->GetProperty()->SetPointSize(5);
    renderer->AddActor(actor);
}

void VGRibbonWindow::highLightline(int raw_cloud)
{
    qDebug()<<res[raw_cloud][0][0]<<res[raw_cloud][0][1]<<res[raw_cloud][0][2]<<res[raw_cloud][0][3]<<res[raw_cloud][0][4]<<res[raw_cloud][0][5];
    double linePara[] = {res[raw_cloud][0][0],res[raw_cloud][0][1],res[raw_cloud][0][2],res[raw_cloud][0][3],res[raw_cloud][0][4],res[raw_cloud][0][5]};//给定参数
    vtkSmartPointer<vtkPoints> p = vtkSmartPointer<vtkPoints>::New();
    int tmin = -999;
    int tmax = 999;
    p->InsertNextPoint(linePara[0]+linePara[3]*tmin,linePara[1]+linePara[4]*tmin,linePara[2]+linePara[5]*tmin);
    p->InsertNextPoint(linePara[0]+linePara[3]*tmax,linePara[1]+linePara[4]*tmax,linePara[2]+linePara[5]*tmax);
    vtkSmartPointer<vtkLineSource> lineSource =vtkSmartPointer<vtkLineSource>::New();
    lineSource->SetPoints(p);
    lineSource->Update();
    vtkSmartPointer<vtkPolyDataMapper> tubeMapper = vtkSmartPointer<vtkPolyDataMapper>::New();
    tubeMapper->SetInputConnection(/*tubeFilter*/lineSource->GetOutputPort());
    vtkSmartPointer<vtkLODActor> lineActor = vtkSmartPointer<vtkLODActor>::New();
    lineActor->SetMapper(tubeMapper);
    lineActor->GetProperty()->SetColor(0,1,0);
    renderer->AddActor(lineActor);
}

void VGRibbonWindow::highLightlinehistory(int raw_cloud)
{
    qDebug()<<res[raw_cloud][0][0]<<res[raw_cloud][0][1]<<res[raw_cloud][0][2]<<res[raw_cloud][0][3]<<res[raw_cloud][0][4]<<res[raw_cloud][0][5];
    double linePara[] = {res[raw_cloud][0][0],res[raw_cloud][0][1],res[raw_cloud][0][2],res[raw_cloud][0][3],res[raw_cloud][0][4],res[raw_cloud][0][5]};//给定参数
    vtkSmartPointer<vtkPoints> p = vtkSmartPointer<vtkPoints>::New();
    int tmin = -999;
    int tmax = 999;
    p->InsertNextPoint(linePara[0]+linePara[3]*tmin,linePara[1]+linePara[4]*tmin,linePara[2]+linePara[5]*tmin);
    p->InsertNextPoint(linePara[0]+linePara[3]*tmax,linePara[1]+linePara[4]*tmax,linePara[2]+linePara[5]*tmax);
    vtkSmartPointer<vtkLineSource> lineSource =vtkSmartPointer<vtkLineSource>::New();
    lineSource->SetPoints(p);
    lineSource->Update();
    vtkSmartPointer<vtkPolyDataMapper> tubeMapper = vtkSmartPointer<vtkPolyDataMapper>::New();
    tubeMapper->SetInputConnection(/*tubeFilter*/lineSource->GetOutputPort());
    vtkSmartPointer<vtkLODActor> lineActor = vtkSmartPointer<vtkLODActor>::New();
    lineActor->SetMapper(tubeMapper);
    lineActor->GetProperty()->SetColor(1,0, 0);
    renderer->AddActor(lineActor);
}

void VGRibbonWindow::highLightplane(int raw_cloud)
{
    QStringList order_x=ui->ordertable->item(raw_cloud,5)->text().split(",");
    QStringList order_y=ui->ordertable->item(raw_cloud,6)->text().split(",");
    QStringList order_z=ui->ordertable->item(raw_cloud,7)->text().split(",");
    x_min=order_x.at(0).toDouble();
    x_max=order_x.at(1).toDouble();
    y_min=order_y.at(0).toDouble();
    y_max=order_y.at(1).toDouble();
    z_min=order_z.at(0).toDouble();
    z_max=order_z.at(1).toDouble();

    double planePara[] = {res[raw_cloud][0][0],res[raw_cloud][0][1],res[raw_cloud][0][2],res[raw_cloud][0][3]};
    vtkSmartPointer<vtkPolyData> planePld =vtkSmartPointer<vtkPolyData>::New();
    vtkSmartPointer<vtkPoints> planePoints =vtkSmartPointer<vtkPoints>::New();
    vtkSmartPointer<vtkCellArray> planeCells =vtkSmartPointer<vtkCellArray>::New();
    vtkSmartPointer<vtkPolyDataMapper> planeMapper =vtkSmartPointer<vtkPolyDataMapper>::New();
    vtkSmartPointer<vtkActor> planeActor =vtkSmartPointer<vtkActor>::New();
    planePoints->SetNumberOfPoints( 4 );
    planePoints->InsertPoint(0, x_max, y_max, (-planePara[3]-planePara[0]*x_max-planePara[1]*y_max)/planePara[2]);
    planePoints->InsertPoint(1, x_min, y_max, (-planePara[3]-planePara[0]*x_min-planePara[1]*y_max)/planePara[2]);
    planePoints->InsertPoint(2, x_max, y_min, (-planePara[3]-planePara[0]*x_max-planePara[1]*y_min)/planePara[2]);
    planePoints->InsertPoint(3, x_min, y_min, (-planePara[3]-planePara[0]*x_min-planePara[1]*y_min)/planePara[2]);
    planePld->SetPoints( planePoints );
    vtkIdType cellId1[3] = { 1, 2, 3 };
    vtkIdType cellId2[3] = { 1, 2, 0 };
    //Create a cell by specifying the number of points and an array of pointid's.  Return the cell id of the cell.
    planeCells->InsertNextCell( 3, cellId1 );
    planeCells->InsertNextCell( 3, cellId2 );
    planePld->SetPolys( planeCells );
    planeMapper->SetInputData( planePld );
    planeActor->SetMapper( planeMapper );
    planeActor->GetProperty()->SetOpacity(0.9);
    planeActor->GetProperty()->SetColor( 0.4, 0.2, 0.7 );
    renderer->AddActor( planeActor );
}

void VGRibbonWindow::highLightplanehistory(int raw_cloud)
{
    QStringList order_x=ui->ordertable->item(raw_cloud,5)->text().split(",");
    QStringList order_y=ui->ordertable->item(raw_cloud,6)->text().split(",");
    QStringList order_z=ui->ordertable->item(raw_cloud,7)->text().split(",");
    x_min=order_x.at(0).toDouble();
    x_max=order_x.at(1).toDouble();
    y_min=order_y.at(0).toDouble();
    y_max=order_y.at(1).toDouble();
    z_min=order_z.at(0).toDouble();
    z_max=order_z.at(1).toDouble();
    double planePara[] = {res[raw_cloud][0][0],res[raw_cloud][0][1],res[raw_cloud][0][2],res[raw_cloud][0][3]};
    vtkSmartPointer<vtkPolyData> planePld =vtkSmartPointer<vtkPolyData>::New();
    vtkSmartPointer<vtkPoints> planePoints =vtkSmartPointer<vtkPoints>::New();
    vtkSmartPointer<vtkCellArray> planeCells =vtkSmartPointer<vtkCellArray>::New();
    vtkSmartPointer<vtkPolyDataMapper> planeMapper =vtkSmartPointer<vtkPolyDataMapper>::New();
    vtkSmartPointer<vtkActor> planeActor =vtkSmartPointer<vtkActor>::New();
    planePoints->SetNumberOfPoints( 4 );

    planePoints->InsertPoint(0, x_max, y_max, (-planePara[3]-planePara[0]*x_max-planePara[1]*y_max)/planePara[2]);
    planePoints->InsertPoint(1, x_min, y_max, (-planePara[3]-planePara[0]*x_min-planePara[1]*y_max)/planePara[2]);
    planePoints->InsertPoint(2, x_max, y_min, (-planePara[3]-planePara[0]*x_max-planePara[1]*y_min)/planePara[2]);
    planePoints->InsertPoint(3, x_min, y_min, (-planePara[3]-planePara[0]*x_min-planePara[1]*y_min)/planePara[2]);
    planePld->SetPoints( planePoints );
    vtkIdType cellId1[3] = { 1, 2, 3 };
    vtkIdType cellId2[3] = { 1, 2, 0 };
    //Create a cell by specifying the number of points and an array of pointid's.  Return the cell id of the cell.
    planeCells->InsertNextCell( 3, cellId1 );
    planeCells->InsertNextCell( 3, cellId2 );
    planePld->SetPolys( planeCells );
    planeMapper->SetInputData( planePld );
    planeActor->SetMapper( planeMapper );
    planeActor->GetProperty()->SetOpacity( 0.9 );
    planeActor->GetProperty()->SetColor(1,0, 0);
    renderer->AddActor( planeActor );
}

void VGRibbonWindow::setVtkLine(YZVision::PointXYZ a,YZVision::PointXYZ b){
    vtkSmartPointer<vtkPoints> p = vtkSmartPointer<vtkPoints>::New();
    p->InsertNextPoint(a.x,a.y,a.z);
    p->InsertNextPoint(b.x,b.y,b.z);
    vtkSmartPointer<vtkLineSource> lineSource =vtkSmartPointer<vtkLineSource>::New();
    lineSource->SetPoints(p);
    lineSource->Update();
    vtkSmartPointer<vtkPolyDataMapper> tubeMapper = vtkSmartPointer<vtkPolyDataMapper>::New();
    tubeMapper->SetInputConnection(/*tubeFilter*/lineSource->GetOutputPort());
    vtkSmartPointer<vtkLODActor> lineActor = vtkSmartPointer<vtkLODActor>::New();
    lineActor->SetMapper(tubeMapper);
    lineActor->GetProperty()->SetColor(0.2,1,0.2);
    renderer->AddActor(lineActor);
}

void VGRibbonWindow::on_cloud_choose_clicked()
{
    ui->reading->show();
    opencloudpath=QFileDialog::getOpenFileName(this,
                                           "please choose an cloud file",
                                           "./images",
                                           "Cloud Files(*.txt *.pcd);");
    if(opencloudpath==""){
        ui->reading->close();
        return;
    }
    QFileInfo file;
    file=QFileInfo(opencloudpath);
    QString path1=qApp->applicationDirPath()+"/1.txt";
    QString path=qApp->applicationDirPath()+"/1.pcd";
    if(file.suffix()=="txt"){
        qDebug()<<QFile::remove(path);
        qDebug()<<QFile::remove(path1);
        QFile::copy(opencloudpath,path1);
    }else{
        qDebug()<<QFile::remove(path);
        QFile::copy(opencloudpath,path);
        path1=path;
    }

    QElapsedTimer  mstimer;
    mstimer.start();
    YZVision::Readcloud_3D read;
    YZVision::Readcloud_3D::InputParam input= YZVision::Readcloud_3D::InputParam();
    YZVision::Readcloud_3D::OutputParam output= YZVision::Readcloud_3D::OutputParam();
    input.read=path1.toStdString();
    input.save=path.toStdString();

    read.readcloud(input,&output);
    cloudarrary[c_row]=output.outputcloud;
    qDebug()<<QFile::remove(path);
    qDebug()<<QFile::remove(path1);

    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    x_min=10000;
    x_max=0;
    y_min=10000;
    y_max=0;
    z_min=10000;
    z_max=0;
    for(long z=0;z<cloudarrary[c_row].size();z++){
        if(cloudarrary[c_row][z].x>x_max)
            x_max=cloudarrary[c_row][z].x;

        if(cloudarrary[c_row][z].x<x_min)
            x_min=cloudarrary[c_row][z].x;

        if(cloudarrary[c_row][z].y>y_max)
            y_max=cloudarrary[c_row][z].y;

        if(cloudarrary[c_row][z].y<y_min)
            y_min=cloudarrary[c_row][z].y;

        if(cloudarrary[c_row][z].z>z_max)
            z_max=cloudarrary[c_row][z].z;

        if(cloudarrary[c_row][z].z<z_min)
            z_min=cloudarrary[c_row][z].z;

        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
    }
    ui->cloud_n->setText(QString::number(cloudarrary[c_row].size()));

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(opencloudpath);
    ui->ordertable->setItem(c_row,4,item->clone());
    item->setText(QString("%1,%2").arg(x_min).arg(x_max));
    ui->ordertable->setItem(c_row,5,item->clone());
    item->setText(QString("%1,%2").arg(y_min).arg(y_max));
    ui->ordertable->setItem(c_row,6,item->clone());
    item->setText(QString("%1,%2").arg(z_min).arg(z_max));
    ui->ordertable->setItem(c_row,7,item->clone());
    opencloud();
    ui->reading->close();
}

//重置视角
void VGRibbonWindow::on_view_reset_clicked()
{
    vtkNew<vtkCamera> camera;
    renderer->SetActiveCamera(camera);
    renderer->ResetCamera();

    qvtkWidget->update();
}

//俯视图
void VGRibbonWindow::on_view_up_clicked()
{
    QStringList order_x=ui->ordertable->item(c_row,5)->text().split(",");
    QStringList order_y=ui->ordertable->item(c_row,6)->text().split(",");
    QStringList order_z=ui->ordertable->item(c_row,7)->text().split(",");
    x_min=order_x.at(0).toDouble();
    x_max=order_x.at(1).toDouble();
    y_min=order_y.at(0).toDouble();
    y_max=order_y.at(1).toDouble();
    z_min=order_z.at(0).toDouble();
    z_max=order_z.at(1).toDouble();
    YZVision::PointXYZ p_min,p_max;
    p_min.setPoint(x_min,y_min,z_min);
    p_max.setPoint(x_max,y_max,z_max);
    double maxLen;
    if(x_max-x_min>y_max-y_min)
        maxLen=x_max-x_min;
    else
        maxLen=y_max-y_min;
    if(maxLen<z_max-z_min)
        maxLen=z_max-z_min;
    //0.5 * (p_min.x + p_max.x), 0.5 * (p_min.y + p_max.y), p_max.z + 2 * maxLen
    vtkNew<vtkCamera> camera;
    camera->SetPosition (0.5 * (p_min.x + p_max.x), 0.5 * (p_min.y + p_max.y), p_max.z + 2 * maxLen);
    camera->SetViewUp (0, 1, 0);
    camera->SetFocalPoint (0, 0, -1);
    renderer->SetActiveCamera(camera);
    renderer->ResetCamera();

    qvtkWidget->update();
}

//前视图
void VGRibbonWindow::on_view_front_clicked()
{
    QStringList order_x=ui->ordertable->item(c_row,5)->text().split(",");
    QStringList order_y=ui->ordertable->item(c_row,6)->text().split(",");
    QStringList order_z=ui->ordertable->item(c_row,7)->text().split(",");
    x_min=order_x.at(0).toDouble();
    x_max=order_x.at(1).toDouble();
    y_min=order_y.at(0).toDouble();
    y_max=order_y.at(1).toDouble();
    z_min=order_z.at(0).toDouble();
    z_max=order_z.at(1).toDouble();
    YZVision::PointXYZ p_min,p_max;
    p_min.setPoint(x_min,y_min,z_min);
    p_max.setPoint(x_max,y_max,z_max);
    double maxLen;
    if(x_max-x_min>y_max-y_min)
        maxLen=x_max-x_min;
    else
        maxLen=y_max-y_min;
    if(maxLen<z_max-z_min)
        maxLen=z_max-z_min;

    //0.5 * (p_min.x + p_max.x), p_min.y - 2 * maxLen, 0.5 * (p_min.z + p_max.z)
    vtkNew<vtkCamera> camera;
    camera->SetPosition (0.5 * (p_min.x + p_max.x), p_min.y - 2 * maxLen, 0.5 * (p_min.z + p_max.z));
    camera->SetViewUp (0,0,1);
    camera->SetFocalPoint (0, 1, 0);
    renderer->SetActiveCamera(camera);
    renderer->ResetCamera();

    qvtkWidget->update();
}

//左视图
void VGRibbonWindow::on_view_left_clicked()
{
    QStringList order_x=ui->ordertable->item(c_row,5)->text().split(",");
    QStringList order_y=ui->ordertable->item(c_row,6)->text().split(",");
    QStringList order_z=ui->ordertable->item(c_row,7)->text().split(",");
    x_min=order_x.at(0).toDouble();
    x_max=order_x.at(1).toDouble();
    y_min=order_y.at(0).toDouble();
    y_max=order_y.at(1).toDouble();
    z_min=order_z.at(0).toDouble();
    z_max=order_z.at(1).toDouble();
    YZVision::PointXYZ p_min,p_max;
    p_min.setPoint(x_min,y_min,z_min);
    p_max.setPoint(x_max,y_max,z_max);
    double maxLen;
    if(x_max-x_min>y_max-y_min)
        maxLen=x_max-x_min;
    else
        maxLen=y_max-y_min;
    if(maxLen<z_max-z_min)
        maxLen=z_max-z_min;
    //p_min.x - 2 * maxLen, 0.5 * (p_min.y + p_max.y), 0.5 * (p_min.z + p_max.z)

    vtkNew<vtkCamera> camera;
    camera->SetPosition (p_min.x - 2 * maxLen, 0.5 * (p_min.y + p_max.y), 0.5 * (p_min.z + p_max.z));
    camera->SetViewUp (0, 0, 1);
    camera->SetFocalPoint (1, 0, 0);
    renderer->SetActiveCamera(camera);
    renderer->ResetCamera();

    qvtkWidget->update();
}

//后视图
void VGRibbonWindow::on_view_back_clicked()
{
    QStringList order_x=ui->ordertable->item(c_row,5)->text().split(",");
    QStringList order_y=ui->ordertable->item(c_row,6)->text().split(",");
    QStringList order_z=ui->ordertable->item(c_row,7)->text().split(",");
    x_min=order_x.at(0).toDouble();
    x_max=order_x.at(1).toDouble();
    y_min=order_y.at(0).toDouble();
    y_max=order_y.at(1).toDouble();
    z_min=order_z.at(0).toDouble();
    z_max=order_z.at(1).toDouble();
    YZVision::PointXYZ p_min,p_max;
    p_min.setPoint(x_min,y_min,z_min);
    p_max.setPoint(x_max,y_max,z_max);
    double maxLen;
    if(x_max-x_min>y_max-y_min)
        maxLen=x_max-x_min;
    else
        maxLen=y_max-y_min;
    if(maxLen<z_max-z_min)
        maxLen=z_max-z_min;
//    0.5 * (p_min.x + p_max.x), p_max.y + 2 * maxLen, 0.5 * (p_min.z + p_max.z)
    vtkNew<vtkCamera> camera;
    camera->SetPosition (0.5 * (p_min.x + p_max.x), p_max.y + 2 * maxLen, 0.5 * (p_min.z + p_max.z));
    camera->SetViewUp (0, 0, 1);
    camera->SetFocalPoint (0, -1, 0);
    renderer->SetActiveCamera(camera);
    qvtkWidget->update();
}

//右视图
void VGRibbonWindow::on_view_right_clicked()
{
    QStringList order_x=ui->ordertable->item(c_row,5)->text().split(",");
    QStringList order_y=ui->ordertable->item(c_row,6)->text().split(",");
    QStringList order_z=ui->ordertable->item(c_row,7)->text().split(",");
    x_min=order_x.at(0).toDouble();
    x_max=order_x.at(1).toDouble();
    y_min=order_y.at(0).toDouble();
    y_max=order_y.at(1).toDouble();
    z_min=order_z.at(0).toDouble();
    z_max=order_z.at(1).toDouble();
    YZVision::PointXYZ p_min,p_max;
    p_min.setPoint(x_min,y_min,z_min);
    p_max.setPoint(x_max,y_max,z_max);
    double maxLen;
    if(x_max-x_min>y_max-y_min)
        maxLen=x_max-x_min;
    else
        maxLen=y_max-y_min;
    if(maxLen<z_max-z_min)
        maxLen=z_max-z_min;
//    p_max.x + 2 * maxLen, 0.5 * (p_min.y + p_max.y), 0.5 * (p_min.z + p_max.z)
    vtkNew<vtkCamera> camera;
    camera->SetPosition (p_max.x + 2 * maxLen, 0.5 * (p_min.y + p_max.y), 0.5 * (p_min.z + p_max.z));
    camera->SetViewUp (0, 0, 1);
    camera->SetFocalPoint (-1, 0, 0);
    renderer->SetActiveCamera(camera);
    qvtkWidget->update();
}

//仰视图
void VGRibbonWindow::on_view_bottom_clicked()
{
    QStringList order_x=ui->ordertable->item(c_row,5)->text().split(",");
    QStringList order_y=ui->ordertable->item(c_row,6)->text().split(",");
    QStringList order_z=ui->ordertable->item(c_row,7)->text().split(",");
    x_min=order_x.at(0).toDouble();
    x_max=order_x.at(1).toDouble();
    y_min=order_y.at(0).toDouble();
    y_max=order_y.at(1).toDouble();
    z_min=order_z.at(0).toDouble();
    z_max=order_z.at(1).toDouble();
    YZVision::PointXYZ p_min,p_max;
    p_min.setPoint(x_min,y_min,z_min);
    p_max.setPoint(x_max,y_max,z_max);
    double maxLen;
    if(x_max-x_min>y_max-y_min)
        maxLen=x_max-x_min;
    else
        maxLen=y_max-y_min;
    if(maxLen<z_max-z_min)
        maxLen=z_max-z_min;
    //0.5 * (p_min.x + p_max.x), 0.5 * (p_min.y + p_max.y), p_min.z - 2 * maxLen
    vtkNew<vtkCamera> camera;
    camera->SetPosition (0.5 * (p_min.x + p_max.x), 0.5 * (p_min.y + p_max.y), p_min.z - 2 * maxLen);
    camera->SetViewUp (0, 1, 0);
    camera->SetFocalPoint (0, 0, 1);
    renderer->SetActiveCamera(camera);

    qvtkWidget->update();
}

//前轴图
void VGRibbonWindow::on_view_frontlso_clicked()
{
    QStringList order_x=ui->ordertable->item(c_row,5)->text().split(",");
    QStringList order_y=ui->ordertable->item(c_row,6)->text().split(",");
    QStringList order_z=ui->ordertable->item(c_row,7)->text().split(",");
    x_min=order_x.at(0).toDouble();
    x_max=order_x.at(1).toDouble();
    y_min=order_y.at(0).toDouble();
    y_max=order_y.at(1).toDouble();
    z_min=order_z.at(0).toDouble();
    z_max=order_z.at(1).toDouble();
    YZVision::PointXYZ p_min,p_max;
    p_min.setPoint(x_min,y_min,z_min);
    p_max.setPoint(x_max,y_max,z_max);
    double maxLen;
    if(x_max-x_min>y_max-y_min)
        maxLen=x_max-x_min;
    else
        maxLen=y_max-y_min;
    if(maxLen<z_max-z_min)
        maxLen=z_max-z_min;
    //p_min.x - 2 * maxLen, p_min.y - 2 * maxLen, p_max.z + 2 * maxLen
    vtkNew<vtkCamera> camera;
    camera->SetPosition (p_min.x - 2 * maxLen, p_min.y - 2 * maxLen, p_max.z + 2 * maxLen);
    camera->SetViewUp (0,1,1);
    camera->SetFocalPoint (1, 1, 0);
    renderer->SetActiveCamera(camera);

    qvtkWidget->update();
}

//后轴图
void VGRibbonWindow::on_view_backlso_clicked()
{
    QStringList order_x=ui->ordertable->item(c_row,5)->text().split(",");
    QStringList order_y=ui->ordertable->item(c_row,6)->text().split(",");
    QStringList order_z=ui->ordertable->item(c_row,7)->text().split(",");
    x_min=order_x.at(0).toDouble();
    x_max=order_x.at(1).toDouble();
    y_min=order_y.at(0).toDouble();
    y_max=order_y.at(1).toDouble();
    z_min=order_z.at(0).toDouble();
    z_max=order_z.at(1).toDouble();
    YZVision::PointXYZ p_min,p_max;
    p_min.setPoint(x_min,y_min,z_min);
    p_max.setPoint(x_max,y_max,z_max);
    double maxLen;
    if(x_max-x_min>y_max-y_min)
        maxLen=x_max-x_min;
    else
        maxLen=y_max-y_min;
    if(maxLen<z_max-z_min)
        maxLen=z_max-z_min;
    //p_max.x + 2 * maxLen, p_max.y + 2 * maxLen, p_max.z + 2 * maxLen
    vtkNew<vtkCamera> camera;
    camera->SetPosition (p_max.x + 2 * maxLen, p_max.y + 2 * maxLen, p_max.z + 2 * maxLen);
    camera->SetViewUp (0,-1,-1);
    camera->SetFocalPoint (1, 1, 0);
    renderer->SetActiveCamera(camera);

    qvtkWidget->update();
}

//找边缘点
void VGRibbonWindow::on_point_general_clicked()
{
    ui->point_setting->setCurrentIndex(0);
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->point_cloud->count()>0){
        int raw_cloud=ui->point_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->point_preview->setEnabled(false);
                ui->point_ROI->setEnabled(false);
            }else{
                ui->point_ROI->setEnabled(true);
                ui->point_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
                opencloud();
                int r=raw_cloud;
                while(ui->ordertable->item(r,3)->text()=="找边缘点"||
                      ui->ordertable->item(r,3)->text()=="找拐点"||
                      ui->ordertable->item(r,3)->text()=="找线"||
                      ui->ordertable->item(r,3)->text()=="找面"||
                      ui->ordertable->item(r,3)->text()=="找质心"){
                    if(res[r].size()==0)
                        break;
                    if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                            ui->ordertable->item(r,3)->text()=="找拐点"||
                            ui->ordertable->item(r,3)->text()=="找质心"){
                        YZVision::vPointsXYZ points;
                        for(int z=0;z<res[r].size();z++){
                            YZVision::PointXYZ point;
                            point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                            points.push_back(point);
                        }
                        highLighthistory(points);
                    }else if(ui->ordertable->item(r,3)->text()=="找线"){
                        highLightlinehistory(r);
                    }else if(ui->ordertable->item(r,3)->text()=="找面"){
                        highLightplanehistory(r);
                    }
                    QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
                    QStringList s_data=order_s.at(0).split("=");
                    r=s_data.at(1).toInt()-1;
                }
            }
        }else
            ui->point_preview->setEnabled(false);
    }else{
        ui->point_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_point_ROI_clicked()
{
    on_point_general_clicked();
    ui->point_ROI->setEnabled(false);
    ui->point_ROI_setting->show();
    double p_x=ui->point_x->text().toDouble();
    double p_y=ui->point_y->text().toDouble();
    double p_z=ui->point_z->text().toDouble();
    double l=ui->point_l->text().toDouble();
    double w=ui->point_w->text().toDouble();
    double h=ui->point_h->text().toDouble();
    if(l==0||w==0||h==0){
        p_x=0;
        p_y=0;
        p_z=0;
        l=20;
        w=20;
        h=20;
        ui->point_x->setText("0");
        ui->point_y->setText("0");
        ui->point_z->setText("0");
        ui->point_l->setText("20");
        ui->point_w->setText("20");
        ui->point_h->setText("20");
        start.setPoint(0,0,0);
        end.setPoint(20,20,20);
    }
    ROI_add_3D(p_x,p_y,p_z,l,w,h);
    point_ROI_change();
}

void VGRibbonWindow::on_point_preview_clicked()
{
    ui->point_ROI->setEnabled(true);
    ui->point_setting->setCurrentIndex(0);
    YZVision::ROIProbeDirection a;
    if(ui->point_direction->currentIndex()==0)
        a=YZVision::ROIProbeDirection::RIGHT;
    else if (ui->point_direction->currentIndex()==1)
        a=YZVision::ROIProbeDirection::LEFT;
    else if (ui->point_direction->currentIndex()==2)
        a=YZVision::ROIProbeDirection::UP;
    else if (ui->point_direction->currentIndex()==3)
        a=YZVision::ROIProbeDirection::DOWN;
    int raw_cloud=ui->point_cloud->currentText().toInt()-1;
    int result;

    QElapsedTimer  mstimer;
    mstimer.start();
    YZVision::vPointsXYZ edgePointCloud;
    YZVision::Feature* feature = NULL;
    YZVision::EdgePoint_3D* p_edgePoint = new YZVision::EdgePoint_3D();
    feature = p_edgePoint;
    YZVision::Feature::InputParam input= YZVision::Feature::InputParam();
    YZVision::Feature::OutputParam output= YZVision::Feature::OutputParam();
    input.inputCloud=&cloudarrary[raw_cloud];
    input.serachDir=a;
    input.m_StartPoint=start;
    input.m_EndPoint=end;
    result=feature->findFeature(input,&output);
    cloudarrary[c_row]=cloudarrary[raw_cloud];
    edgePointCloud=output.outputPoints;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);

    openrawcloud(cloudarrary[raw_cloud]);
    highLight(edgePointCloud);

    int r=raw_cloud;
    while(ui->ordertable->item(r,3)->text()=="找边缘点"||
          ui->ordertable->item(r,3)->text()=="找拐点"||
          ui->ordertable->item(r,3)->text()=="找线"||
          ui->ordertable->item(r,3)->text()=="找面"||
          ui->ordertable->item(r,3)->text()=="找质心"){
        if(res[r].size()==0)
            break;
        if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                ui->ordertable->item(r,3)->text()=="找拐点"||
                ui->ordertable->item(r,3)->text()=="找质心"){
            YZVision::vPointsXYZ points;
            for(int z=0;z<res[r].size();z++){
                YZVision::PointXYZ point;
                point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                points.push_back(point);
            }
            highLighthistory(points);
        }else if(ui->ordertable->item(r,3)->text()=="找线"){
            highLightlinehistory(r);
        }else if(ui->ordertable->item(r,3)->text()=="找面"){
            highLightplanehistory(r);
        }
        QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
        QStringList s_data=order_s.at(0).split("=");
        r=s_data.at(1).toInt()-1;
    }

    std::vector<std::vector <float>> t;
    for(long z=0;z<edgePointCloud.size();z++){
        std::vector <float> t_a;
        t_a.push_back(edgePointCloud[z].x);
        t_a.push_back(edgePointCloud[z].y);
        t_a.push_back(edgePointCloud[z].z);
        t.push_back(t_a);
    }
    res[c_row]=t;
}

void VGRibbonWindow::point_setting_change()
{
     QTableWidgetItem *item = new QTableWidgetItem;
     item->setText("raw_cloud="+ui->point_cloud->currentText()+","+
                   "direction="+QString::number(ui->point_direction->currentIndex()));
     ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::point_ROI_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    double* xrange = mouseStyle->a->GetXRange();
    double* yrange = mouseStyle->a->GetYRange();
    double* zrange = mouseStyle->a->GetZRange();
    start.setPoint(xrange[0],yrange[0],zrange[0]);
    end.setPoint(xrange[1],yrange[1],zrange[1]);
    item->setText(ui->point_x->text()+","+
                  ui->point_y->text()+","+
                  ui->point_z->text()+","+
                  ui->point_l->text()+","+
                  ui->point_w->text()+","+
                  ui->point_h->text()+","+
                  QString::number(xrange[0])+","+
                  QString::number(yrange[0])+","+
                  QString::number(zrange[0])+","+
                  QString::number(xrange[1])+","+
                  QString::number(yrange[1])+","+
                  QString::number(zrange[1]));
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_point_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_point_general_clicked();
        int raw_cloud=ui->point_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());

        point_setting_change();
    }
}

void VGRibbonWindow::on_point_direction_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    point_setting_change();
}

void VGRibbonWindow::on_point_x_editingFinished()
{
    on_point_general_clicked();
    on_point_ROI_clicked();
    point_ROI_change();
}

void VGRibbonWindow::on_point_y_editingFinished()
{
    on_point_general_clicked();
    on_point_ROI_clicked();
    point_ROI_change();
}


void VGRibbonWindow::on_point_z_editingFinished()
{
    on_point_general_clicked();
    on_point_ROI_clicked();
    point_ROI_change();
}


void VGRibbonWindow::on_point_l_editingFinished()
{
    on_point_general_clicked();
    on_point_ROI_clicked();
    point_ROI_change();
}


void VGRibbonWindow::on_point_w_editingFinished()
{
    on_point_general_clicked();
    on_point_ROI_clicked();
    point_ROI_change();
}


void VGRibbonWindow::on_point_h_editingFinished()
{
    on_point_general_clicked();
    on_point_ROI_clicked();
    point_ROI_change();
}

//找拐点
void VGRibbonWindow::on_turning_general_clicked()
{
    ui->turning_setting->setCurrentIndex(0);
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->turning_cloud->count()>0){
        int raw_cloud=ui->turning_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->turning_ROI->setEnabled(false);
                ui->turning_preview->setEnabled(false);
            }else{
                ui->turning_ROI->setEnabled(true);
                ui->turning_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
                opencloud();
                int r=raw_cloud;
                while(ui->ordertable->item(r,3)->text()=="找边缘点"||
                      ui->ordertable->item(r,3)->text()=="找拐点"||
                      ui->ordertable->item(r,3)->text()=="找线"||
                      ui->ordertable->item(r,3)->text()=="找面"||
                      ui->ordertable->item(r,3)->text()=="找质心"){
                    if(res[r].size()==0)
                        break;
                    if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                            ui->ordertable->item(r,3)->text()=="找拐点"||
                            ui->ordertable->item(r,3)->text()=="找质心"){
                        YZVision::vPointsXYZ points;
                        for(int z=0;z<res[r].size();z++){
                            YZVision::PointXYZ point;
                            point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                            points.push_back(point);
                        }
                        highLighthistory(points);
                    }else if(ui->ordertable->item(r,3)->text()=="找线"){
                        highLightlinehistory(r);
                    }else if(ui->ordertable->item(r,3)->text()=="找面"){
                        highLightplanehistory(r);
                    }
                    QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
                    QStringList s_data=order_s.at(0).split("=");
                    r=s_data.at(1).toInt()-1;
                }
            }
        }else
            ui->turning_preview->setEnabled(false);
    }else{
        ui->turning_preview->setEnabled(false);
    }

}

void VGRibbonWindow::on_turning_ROI_clicked()
{
    on_turning_general_clicked();
    ui->turning_ROI->setEnabled(false);
    ui->turning_ROI_setting->show();
    double p_x=ui->turning_x->text().toDouble();
    double p_y=ui->turning_y->text().toDouble();
    double p_z=ui->turning_z->text().toDouble();
    double l=ui->turning_l->text().toDouble();
    double w=ui->turning_w->text().toDouble();
    double h=ui->turning_h->text().toDouble();
    if(l==0||w==0||h==0){
        p_x=0;
        p_y=0;
        p_z=0;
        l=20;
        w=20;
        h=20;
        ui->turning_x->setText("0");
        ui->turning_y->setText("0");
        ui->turning_z->setText("0");
        ui->turning_l->setText("20");
        ui->turning_w->setText("20");
        ui->turning_h->setText("20");
        start.setPoint(0,0,0);
        end.setPoint(20,20,20);
    }
    ROI_add_3D(p_x,p_y,p_z,l,w,h);
    turning_ROI_change();
}

void VGRibbonWindow::on_turning_preview_clicked()
{
    ui->turning_ROI->setEnabled(true);
    ui->turning_setting->setCurrentIndex(0);
    YZVision::ROIProbeDirection a;
    if(ui->turning_direction->currentIndex()==0)
        a=YZVision::ROIProbeDirection::RIGHT;
    else if (ui->turning_direction->currentIndex()==1)
        a=YZVision::ROIProbeDirection::LEFT;
    else if (ui->turning_direction->currentIndex()==2)
        a=YZVision::ROIProbeDirection::UP;
    else if (ui->turning_direction->currentIndex()==3)
        a=YZVision::ROIProbeDirection::DOWN;
    double threshold=ui->turning_threshold->text().toDouble();
    int raw_cloud=ui->turning_cloud->currentText().toInt()-1;
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();
    YZVision::vPointsXYZ turningPointCloud;
    YZVision::Feature* feature = NULL;
    YZVision::TurningPoint_3D* p_turnPoint = new YZVision::TurningPoint_3D();
    feature = p_turnPoint;
    YZVision::Feature::InputParam input= YZVision::Feature::InputParam();
    YZVision::Feature::OutputParam output= YZVision::Feature::OutputParam();
    input.inputCloud=&cloudarrary[raw_cloud];
    input.serachDir=a;
    input.m_StartPoint=start;
    input.m_EndPoint=end;
    input.z_thres=threshold;
    result=feature->findFeature(input,&output);
    cloudarrary[c_row]=cloudarrary[raw_cloud];
    turningPointCloud=output.outputPoints;
    qDebug()<<turningPointCloud.size();

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);
    cloudarrary[c_row]=cloudarrary[raw_cloud];
    openrawcloud(cloudarrary[raw_cloud]);
    highLight(turningPointCloud);

    int r=raw_cloud;
    while(ui->ordertable->item(r,3)->text()=="找边缘点"||
          ui->ordertable->item(r,3)->text()=="找拐点"||
          ui->ordertable->item(r,3)->text()=="找线"||
          ui->ordertable->item(r,3)->text()=="找面"||
          ui->ordertable->item(r,3)->text()=="找质心"){
        if(res[r].size()==0)
            break;
        if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                ui->ordertable->item(r,3)->text()=="找拐点"||
                ui->ordertable->item(r,3)->text()=="找质心"){
            YZVision::vPointsXYZ points;
            for(int z=0;z<res[r].size();z++){
                YZVision::PointXYZ point;
                point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                points.push_back(point);
            }
            highLighthistory(points);
        }else if(ui->ordertable->item(r,3)->text()=="找线"){
            highLightlinehistory(r);
        }else if(ui->ordertable->item(r,3)->text()=="找面"){
            highLightplanehistory(r);
        }
        QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
        QStringList s_data=order_s.at(0).split("=");
        r=s_data.at(1).toInt()-1;
    }

    std::vector<std::vector <float>> t;
    for(long z=0;z<turningPointCloud.size();z++){
        std::vector <float> t_a;
        t_a.push_back(turningPointCloud[z].x);
        t_a.push_back(turningPointCloud[z].y);
        t_a.push_back(turningPointCloud[z].z);
        t.push_back(t_a);
    }
    res[c_row]=t;
}

void VGRibbonWindow::turning_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->turning_cloud->currentText()+","+
                  "direction="+QString::number(ui->turning_direction->currentIndex())+","+
                  "threshold="+ui->turning_threshold->text());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::turning_ROI_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    double* xrange = mouseStyle->a->GetXRange();
    double* yrange = mouseStyle->a->GetYRange();
    double* zrange = mouseStyle->a->GetZRange();
    start.setPoint(xrange[0],yrange[0],zrange[0]);
    end.setPoint(xrange[1],yrange[1],zrange[1]);
    item->setText(ui->turning_x->text()+","+
                  ui->turning_y->text()+","+
                  ui->turning_z->text()+","+
                  ui->turning_l->text()+","+
                  ui->turning_w->text()+","+
                  ui->turning_h->text()+","+
                  QString::number(xrange[0])+","+
                  QString::number(yrange[0])+","+
                  QString::number(zrange[0])+","+
                  QString::number(xrange[1])+","+
                  QString::number(yrange[1])+","+
                  QString::number(zrange[1]));
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_turning_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_turning_general_clicked();
        int raw_cloud=ui->turning_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());

        turning_setting_change();
    }
}

void VGRibbonWindow::on_turning_direction_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    turning_setting_change();
}

void VGRibbonWindow::on_turning_threshold_editingFinished()
{
    turning_setting_change();
}

void VGRibbonWindow::on_turning_x_editingFinished()
{
    on_turning_general_clicked();
    on_turning_ROI_clicked();
    turning_ROI_change();
}

void VGRibbonWindow::on_turning_y_editingFinished()
{
    on_turning_general_clicked();
    on_turning_ROI_clicked();
    turning_ROI_change();
}

void VGRibbonWindow::on_turning_z_editingFinished()
{
    on_turning_general_clicked();
    on_turning_ROI_clicked();
    turning_ROI_change();
}

void VGRibbonWindow::on_turning_l_editingFinished()
{
    on_turning_general_clicked();
    on_turning_ROI_clicked();
    turning_ROI_change();
}

void VGRibbonWindow::on_turning_w_editingFinished()
{
    on_turning_general_clicked();
    on_turning_ROI_clicked();
    turning_ROI_change();
}

void VGRibbonWindow::on_turning_h_editingFinished()
{
    on_turning_general_clicked();
    on_turning_ROI_clicked();
    turning_ROI_change();
}

//找线
void VGRibbonWindow::on_line_general_clicked()
{
    ui->line_setting->setCurrentIndex(0);
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->line_cloud->count()>0){
        int raw_cloud=ui->line_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->line_ROI->setEnabled(false);
                ui->line_preview->setEnabled(false);
            }else{
                ui->line_ROI->setEnabled(true);
                ui->line_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
                opencloud();
                int r=raw_cloud;
                while(ui->ordertable->item(r,3)->text()=="找边缘点"||
                      ui->ordertable->item(r,3)->text()=="找拐点"||
                      ui->ordertable->item(r,3)->text()=="找线"||
                      ui->ordertable->item(r,3)->text()=="找面"||
                      ui->ordertable->item(r,3)->text()=="找质心"){
                    if(res[r].size()==0)
                        break;
                    if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                            ui->ordertable->item(r,3)->text()=="找拐点"||
                            ui->ordertable->item(r,3)->text()=="找质心"){
                        YZVision::vPointsXYZ points;
                        for(int z=0;z<res[r].size();z++){
                            YZVision::PointXYZ point;
                            point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                            points.push_back(point);
                        }
                        highLighthistory(points);
                    }else if(ui->ordertable->item(r,3)->text()=="找线"){
                        highLightlinehistory(r);
                    }else if(ui->ordertable->item(r,3)->text()=="找面"){
                        highLightplanehistory(r);
                    }
                    QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
                    QStringList s_data=order_s.at(0).split("=");
                    r=s_data.at(1).toInt()-1;
                }
            }
        }else
            ui->line_preview->setEnabled(false);
    }else{
        ui->line_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_line_ROI_clicked()
{
    on_line_general_clicked();
    ui->line_ROI->setEnabled(false);
    ui->line_ROI_setting->show();
    double p_x=ui->line_x->text().toDouble();
    double p_y=ui->line_y->text().toDouble();
    double p_z=ui->line_z->text().toDouble();
    double l=ui->line_l->text().toDouble();
    double w=ui->line_w->text().toDouble();
    double h=ui->line_h->text().toDouble();
    if(l==0||w==0||h==0){
        p_x=0;
        p_y=0;
        p_z=0;
        l=20;
        w=20;
        h=20;
        ui->line_x->setText("0");
        ui->line_y->setText("0");
        ui->line_z->setText("0");
        ui->line_l->setText("20");
        ui->line_w->setText("20");
        ui->line_h->setText("20");
        start.setPoint(0,0,0);
        end.setPoint(20,20,20);
    }
    ROI_add_3D(p_x,p_y,p_z,l,w,h);
    line_ROI_change();
}

void VGRibbonWindow::on_line_preview_clicked()
{
    ui->line_ROI->setEnabled(true);
    ui->line_setting->setCurrentIndex(0);
    YZVision::ROIProbeDirection a;
    if(ui->line_direction->currentIndex()==0)
        a=YZVision::ROIProbeDirection::RIGHT;
    else if (ui->line_direction->currentIndex()==1)
        a=YZVision::ROIProbeDirection::LEFT;
    else if (ui->line_direction->currentIndex()==2)
        a=YZVision::ROIProbeDirection::UP;
    else if (ui->line_direction->currentIndex()==3)
        a=YZVision::ROIProbeDirection::DOWN;
    int raw_cloud=ui->line_cloud->currentText().toInt()-1;
    int type=ui->line_type->currentIndex();
    int result;
    std::vector<int> index;
    std::vector<float> Coeffients;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Segmentation* segmentation = NULL;
    YZVision::LineSegment* p_lineSeg = new YZVision::LineSegment();
    segmentation = p_lineSeg;
    YZVision::Segmentation::InputParam input_Param;
    YZVision::Segmentation::OutputParam output_Param;
    input_Param.inputCloud = &cloudarrary[raw_cloud];
    input_Param.serachDir = a;
    input_Param.m_StartPoint = start;
    input_Param.m_EndPoint = end;
    input_Param.distance_Threshold = 0.5;
    input_Param.max_iteratios = 100;
    input_Param.z_threshold=0.1;
    if(type==1){
        input_Param.line_seg_option=YZVision::Segmentation::LineSegOption::FIT_LINE_BASE_ON_TURNINGPOINTS;
    }

    result = segmentation->segment(input_Param, &output_Param);
    index=output_Param.modelInliers;
    Coeffients=output_Param.modelCoeffients;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);
    cloudarrary[c_row]=cloudarrary[raw_cloud];

    std::vector<std::vector <float>> t;
    std::vector <float> t_a;
    for(int x=0;x<Coeffients.size();x++){
        t_a.push_back(Coeffients[x]);
        qDebug()<<Coeffients[x];
    }
    t.push_back(t_a);
    std::vector <float> t_r;
    t_r.push_back(output_Param.xyz_angles[0]);
    t_r.push_back(output_Param.xyz_angles[1]);
    t_r.push_back(output_Param.xyz_angles[2]);
    t.push_back(t_r);
    res[c_row]=t;

    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();

    highLightline(c_row);

    int r=raw_cloud;
    while(ui->ordertable->item(r,3)->text()=="找边缘点"||
          ui->ordertable->item(r,3)->text()=="找拐点"||
          ui->ordertable->item(r,3)->text()=="找线"||
          ui->ordertable->item(r,3)->text()=="找面"||
          ui->ordertable->item(r,3)->text()=="找质心"){
        if(res[r].size()==0)
            break;
        if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                ui->ordertable->item(r,3)->text()=="找拐点"||
                ui->ordertable->item(r,3)->text()=="找质心"){
            YZVision::vPointsXYZ points;
            for(int z=0;z<res[r].size();z++){
                YZVision::PointXYZ point;
                point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                points.push_back(point);
            }
            highLighthistory(points);
        }else if(ui->ordertable->item(r,3)->text()=="找线"){
            highLightlinehistory(r);
        }else if(ui->ordertable->item(r,3)->text()=="找面"){
            highLightplanehistory(r);
        }
        QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
        QStringList s_data=order_s.at(0).split("=");
        r=s_data.at(1).toInt()-1;
    }
}

void VGRibbonWindow::line_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->line_cloud->currentText()+","+
                  "direction="+QString::number(ui->line_direction->currentIndex())+","+
                  "type="+QString::number(ui->line_type->currentIndex()));
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::line_ROI_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    double* xrange = mouseStyle->a->GetXRange();
    double* yrange = mouseStyle->a->GetYRange();
    double* zrange = mouseStyle->a->GetZRange();
    start.setPoint(xrange[0],yrange[0],zrange[0]);
    end.setPoint(xrange[1],yrange[1],zrange[1]);
    qDebug()<<start.x<<start.y<<start.z;
    qDebug()<<end.x<<end.y<<end.z;
    item->setText(ui->line_x->text()+","+
                  ui->line_y->text()+","+
                  ui->line_z->text()+","+
                  ui->line_l->text()+","+
                  ui->line_w->text()+","+
                  ui->line_h->text()+","+
                  QString::number(xrange[0])+","+
                  QString::number(yrange[0])+","+
                  QString::number(zrange[0])+","+
                  QString::number(xrange[1])+","+
                  QString::number(yrange[1])+","+
                  QString::number(zrange[1]));
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_line_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_line_general_clicked();
        int raw_cloud=ui->line_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        line_setting_change();
    }
}

void VGRibbonWindow::on_line_direction_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    line_setting_change();
}

void VGRibbonWindow::on_line_type_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    line_setting_change();
}

void VGRibbonWindow::on_line_x_editingFinished()
{
    on_line_general_clicked();
    on_line_ROI_clicked();
    line_ROI_change();
}

void VGRibbonWindow::on_line_y_editingFinished()
{
    on_line_general_clicked();
    on_line_ROI_clicked();
    line_ROI_change();
}

void VGRibbonWindow::on_line_z_editingFinished()
{
    on_line_general_clicked();
    on_line_ROI_clicked();
    line_ROI_change();
}

void VGRibbonWindow::on_line_l_editingFinished()
{
    on_line_general_clicked();
    on_line_ROI_clicked();
    line_ROI_change();
}

void VGRibbonWindow::on_line_w_editingFinished()
{
    on_line_general_clicked();
    on_line_ROI_clicked();
    line_ROI_change();
}

void VGRibbonWindow::on_line_h_editingFinished()
{
    on_line_general_clicked();
    on_line_ROI_clicked();
    line_ROI_change();
}

//找面
void VGRibbonWindow::on_plane_general_clicked()
{
    ui->plane_setting->setCurrentIndex(0);
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->plane_cloud->count()>0){
        int raw_cloud=ui->plane_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->plane_ROI->setEnabled(false);
                ui->plane_preview->setEnabled(false);
            }else{
                ui->plane_ROI->setEnabled(true);
                ui->plane_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
                opencloud();
                int r=raw_cloud;
                while(ui->ordertable->item(r,3)->text()=="找边缘点"||
                      ui->ordertable->item(r,3)->text()=="找拐点"||
                      ui->ordertable->item(r,3)->text()=="找线"||
                      ui->ordertable->item(r,3)->text()=="找面"||
                      ui->ordertable->item(r,3)->text()=="找质心"){
                    if(res[r].size()==0)
                        break;
                    if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                            ui->ordertable->item(r,3)->text()=="找拐点"||
                            ui->ordertable->item(r,3)->text()=="找质心"){
                        YZVision::vPointsXYZ points;
                        for(int z=0;z<res[r].size();z++){
                            YZVision::PointXYZ point;
                            point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                            points.push_back(point);
                        }
                        highLighthistory(points);
                    }else if(ui->ordertable->item(r,3)->text()=="找线"){
                        highLightlinehistory(r);
                    }else if(ui->ordertable->item(r,3)->text()=="找面"){
                        highLightplanehistory(r);
                    }
                    QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
                    QStringList s_data=order_s.at(0).split("=");
                    r=s_data.at(1).toInt()-1;
                }

            }
        }else
            ui->plane_preview->setEnabled(false);
    }else{
        ui->plane_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_plane_ROI_clicked()
{
    on_plane_general_clicked();
    ui->plane_ROI->setEnabled(false);
    ui->plane_ROI_setting->show();
    double p_x=ui->plane_x->text().toDouble();
    double p_y=ui->plane_y->text().toDouble();
    double p_z=ui->plane_z->text().toDouble();
    double l=ui->plane_l->text().toDouble();
    double w=ui->plane_w->text().toDouble();
    double h=ui->plane_h->text().toDouble();
    if(l==0||w==0||h==0){
        p_x=0;
        p_y=0;
        p_z=0;
        l=20;
        w=20;
        h=20;
        ui->plane_x->setText("0");
        ui->plane_y->setText("0");
        ui->plane_z->setText("0");
        ui->plane_l->setText("20");
        ui->plane_w->setText("20");
        ui->plane_h->setText("20");
        start.setPoint(0,0,0);
        end.setPoint(20,20,20);
    }
    ROI_add_3D(p_x,p_y,p_z,l,w,h);
    plane_ROI_change();
}

void VGRibbonWindow::on_plane_preview_clicked()
{
    ui->plane_ROI->setEnabled(true);
    ui->plane_setting->setCurrentIndex(0);
    YZVision::ROIProbeDirection a;
    if(ui->plane_direction->currentIndex()==0)
        a=YZVision::ROIProbeDirection::FRONT;
    else if (ui->plane_direction->currentIndex()==1)
        a=YZVision::ROIProbeDirection::BACK;
    int result;
    std::vector<int> index;
    std::vector<float> Coeffients;
    int raw_cloud=ui->plane_cloud->currentText().toInt()-1;

    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Segmentation* segmentation = NULL;
    YZVision::PlaneSegment* p_planeSeg = new YZVision::PlaneSegment();
    segmentation = p_planeSeg;
    YZVision::Segmentation::InputParam input_Param;
    YZVision::Segmentation::OutputParam output_Param;
    input_Param.inputCloud = &cloudarrary[raw_cloud];
    input_Param.serachDir = a;
    input_Param.m_StartPoint = start;
    input_Param.m_EndPoint = end;
    input_Param.distance_Threshold = 0.5;
    input_Param.max_iteratios = 100;

    result = segmentation->segment(input_Param, &output_Param);
    index=output_Param.modelInliers;
    Coeffients=output_Param.modelCoeffients;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);

    cloudarrary[c_row]=cloudarrary[raw_cloud];

    std::vector<std::vector <float>> t;
    std::vector <float> t_a;
    for(int x=0;x<Coeffients.size();x++){
        t_a.push_back(Coeffients[x]);
        qDebug()<<Coeffients[x];
    }
    t.push_back(t_a);
    res[c_row]=t;

    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();

    highLightplane(c_row);

    int r=raw_cloud;
    while(ui->ordertable->item(r,3)->text()=="找边缘点"||
          ui->ordertable->item(r,3)->text()=="找拐点"||
          ui->ordertable->item(r,3)->text()=="找线"||
          ui->ordertable->item(r,3)->text()=="找面"||
          ui->ordertable->item(r,3)->text()=="找质心"){
        if(res[r].size()==0)
            break;
        if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                ui->ordertable->item(r,3)->text()=="找拐点"||
                ui->ordertable->item(r,3)->text()=="找质心"){
            YZVision::vPointsXYZ points;
            for(int z=0;z<res[r].size();z++){
                YZVision::PointXYZ point;
                point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                points.push_back(point);
            }
            highLighthistory(points);
        }else if(ui->ordertable->item(r,3)->text()=="找线"){
            highLightlinehistory(r);
        }else if(ui->ordertable->item(r,3)->text()=="找面"){
            highLightplanehistory(r);
        }
        QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
        QStringList s_data=order_s.at(0).split("=");
        r=s_data.at(1).toInt()-1;
    }

}

void VGRibbonWindow::plane_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->plane_cloud->currentText()+","+
                  "direction="+QString::number(ui->plane_direction->currentIndex()));
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::plane_ROI_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    double* xrange = mouseStyle->a->GetXRange();
    double* yrange = mouseStyle->a->GetYRange();
    double* zrange = mouseStyle->a->GetZRange();
    start.setPoint(xrange[0],yrange[0],zrange[0]);
    end.setPoint(xrange[1],yrange[1],zrange[1]);
    qDebug()<<start.x<<start.y<<start.z;
    qDebug()<<end.x<<end.y<<end.z;
    item->setText(ui->plane_x->text()+","+
                  ui->plane_y->text()+","+
                  ui->plane_z->text()+","+
                  ui->plane_l->text()+","+
                  ui->plane_w->text()+","+
                  ui->plane_h->text()+","+
                  QString::number(xrange[0])+","+
                  QString::number(yrange[0])+","+
                  QString::number(zrange[0])+","+
                  QString::number(xrange[1])+","+
                  QString::number(yrange[1])+","+
                  QString::number(zrange[1]));
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_plane_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_plane_general_clicked();
        int raw_cloud=ui->planeness_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());

        plane_setting_change();

    }
}

void VGRibbonWindow::on_plane_direction_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    plane_setting_change();
}

void VGRibbonWindow::on_plane_x_editingFinished()
{
    on_plane_general_clicked();
    on_plane_ROI_clicked();
    plane_ROI_change();
}

void VGRibbonWindow::on_plane_y_editingFinished()
{
    on_plane_general_clicked();
    on_plane_ROI_clicked();
    plane_ROI_change();
}

void VGRibbonWindow::on_plane_z_editingFinished()
{
    on_plane_general_clicked();
    on_plane_ROI_clicked();
    plane_ROI_change();
}

void VGRibbonWindow::on_plane_l_editingFinished()
{
    on_plane_general_clicked();
    on_plane_ROI_clicked();
    plane_ROI_change();
}

void VGRibbonWindow::on_plane_w_editingFinished()
{
    on_plane_general_clicked();
    on_plane_ROI_clicked();
    plane_ROI_change();
}

void VGRibbonWindow::on_plane_h_editingFinished()
{
    on_plane_general_clicked();
    on_plane_ROI_clicked();
    plane_ROI_change();
}

//找质心
void VGRibbonWindow::on_Centroid_general_clicked()
{
    ui->Centroid_setting->setCurrentIndex(0);
    ui->Centroid_result->setText("");
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->Centroid_cloud->count()>0){
        int raw_cloud=ui->Centroid_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->Centroid_ROI->setEnabled(false);
                ui->Centroid_preview->setEnabled(false);
            }else{
                ui->Centroid_ROI->setEnabled(true);
                ui->Centroid_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }

                opencloud();
                int r=raw_cloud;
                while(ui->ordertable->item(r,3)->text()=="找边缘点"||
                      ui->ordertable->item(r,3)->text()=="找拐点"||
                      ui->ordertable->item(r,3)->text()=="找线"||
                      ui->ordertable->item(r,3)->text()=="找面"||
                      ui->ordertable->item(r,3)->text()=="找质心"){
                    if(res[r].size()==0)
                        break;
                    if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                            ui->ordertable->item(r,3)->text()=="找拐点"||
                            ui->ordertable->item(r,3)->text()=="找质心"){
                        YZVision::vPointsXYZ points;
                        for(int z=0;z<res[r].size();z++){
                            YZVision::PointXYZ point;
                            point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                            points.push_back(point);
                        }
                        highLighthistory(points);
                    }else if(ui->ordertable->item(r,3)->text()=="找线"){
                        highLightlinehistory(r);
                    }else if(ui->ordertable->item(r,3)->text()=="找面"){
                        highLightplanehistory(r);
                    }
                    QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
                    QStringList s_data=order_s.at(0).split("=");
                    r=s_data.at(1).toInt()-1;
                }

            }
        }else
            ui->Centroid_preview->setEnabled(false);
    }else{
        ui->Centroid_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_Centroid_ROI_clicked()
{
    on_Centroid_general_clicked();
    ui->Centroid_ROI->setEnabled(false);
    ui->Centroid_ROI_setting->show();
    double p_x=ui->Centroid_x->text().toDouble();
    double p_y=ui->Centroid_y->text().toDouble();
    double p_z=ui->Centroid_z->text().toDouble();
    double l=ui->Centroid_l->text().toDouble();
    double w=ui->Centroid_w->text().toDouble();
    double h=ui->Centroid_h->text().toDouble();
    if(l==0||w==0||h==0){
        p_x=0;
        p_y=0;
        p_z=0;
        l=20;
        w=20;
        h=20;
        ui->Centroid_x->setText("0");
        ui->Centroid_y->setText("0");
        ui->Centroid_z->setText("0");
        ui->Centroid_l->setText("20");
        ui->Centroid_w->setText("20");
        ui->Centroid_h->setText("20");
        start.setPoint(0,0,0);
        end.setPoint(20,20,20);
    }
    ROI_add_3D(p_x,p_y,p_z,l,w,h);
    Centroid_ROI_change();
}

void VGRibbonWindow::on_Centroid_preview_clicked()
{
    ui->Centroid_ROI->setEnabled(true);
    ui->Centroid_setting->setCurrentIndex(0);
    int raw_cloud=ui->Centroid_cloud->currentText().toInt()-1;
    int result=0;
    YZVision::vPointsXYZ CentroidPointCloud;
    QElapsedTimer  mstimer;
    mstimer.start();
    YZVision::Feature* feature = NULL;
    YZVision::Centroid_3D* p_Centroid = new YZVision::Centroid_3D();
    feature = p_Centroid;
    YZVision::Feature::InputParam input= YZVision::Feature::InputParam();
    YZVision::Feature::OutputParam output= YZVision::Feature::OutputParam();
    input.inputCloud=&cloudarrary[raw_cloud];
    input.serachDir = YZVision::ROIProbeDirection::RIGHT;
    input.m_StartPoint=start;
    input.m_EndPoint=end;
    result=feature->findFeature(input,&output);
    CentroidPointCloud=output.outputPoints;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);

    cloudarrary[c_row]=cloudarrary[raw_cloud];
    openrawcloud(cloudarrary[c_row]);
    highLight(CentroidPointCloud);

    int r=raw_cloud;
    while(ui->ordertable->item(r,3)->text()=="找边缘点"||
          ui->ordertable->item(r,3)->text()=="找拐点"||
          ui->ordertable->item(r,3)->text()=="找线"||
          ui->ordertable->item(r,3)->text()=="找面"||
          ui->ordertable->item(r,3)->text()=="找质心"){
        if(res[r].size()==0)
            break;
        if(ui->ordertable->item(r,3)->text()=="找边缘点"||
                ui->ordertable->item(r,3)->text()=="找拐点"||
                ui->ordertable->item(r,3)->text()=="找质心"){
            YZVision::vPointsXYZ points;
            for(int z=0;z<res[r].size();z++){
                YZVision::PointXYZ point;
                point.setPoint(res[r][z][0],res[r][z][1],res[r][z][2]);
                points.push_back(point);
            }
            highLighthistory(points);
        }else if(ui->ordertable->item(r,3)->text()=="找线"){
            highLightlinehistory(r);
        }else if(ui->ordertable->item(r,3)->text()=="找面"){
            highLightplanehistory(r);
        }
        QStringList order_s=ui->ordertable->item(r,4)->text().split(",");
        QStringList s_data=order_s.at(0).split("=");
        r=s_data.at(1).toInt()-1;
    }

    ui->Centroid_result->setText(QString::number(CentroidPointCloud[0].x)+","+QString::number(CentroidPointCloud[0].y)+","+QString::number(CentroidPointCloud[0].z));

    std::vector<std::vector <float>> t;
    std::vector <float> t_a;
    t_a.push_back(CentroidPointCloud[0].x);
    t_a.push_back(CentroidPointCloud[0].y);
    t_a.push_back(CentroidPointCloud[0].z);
    t.push_back(t_a);
    res[c_row]=t;
}

void VGRibbonWindow::Centroid_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->Centroid_cloud->currentText());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::Centroid_ROI_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    double* xrange = mouseStyle->a->GetXRange();
    double* yrange = mouseStyle->a->GetYRange();
    double* zrange = mouseStyle->a->GetZRange();
    start.setPoint(xrange[0],yrange[0],zrange[0]);
    end.setPoint(xrange[1],yrange[1],zrange[1]);
    qDebug()<<start.x<<start.y<<start.z;
    qDebug()<<end.x<<end.y<<end.z;
    item->setText(ui->Centroid_x->text()+","+
                  ui->Centroid_y->text()+","+
                  ui->Centroid_z->text()+","+
                  ui->Centroid_l->text()+","+
                  ui->Centroid_w->text()+","+
                  ui->Centroid_h->text()+","+
                  QString::number(xrange[0])+","+
                  QString::number(yrange[0])+","+
                  QString::number(zrange[0])+","+
                  QString::number(xrange[1])+","+
                  QString::number(yrange[1])+","+
                  QString::number(zrange[1]));
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_Centroid_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_Centroid_general_clicked();
        Centroid_setting_change();
        int raw_cloud=ui->Centroid_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());

        ui->Centroid_result->setText("");
    }
}

void VGRibbonWindow::on_Centroid_x_editingFinished()
{
    on_Centroid_general_clicked();
    on_Centroid_ROI_clicked();
    Centroid_ROI_change();
}

void VGRibbonWindow::on_Centroid_y_editingFinished()
{
    on_Centroid_general_clicked();
    on_Centroid_ROI_clicked();
    Centroid_ROI_change();
}

void VGRibbonWindow::on_Centroid_z_editingFinished()
{
    on_Centroid_general_clicked();
    on_Centroid_ROI_clicked();
    Centroid_ROI_change();
}

void VGRibbonWindow::on_Centroid_l_editingFinished()
{
    on_Centroid_general_clicked();
    on_Centroid_ROI_clicked();
    Centroid_ROI_change();
}

void VGRibbonWindow::on_Centroid_w_editingFinished()
{
    on_Centroid_general_clicked();
    on_Centroid_ROI_clicked();
    Centroid_ROI_change();
}

void VGRibbonWindow::on_Centroid_h_editingFinished()
{
    on_Centroid_general_clicked();
    on_Centroid_ROI_clicked();
    Centroid_ROI_change();
}

//拼接
void VGRibbonWindow::on_Splicing_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->Splicing_raw_cloud_1->count()>0&&ui->Splicing_raw_cloud_2->count()>0){
        int raw_cloud_1,raw_cloud_2;
        raw_cloud_1=ui->Splicing_raw_cloud_1->currentText().toInt()-1;
        raw_cloud_2=ui->Splicing_raw_cloud_2->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud_1,10)->text()=="3D"){
            if(cloudarrary[raw_cloud_1].size()>0){
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud_1].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud_1][z].x,cloudarrary[raw_cloud_1][z].y,cloudarrary[raw_cloud_1][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud_1][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud_1][z].z;
                    }

                    if (cloudarrary[raw_cloud_1][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud_1][z].z;
                    }
                }
            }
        }
        if(ui->ordertable->item(raw_cloud_1,10)->text()=="3D"&&ui->ordertable->item(raw_cloud_2,10)->text()=="3D"){
            ui->Splicing_preview->setEnabled(true);
        }else
            ui->Splicing_preview->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_Splicing_preview_clicked()
{
    int raw_cloud_1,raw_cloud_2;
    bool crop;
    if(ui->Splicing_CROP->isChecked())
        crop=false;
    else
        crop=true;
    double low=ui->Splicing_CROP_low->text().toDouble(),high=ui->Splicing_CROP_high->text().toDouble(),move=ui->Splicing_CROP_move->text().toDouble();
    raw_cloud_1=ui->Splicing_raw_cloud_1->currentText().toInt()-1;
    raw_cloud_2=ui->Splicing_raw_cloud_2->currentText().toInt()-1;
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Cloudsplicing_3D Cloudsplicing;
    YZVision::Cloudsplicing_3D::InputParam input= YZVision::Cloudsplicing_3D::InputParam();
    YZVision::Cloudsplicing_3D::OutputParam output= YZVision::Cloudsplicing_3D::OutputParam();
    input.inputcloud_90=&cloudarrary[raw_cloud_1];
    input.inputcloud_91=&cloudarrary[raw_cloud_2];
    input.Q=crop;
    input.x_0=move;
    input.l_0=low;
    input.l_1=high;
    result=Cloudsplicing.cloudsplicing(input,&output);
    cloudarrary[c_row]=output.outputcloud_90_91;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);

    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        qDebug()<<cloudarrary[c_row][z].x<<" "<<cloudarrary[c_row][z].y<<" "<<cloudarrary[c_row][z].z;
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::Splicing_setting_change()
{
    QString crop;
    if(ui->Splicing_CROP->isChecked())
        crop="1";
    else
        crop="0";
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud_1="+ui->Splicing_raw_cloud_1->currentText()+","+
                  "raw_cloud_2="+ui->Splicing_raw_cloud_2->currentText()+","+
                  "CROP="+crop+","+
                  "move="+ui->Splicing_CROP_move->text()+","+
                  "low="+ui->Splicing_CROP_low->text()+","+
                  "high="+ui->Splicing_CROP_high->text());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_Splicing_raw_cloud_1_currentIndexChanged(int index)
{
    if(index>=0){
        on_Splicing_general_clicked();
        points = vtkSmartPointer<vtkPoints>::New();
        vertices = vtkSmartPointer<vtkCellArray>::New();
        int raw_cloud=ui->Splicing_raw_cloud_1->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            z_min=10000;
            z_max=0;
            cloudarrary[c_row]=cloudarrary[raw_cloud];
            for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                vertices->InsertNextCell(1);
                vertices->InsertCellPoint(z);
                if (cloudarrary[raw_cloud][z].z< z_min)
                {
                    z_min = cloudarrary[raw_cloud][z].z;
                }

                if (cloudarrary[raw_cloud][z].z > z_max)
                {
                    z_max = cloudarrary[raw_cloud][z].z;
                }
            }
            ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
            ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
            ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        }
        opencloud();
        Splicing_setting_change();
    }
}

void VGRibbonWindow::on_Splicing_raw_cloud_2_currentIndexChanged(int index)
{
    if(index>=0){
        on_Splicing_general_clicked();
        points = vtkSmartPointer<vtkPoints>::New();
        vertices = vtkSmartPointer<vtkCellArray>::New();
        int raw_cloud=ui->Splicing_raw_cloud_2->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            z_min=10000;
            z_max=0;
            for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                vertices->InsertNextCell(1);
                vertices->InsertCellPoint(z);
                if (cloudarrary[raw_cloud][z].z < z_min)
                {
                    z_min = cloudarrary[raw_cloud][z].z;
                }

                if (cloudarrary[raw_cloud][z].z > z_max)
                {
                    z_max = cloudarrary[raw_cloud][z].z;
                }
            }
        }
        opencloud();
        Splicing_setting_change();
    }
}

void VGRibbonWindow::on_Splicing_CROP_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    if(ui->Splicing_CROP->isChecked()){
        ui->Splicing_CROP_l->show();
        ui->Splicing_CROP_low->show();
        ui->Splicing_CROP_high->show();
    }else{
        ui->Splicing_CROP_l->close();
        ui->Splicing_CROP_low->close();
        ui->Splicing_CROP_high->close();
    }
    Splicing_setting_change();
}

void VGRibbonWindow::on_Splicing_CROP_move_editingFinished()
{
    Splicing_setting_change();
}

void VGRibbonWindow::on_Splicing_CROP_low_editingFinished()
{
    Splicing_setting_change();
}

void VGRibbonWindow::on_Splicing_CROP_high_editingFinished()
{
    Splicing_setting_change();
}

//平滑
void VGRibbonWindow::on_smooth_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->smooth_raw_cloud->count()>0){
        int raw_cloud=ui->smooth_raw_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->smooth_preview->setEnabled(false);
            }else{
                ui->smooth_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
            }
        }else
            ui->smooth_preview->setEnabled(false);
    }else{
        ui->smooth_preview->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_smooth_preview_clicked()
{
    int raw_cloud=ui->smooth_raw_cloud->currentText().toInt()-1;
    double radius=ui->smooth_radius->text().toDouble();
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Fullupcloud_3D smooth;
    YZVision::Fullupcloud_3D::InputParam input= YZVision::Fullupcloud_3D::InputParam();
    YZVision::Fullupcloud_3D::OutputParam output= YZVision::Fullupcloud_3D::OutputParam();
    input.inputcloud=&cloudarrary[raw_cloud];
    input.r_0=radius;
    result=smooth.fullupcloud(input,&output);
    cloudarrary[c_row]=output.outputcloud;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);

    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::smooth_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->smooth_raw_cloud->currentText()+","+
                  "radius="+ui->smooth_radius->text());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_smooth_raw_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_smooth_general_clicked();
        int raw_cloud=ui->smooth_raw_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        smooth_setting_change();
    }
}

void VGRibbonWindow::on_smooth_radius_editingFinished()
{
    smooth_setting_change();
}

//去重
void VGRibbonWindow::on_CROP_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->CROP_raw_cloud->count()>0){
        int raw_cloud=ui->CROP_raw_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->CROP_preview->setEnabled(false);
            }else{
                ui->CROP_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
            }
        }else
            ui->CROP_preview->setEnabled(false);
    }else{
        ui->CROP_preview->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_CROP_preview_clicked()
{
    int raw_cloud=ui->CROP_raw_cloud->currentText().toInt()-1;
    int dirction=ui->CROP_direction->currentIndex()+1;
    double low=ui->CROP_low->text().toDouble(),high=ui->CROP_high->text().toDouble();
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::CloudDeduplication_3D CROP;
    YZVision::CloudDeduplication_3D::InputParam input= YZVision::CloudDeduplication_3D::InputParam();
    YZVision::CloudDeduplication_3D::OutputParam output= YZVision::CloudDeduplication_3D::OutputParam();
    input.inputcloud_90=&cloudarrary[raw_cloud];
    input.a=dirction;
    input.l_0=low;
    input.l_1=high;
    result=CROP.clouddeduplication(input,&output);

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    cloudarrary[c_row]=output.outputcloud;
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::CROP_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->CROP_raw_cloud->currentText()+","+
                  "dirction="+QString::number(ui->CROP_direction->currentIndex())+","+
                  "low="+ui->CROP_low->text()+","+
                  "high="+ui->CROP_high->text()+","+
                  "move="+ui->CROP_move->text());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_CROP_raw_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_CROP_general_clicked();
        int raw_cloud=ui->CROP_raw_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        CROP_setting_change();
    }
}

void VGRibbonWindow::on_CROP_direction_currentIndexChanged(int index)
{
    if(index>=0){
        CROP_setting_change();
    }
}

void VGRibbonWindow::on_CROP_low_editingFinished()
{
    if(ui->CROP_low->text().toDouble()>ui->CROP_high->text().toDouble()){
        QMessageBox::warning(0, "警告","去重范围最小值请小于最大值");
        ui->CROP_low->setText(ui->CROP_high->text());
    }
    CROP_setting_change();
}

void VGRibbonWindow::on_CROP_high_editingFinished()
{
    if(ui->CROP_low->text().toDouble()>ui->CROP_high->text().toDouble()){
        QMessageBox::warning(0, "警告","去重范围最大值请大于最小值");
        ui->CROP_high->setText(ui->CROP_low->text());
    }
    CROP_setting_change();
}

void VGRibbonWindow::on_CROP_move_editingFinished()
{
    CROP_setting_change();
}

//3d转深度图
void VGRibbonWindow::on_Deep_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->Deep_raw_cloud->count()>0){
        int raw_cloud=ui->Deep_raw_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->Deep_preview->setEnabled(false);
            }else{
                ui->Deep_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
            }
        }else
            ui->Deep_preview->setEnabled(false);
    }else{
        ui->Deep_preview->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_Deep_preview_clicked()
{
    int raw_cloud=ui->Deep_raw_cloud->currentText().toInt()-1;
    double zoom=ui->Deep_zoom->text().toDouble();
    double zoom_y=ui->Deep_zoom_y->text().toDouble();
    int result;
    bool wave=ui->Deep_wave->isChecked();
    double threshold=ui->Deep_threshold->text().toDouble();
    QImage resu;
    YZVision::vPointsXYZ cloud;
    cloud=cloudarrary[raw_cloud];

    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Deepcloud_3D deep;
    YZVision::Deepcloud_3D::InputParam input= YZVision::Deepcloud_3D::InputParam();
    YZVision::Deepcloud_3D::OutputParam output= YZVision::Deepcloud_3D::OutputParam();
    input.inputcloud=&cloud;
    input.x_0=zoom;
    input.y_0=zoom_y;
    input.Q=wave;
    input.a_0=threshold;
    result=deep.deepcloud(input,&output);
    resu =cvMat2Image(output.outImage); 

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    image[c_row]=QPixmap::fromImage(resu);
    QGraphicsScene *scene = new QGraphicsScene;
    graphicsimageitem* raw = new graphicsimageitem(image[c_row]);
    n_image=image[c_row];
    connect(raw,SIGNAL(mousemove(qreal,QPointF)),this,SLOT(showinfo(qreal,QPointF)));
    scene->addItem(raw);
    ui->graphicsView->setScene(scene);
    ui->cameraWidget->setWidget(ui->graphicsView);
}

void VGRibbonWindow::Deep_setting_change()
{
    QString wave;
    if(ui->Deep_wave->isChecked())
        wave="1";
    else
        wave="0";
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->Deep_raw_cloud->currentText()+","+
                  "zoom="+ui->Deep_zoom->text()+","+
                  "zoom_y="+ui->Deep_zoom->text()+","+
                  "wave="+wave+","+
                  "threshold="+ui->Deep_threshold->text());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_Deep_raw_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_Deep_general_clicked();
        Deep_setting_change();
    }
}

void VGRibbonWindow::on_Deep_zoom_editingFinished()
{
    Deep_setting_change();
}

void VGRibbonWindow::on_Deep_zoom_y_editingFinished()
{
    Deep_setting_change();
}

void VGRibbonWindow::on_Deep_wave_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    if(ui->Deep_wave->isChecked()){
        ui->Deep_threshold_l->show();
        ui->Deep_threshold->show();
    }else{
        ui->Deep_threshold_l->close();
        ui->Deep_threshold->close();
    }
    Deep_setting_change();
}

void VGRibbonWindow::on_Deep_threshold_editingFinished()
{
    Deep_setting_change();
}

//重采样
void VGRibbonWindow::on_sampling_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->sampling_raw_cloud->count()>0){
        int raw_cloud=ui->sampling_raw_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->sampling_preview->setEnabled(false);
            }else{
                ui->sampling_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
            }
        }else
            ui->sampling_preview->setEnabled(false);
    }else{
        ui->sampling_preview->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_sampling_preview_clicked()
{
    int raw_cloud=ui->sampling_raw_cloud->currentText().toInt()-1;
    int type=ui->sampling_type->currentIndex();
    double length=ui->sampling_length->text().toDouble();
    double radius=ui->sampling_radius->text().toDouble();
    double step=ui->sampling_step->text().toDouble();
    YZVision::vPointsXYZ cloud;
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();
    if(type==0){
        YZVision::Downresampling_3D Downresampling;
        YZVision::Downresampling_3D::InputParam input= YZVision::Downresampling_3D::InputParam();
        YZVision::Downresampling_3D::OutputParam output= YZVision::Downresampling_3D::OutputParam();
        input.inputcloud=&cloudarrary[raw_cloud];
        input.r_0=length;
        result=Downresampling.downresampling(input,&output);
        cloud=output.outputcloud;
    }else if(type==1){
        YZVision::Averageresampling_3D Averageresampling;
        YZVision::Averageresampling_3D::InputParam input= YZVision::Averageresampling_3D::InputParam();
        YZVision::Averageresampling_3D::OutputParam output= YZVision::Averageresampling_3D::OutputParam();
        input.inputcloud=&cloudarrary[raw_cloud];
        input.r_0=length;
        result=Averageresampling.averageresampling(input,&output);
        cloud=output.outputcloud;
     }else if(type==2){
        YZVision::Upresampling_3D Upresampling;
        YZVision::Upresampling_3D::InputParam input= YZVision::Upresampling_3D::InputParam();
        YZVision::Upresampling_3D::OutputParam output= YZVision::Upresampling_3D::OutputParam();
        input.inputcloud=&cloudarrary[raw_cloud];
        input.r_0=length;
        input.r_1=radius;
        input.s_0=step;
        result=Upresampling.upresampling(input,&output);
        cloud=output.outputcloud;
    }
    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    cloudarrary[c_row]=cloud;
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::sampling_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->sampling_raw_cloud->currentText()+","+
                  "type="+QString::number(ui->sampling_type->currentIndex())+","+
                  "length="+ui->sampling_length->text()+","+
                  "radius="+ui->sampling_radius->text()+","+
                  "step="+ui->sampling_step->text());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_sampling_raw_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_sampling_general_clicked();
        int raw_cloud=ui->sampling_raw_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        sampling_setting_change();
    }
}

void VGRibbonWindow::on_sampling_type_currentIndexChanged(int index)
{
    if(index>=0){
        ui->sampling_radius->close();
        ui->sampling_step->close();
        ui->sampling_radius_label->close();
        ui->sampling_step_label->close();
        if(index==0){
            ui->sampling_type_n->setText("体素栅格边长");
        }else if(index==1){
            ui->sampling_type_n->setText("查找半径大小");
        }else{
            ui->sampling_type_n->setText("搜索领域半径");
            ui->sampling_radius->show();
            ui->sampling_step->show();
            ui->sampling_radius_label->show();
            ui->sampling_step_label->show();
        }
        sampling_setting_change();
    }
}

void VGRibbonWindow::on_sampling_length_editingFinished()
{
    sampling_setting_change();
}

void VGRibbonWindow::on_sampling_radius_editingFinished()
{
    sampling_setting_change();
}

void VGRibbonWindow::on_sampling_step_editingFinished()
{
    sampling_setting_change();
}

//滤波
void VGRibbonWindow::on_wave_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->wave_raw_cloud->count()>0){
        int raw_cloud=ui->wave_raw_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->wave_preview->setEnabled(false);
            }else{
                ui->wave_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }
                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
            }
        }else
            ui->wave_preview->setEnabled(false);
    }else{
        ui->wave_preview->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_wave_preview_clicked()
{
    int raw_cloud=ui->wave_raw_cloud->currentText().toInt()-1;
    int type=ui->wave_type->currentIndex();
    int direction=ui->wave_direction->currentIndex()+1;
    double up=ui->wave_up->text().toDouble();
    double down=ui->wave_down->text().toDouble();
    double number=ui->wave_number->text().toDouble();
    double zoom=ui->wave_zoom->text().toDouble();
    bool saved;
    if(ui->wave_save->isChecked())
        saved=true;
    else
        saved=false;
    YZVision::vPointsXYZ cloud;
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();
    if(type==0){
        YZVision::PassthroughFilter_3D pass;
        YZVision::PassthroughFilter_3D::InputParam input= YZVision::PassthroughFilter_3D::InputParam();
        YZVision::PassthroughFilter_3D::OutputParam output= YZVision::PassthroughFilter_3D::OutputParam();
        input.inputcloud=&cloudarrary[raw_cloud];
        input.a=direction;
        input.R_0=saved;
        input.x_0=down;
        input.x_1=up;
        result=pass.passThroughFilter(input,&output);
        cloud=output.outputcloud;
    }else if(type==1){
        YZVision::Statisticalcloud_3D Statis;
        YZVision::Statisticalcloud_3D::InputParam input= YZVision::Statisticalcloud_3D::InputParam();
        YZVision::Statisticalcloud_3D::OutputParam output= YZVision::Statisticalcloud_3D::OutputParam();
        input.inputcloud=&cloudarrary[raw_cloud];
        input.x_0=saved;
        input.a_0=number;
        input.s_0=zoom;
        result=Statis.statisticalcloud(input,&output);
        cloud=output.outputcloud;
    }else if(type==2){
        YZVision::Radiuscloud_3D Radius;
        YZVision::Radiuscloud_3D::InputParam input= YZVision::Radiuscloud_3D::InputParam();
        YZVision::Radiuscloud_3D::OutputParam output= YZVision::Radiuscloud_3D::OutputParam();
        input.inputcloud=&cloudarrary[raw_cloud];
        input.a_0=number;
        input.r_0=zoom;
        result=Radius.raduiscloud(input,&output);
        cloud=output.outputcloud;
        qDebug()<<cloudarrary[raw_cloud].size();
        qDebug()<<cloud.size();
    }
    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    cloudarrary[c_row]=cloud;
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::wave_setting_change()
{
    QString save;
    if(ui->wave_save->isChecked())
        save="1";
    else
        save="0";
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->wave_raw_cloud->currentText()+","+
                  "type="+QString::number(ui->wave_type->currentIndex())+","+
                  "direction="+QString::number(ui->wave_direction->currentIndex())+","+
                  "up="+ui->wave_up->text()+","+
                  "down="+ui->wave_down->text()+","+
                  "number="+ui->wave_number->text()+","+
                  "zoom="+ui->wave_zoom->text()+","+
                  "save="+save);
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_wave_raw_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_wave_general_clicked();
        int raw_cloud=ui->wave_raw_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());

        wave_setting_change();
    }
}

void VGRibbonWindow::on_wave_type_currentIndexChanged(int index)
{
    if(index==0){
        ui->wave_setting->setCurrentIndex(0);
        ui->wave_save->show();
    }else if(index==1){
        ui->wave_setting->setCurrentIndex(1);
        ui->wave_number_l->setText("临近点个数");
        ui->wave_zoom_l->setText("标准差倍数");
        ui->wave_save->show();
    }else if(index==2){
        ui->wave_setting->setCurrentIndex(1);
        ui->wave_number_l->setText("邻域点集个数");
        ui->wave_zoom_l->setText("滤波半径");
        ui->wave_save->close();
    }
    wave_setting_change();
}

void VGRibbonWindow::on_wave_direction_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    wave_setting_change();
}

void VGRibbonWindow::on_wave_up_editingFinished()
{
    if(ui->wave_down->text().toDouble()>ui->wave_up->text().toDouble())
    {
        ui->wave_down->setText(ui->wave_up->text());
        QMessageBox::warning(0, "警告","滤波范围下限请小于上限");
    }
    wave_setting_change();
}

void VGRibbonWindow::on_wave_down_editingFinished()
{
    if(ui->wave_down->text().toDouble()>ui->wave_up->text().toDouble())
    {
        ui->wave_up->setText(ui->wave_down->text());
        QMessageBox::warning(0, "警告","滤波范围下限请小于上限");
    }
    wave_setting_change();
}

void VGRibbonWindow::on_wave_number_editingFinished()
{
    wave_setting_change();
}

void VGRibbonWindow::on_wave_zoom_editingFinished()
{
    wave_setting_change();
}


void VGRibbonWindow::on_wave_save_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    wave_setting_change();
}

//裁切
void VGRibbonWindow::on_getcloud_general_clicked()
{
    ui->getcloud_setting->setCurrentIndex(0);
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->getcloud_cloud->count()>0){
        int raw_cloud=ui->getcloud_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->getcloud_ROI->setEnabled(false);
                ui->getcloud_preview->setEnabled(false);
            }else{
                ui->getcloud_ROI->setEnabled(true);
                ui->getcloud_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
            }
        }else
            ui->getcloud_preview->setEnabled(false);
    }else{
        ui->getcloud_preview->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_getcloud_ROI_clicked()
{
    on_getcloud_general_clicked();
    ui->getcloud_ROI->setEnabled(false);
    ui->getcloud_ROI_setting->show();
    double p_x=ui->getcloud_x->text().toDouble();
    double p_y=ui->getcloud_y->text().toDouble();
    double p_z=ui->getcloud_z->text().toDouble();
    double l=ui->getcloud_l->text().toDouble();
    double w=ui->getcloud_w->text().toDouble();
    double h=ui->getcloud_h->text().toDouble();
    if(l==0||w==0||h==0){
        p_x=0;
        p_y=0;
        p_z=0;
        l=20;
        w=20;
        h=20;
        ui->getcloud_x->setText("0");
        ui->getcloud_y->setText("0");
        ui->getcloud_z->setText("0");
        ui->getcloud_l->setText("20");
        ui->getcloud_w->setText("20");
        ui->getcloud_h->setText("20");
        start.setPoint(0,0,0);
        end.setPoint(20,20,20);
    }
    ROI_add_3D(p_x,p_y,p_z,l,w,h);
    getcloud_ROI_change();
}


void VGRibbonWindow::on_getcloud_preview_clicked()
{
    ui->getcloud_ROI->setEnabled(true);
    ui->getcloud_setting->setCurrentIndex(0);
    int raw_cloud=ui->getcloud_cloud->currentText().toInt()-1;
    bool in=ui->getcloud_in->isChecked();
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Cutcloud_3D *Cutcloud=new YZVision::Cutcloud_3D();
    YZVision::Cutcloud_3D::InputParam input= YZVision::Cutcloud_3D::InputParam();
    YZVision::Cutcloud_3D::OutputParam output= YZVision::Cutcloud_3D::OutputParam();
    input.inputcloud=&cloudarrary[raw_cloud];
    input.x_0=in;
    input.m_StartPoint=start;
    input.m_EndPoint=end;
    result=Cutcloud->cutcloud(input,&output);
    cloudarrary[c_row]=output.outputcloud;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        qDebug()<<cloudarrary[c_row][z].x<<" "<<cloudarrary[c_row][z].y<<" "<<cloudarrary[c_row][z].z;
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::getcloud_setting_change()
{
    int in;
    if(ui->getcloud_in->isChecked())
        in=1;
    else
        in=0;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->getcloud_cloud->currentText()+","+
                  "in="+QString::number(in));
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::getcloud_ROI_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    double* xrange = mouseStyle->a->GetXRange();
    double* yrange = mouseStyle->a->GetYRange();
    double* zrange = mouseStyle->a->GetZRange();
    start.setPoint(xrange[0],yrange[0],zrange[0]);
    end.setPoint(xrange[1],yrange[1],zrange[1]);
    item->setText(ui->getcloud_x->text()+","+
                  ui->getcloud_y->text()+","+
                  ui->getcloud_z->text()+","+
                  ui->getcloud_l->text()+","+
                  ui->getcloud_w->text()+","+
                  ui->getcloud_h->text()+","+
                  QString::number(xrange[0])+","+
                  QString::number(yrange[0])+","+
                  QString::number(zrange[0])+","+
                  QString::number(xrange[1])+","+
                  QString::number(yrange[1])+","+
                  QString::number(zrange[1]));
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_getcloud_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_getcloud_general_clicked();
        int raw_cloud=ui->getcloud_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        getcloud_setting_change();
    }
}

void VGRibbonWindow::on_getcloud_in_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    getcloud_setting_change();
}

void VGRibbonWindow::on_getcloud_x_editingFinished()
{
    on_getcloud_general_clicked();
    on_getcloud_ROI_clicked();
    getcloud_ROI_change();
}

void VGRibbonWindow::on_getcloud_y_editingFinished()
{
    on_getcloud_general_clicked();
    on_getcloud_ROI_clicked();
    getcloud_ROI_change();
}

void VGRibbonWindow::on_getcloud_z_editingFinished()
{
    on_getcloud_general_clicked();
    on_getcloud_ROI_clicked();
    getcloud_ROI_change();
}

void VGRibbonWindow::on_getcloud_l_editingFinished()
{
    on_getcloud_general_clicked();
    on_getcloud_ROI_clicked();
    getcloud_ROI_change();
}

void VGRibbonWindow::on_getcloud_w_editingFinished()
{
    on_getcloud_general_clicked();
    on_getcloud_ROI_clicked();
    getcloud_ROI_change();
}

void VGRibbonWindow::on_getcloud_h_editingFinished()
{
    on_getcloud_general_clicked();
    on_getcloud_ROI_clicked();
    getcloud_ROI_change();
}

//拟合圆柱
void VGRibbonWindow::on_cylinderSegment_general_clicked()
{
    ui->cylinderSegment_setting->setCurrentIndex(0);
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->cylinderSegment_cloud->count()>0){
        int raw_cloud=ui->cylinderSegment_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->cylinderSegment_ROI->setEnabled(false);
                ui->cylinderSegment_preview->setEnabled(false);
            }else{
                ui->cylinderSegment_ROI->setEnabled(true);
                ui->cylinderSegment_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
            }
        }else
            ui->cylinderSegment_preview->setEnabled(false);
    }else{
        ui->cylinderSegment_preview->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_cylinderSegment_ROI_clicked()
{
    on_cylinderSegment_general_clicked();
    ui->cylinderSegment_ROI->setEnabled(false);
    ui->cylinderSegment_ROI_setting->show();
    double p_x=ui->cylinderSegment_x->text().toDouble();
    double p_y=ui->cylinderSegment_y->text().toDouble();
    double p_z=ui->cylinderSegment_z->text().toDouble();
    double l=ui->cylinderSegment_l->text().toDouble();
    double w=ui->cylinderSegment_w->text().toDouble();
    double h=ui->cylinderSegment_h->text().toDouble();
    if(l==0||w==0||h==0){
        p_x=0;
        p_y=0;
        p_z=0;
        l=20;
        w=20;
        h=20;
        ui->cylinderSegment_x->setText("0");
        ui->cylinderSegment_y->setText("0");
        ui->cylinderSegment_z->setText("0");
        ui->cylinderSegment_l->setText("20");
        ui->cylinderSegment_w->setText("20");
        ui->cylinderSegment_h->setText("20");
        start.setPoint(0,0,0);
        end.setPoint(20,20,20);
    }
    ROI_add_3D(p_x,p_y,p_z,l,w,h);
    cylinderSegment_ROI_change();
}

void VGRibbonWindow::on_cylinderSegment_preview_clicked()
{
    ui->cylinderSegment_ROI->setEnabled(true);
    ui->cylinderSegment_setting->setCurrentIndex(0);
    int raw_cloud=ui->cylinderSegment_cloud->currentText().toInt()-1;
    int result;
    std::vector<int> index;
    std::vector<float> Coeffients;
    QElapsedTimer  mstimer;
    mstimer.start();
    YZVision::Segmentation* segmentation = NULL;
    YZVision::CylinderSegment* p_cylinderSeg = new YZVision::CylinderSegment();
    segmentation = p_cylinderSeg;
    YZVision::Segmentation::InputParam input_Param;
    YZVision::Segmentation::OutputParam output_Param;
    input_Param.inputCloud = &cloudarrary[raw_cloud];
    input_Param.m_StartPoint = start;
    input_Param.m_EndPoint = end;
    input_Param.distance_Threshold = 0.1;
    input_Param.distance_weight = 0.1;
    input_Param.k_nearest_neighbors = 10;
    input_Param.max_iteratios = 20;

    result = segmentation->segment(input_Param, &output_Param);
    Coeffients=output_Param.modelCoeffients;
    index=output_Param.modelInliers;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);

    cloudarrary[c_row]=cloudarrary[raw_cloud];

    std::vector<std::vector <float>> t;
    std::vector <float> t_a;
    for(int x=0;x<Coeffients.size();x++){
        t_a.push_back(Coeffients[x]);
        qDebug()<<Coeffients[x];
    }
    t.push_back(t_a);
    res[c_row]=t;

    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();

    double radius1 = res[c_row][0][6];
    double center1[3] = {res[c_row][0][0],res[c_row][0][1],res[c_row][0][2]};
    vtkSmartPointer<vtkCylinderSource> cylinder = vtkSmartPointer<vtkCylinderSource>::New();
    cylinder->SetCapping(false);
    cylinder->SetRadius(radius1);
    cylinder->SetCenter(center1);
    cylinder->SetHeight(1000);
    // Set the number of facets used to represent the cone.
    cylinder->SetResolution(100);
    cylinder->Update();
    vtkSmartPointer<vtkPolyDataMapper> cylinderMapper1 = vtkSmartPointer<vtkPolyDataMapper>::New();
    cylinderMapper1->SetInputData(cylinder->GetOutput());
    vtkSmartPointer<vtkActor> cylinderActor1 = vtkSmartPointer<vtkActor>::New();
    cylinderActor1->SetMapper(cylinderMapper1);
    cylinderActor1->GetProperty()->SetColor(0.46, 0.46, 0.93);
    cylinderActor1->GetProperty()->SetOpacity(0.6);
    renderer->AddActor(cylinderActor1);
}

void VGRibbonWindow::cylinderSegment_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->cylinderSegment_cloud->currentText());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::cylinderSegment_ROI_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    double* xrange = mouseStyle->a->GetXRange();
    double* yrange = mouseStyle->a->GetYRange();
    double* zrange = mouseStyle->a->GetZRange();
    start.setPoint(xrange[0],yrange[0],zrange[0]);
    end.setPoint(xrange[1],yrange[1],zrange[1]);
    item->setText(ui->cylinderSegment_x->text()+","+
                  ui->cylinderSegment_y->text()+","+
                  ui->cylinderSegment_z->text()+","+
                  ui->cylinderSegment_l->text()+","+
                  ui->cylinderSegment_w->text()+","+
                  ui->cylinderSegment_h->text()+","+
                  QString::number(xrange[0])+","+
                  QString::number(yrange[0])+","+
                  QString::number(zrange[0])+","+
                  QString::number(xrange[1])+","+
                  QString::number(yrange[1])+","+
                  QString::number(zrange[1]));
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_cylinderSegment_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_cylinderSegment_general_clicked();
        int raw_cloud=ui->cylinderSegment_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        cylinderSegment_setting_change();
    }
}

void VGRibbonWindow::on_cylinderSegment_x_editingFinished()
{
    on_cylinderSegment_general_clicked();
    on_cylinderSegment_ROI_clicked();
    cylinderSegment_ROI_change();
}

void VGRibbonWindow::on_cylinderSegment_y_editingFinished()
{
    on_cylinderSegment_general_clicked();
    on_cylinderSegment_ROI_clicked();
    cylinderSegment_ROI_change();
}

void VGRibbonWindow::on_cylinderSegment_z_editingFinished()
{
    on_cylinderSegment_general_clicked();
    on_cylinderSegment_ROI_clicked();
    cylinderSegment_ROI_change();
}

void VGRibbonWindow::on_cylinderSegment_l_editingFinished()
{
    on_cylinderSegment_general_clicked();
    on_cylinderSegment_ROI_clicked();
    cylinderSegment_ROI_change();
}

void VGRibbonWindow::on_cylinderSegment_w_editingFinished()
{
    on_cylinderSegment_general_clicked();
    on_cylinderSegment_ROI_clicked();
    cylinderSegment_ROI_change();
}

void VGRibbonWindow::on_cylinderSegment_h_editingFinished()
{
    on_cylinderSegment_general_clicked();
    on_cylinderSegment_ROI_clicked();
    cylinderSegment_ROI_change();
}

//曲面展开
void VGRibbonWindow::on_cylinderToPlane_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    int raw_cloud;
    if(ui->cylinderToPlane_cloud->count()>0){
        raw_cloud=ui->cylinderToPlane_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->cylinderToPlane_preview->setEnabled(false);
            }else{
                ui->cylinderToPlane_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
                opencloud();
                if(ui->ordertable->item(raw_cloud,3)->text()!="拟合圆柱")
                    ui->cylinderToPlane_preview->setEnabled(false);
                else{
                    ui->cylinderToPlane_preview->setEnabled(true);

                    double radius1 = res[raw_cloud][0][6];
                    double center1[3] = {res[raw_cloud][0][0],res[raw_cloud][0][1],res[raw_cloud][0][2]};
                    vtkSmartPointer<vtkCylinderSource> cylinder = vtkSmartPointer<vtkCylinderSource>::New();
                    cylinder->SetCapping(false);
                    cylinder->SetRadius(radius1);
                    cylinder->SetCenter(center1);
                    cylinder->SetHeight(100);
                    // Set the number of facets used to represent the cone.
                    cylinder->SetResolution(100);
                    cylinder->Update();
                    vtkSmartPointer<vtkPolyDataMapper> cylinderMapper1 = vtkSmartPointer<vtkPolyDataMapper>::New();
                    cylinderMapper1->SetInputData(cylinder->GetOutput());
                    vtkSmartPointer<vtkActor> cylinderActor1 = vtkSmartPointer<vtkActor>::New();
                    cylinderActor1->SetMapper(cylinderMapper1);
                    renderer->AddActor(cylinderActor1);
                }
            }
        }else
            ui->cylinderToPlane_preview->setEnabled(false);
    }else{
        ui->cylinderToPlane_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_cylinderToPlane_preview_clicked()
{
    int raw_cloud=ui->cylinderToPlane_cloud->currentText().toInt()-1;
    YZVision::vPointsXYZ out;
//    YZ3DVision::GEO_CYLINDER para_cylinder;
//    para_cylinder.R = res[raw_cloud][0][6];
//    para_cylinder.Axial = YZ3DVision::AXIS::AXIS_Y;
//    para_cylinder.RadialTran = YZ3DVision::AXIS::AXIS_X;
//    para_cylinder.RadialLong = YZ3DVision::AXIS::AXIS_Z;
//    para_cylinder.CenterTran = res[raw_cloud][0][0];
//    para_cylinder.CenterLong = res[raw_cloud][0][2];
    QElapsedTimer  mstimer;
    mstimer.start();
//    YZ3DVision::Algorithm* p_algorithm_plane = new YZ3DVision::Algorithm();
//    p_algorithm_plane->cylinderToPlane(&cloudarrary[raw_cloud],para_cylinder,&out);
    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    cloudarrary[c_row]=out;
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::cylinderToPlane_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->cylinderToPlane_cloud->currentText());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_cylinderToPlane_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        int raw_cloud=ui->cylinderToPlane_cloud->currentText().toInt()-1;
        on_cylinderToPlane_general_clicked();
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        cylinderToPlane_setting_change();
    }
}

// 锚定
void VGRibbonWindow::on_Anchor_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->Anchor_cloud->count()>0){
        int raw_cloud=ui->Anchor_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->Anchor_preview->setEnabled(false);
            }else{
                ui->Anchor_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
                opencloud();
                double x,y,z;
                x=ui->Anchor_x->text().toDouble();
                y=ui->Anchor_y->text().toDouble();
                z=ui->Anchor_z->text().toDouble();
                origin_add_3D(x,y,z);
            }
        }else
            ui->Anchor_preview->setEnabled(false);
    }else{
        ui->Anchor_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_Anchor_preview_clicked()
{
    int raw=ui->Anchor_cloud->currentText().toInt()-1;
    double x,y,z;
    x=ui->Anchor_x->text().toDouble();
    y=ui->Anchor_y->text().toDouble();
    z=ui->Anchor_z->text().toDouble();
    YZVision::PointXYZ point;
    point.setPoint(x,y,z);
    int result=0;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Transformation* transformation = NULL;
    YZVision::MovePointCloud* p_movePointCloud = new YZVision::MovePointCloud();
    transformation = p_movePointCloud;
    YZVision::Transformation::InputParam input_Param;
    YZVision::Transformation::OutputParam output_Param;
    input_Param.input_cloud=&cloudarrary[raw];
    input_Param.anchor_point=point;
    input_Param.angle_xyz[0] = 0;
    input_Param.angle_xyz[1] = 0;
    input_Param.angle_xyz[2] = 0;
    result = transformation->transform(input_Param, &output_Param);
    cloudarrary[c_row]=output_Param.trans_point_cloud;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::Anchor_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->Anchor_cloud->currentText());
    ui->ordertable->setItem(c_row,4,item->clone());
    QTableWidgetItem *roi = new QTableWidgetItem;
    roi->setText(ui->Anchor_x->text()+","+
                 ui->Anchor_y->text()+","+
                 ui->Anchor_z->text());
    ui->ordertable->setItem(c_row,9,roi->clone());
}

void VGRibbonWindow::on_Anchor_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        ui->Anchor_x->setText("0");
        ui->Anchor_y->setText("0");
        ui->Anchor_z->setText("0");
        int raw_cloud=ui->Anchor_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());

        on_Anchor_general_clicked();
        Anchor_setting_change();
    }
}

void VGRibbonWindow::on_Anchor_x_editingFinished()
{
    if(ui->Anchor_x->text()=="")
        ui->Anchor_x->setText("0");
    on_Anchor_general_clicked();
    Anchor_setting_change();
}

void VGRibbonWindow::on_Anchor_y_editingFinished()
{
    if(ui->Anchor_y->text()=="")
        ui->Anchor_y->setText("0");
    on_Anchor_general_clicked();
    Anchor_setting_change();
}

void VGRibbonWindow::on_Anchor_z_editingFinished()
{
    if(ui->Anchor_z->text()=="")
        ui->Anchor_z->setText("0");
    on_Anchor_general_clicked();
    Anchor_setting_change();
}

//矫正
void VGRibbonWindow::on_correct_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->correct_cloud->count()>0){
        int raw_cloud=ui->correct_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->correct_preview->setEnabled(false);
            }else{
                ui->correct_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
                opencloud();
                if(ui->ordertable->item(raw_cloud,3)->text()=="找线"){
                    if(res[raw_cloud].size()>0){
                        highLightline(raw_cloud);
                    }
                }
            }
        }else
            ui->correct_preview->setEnabled(false);
    }else{
        ui->correct_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_correct_preview_clicked()
{
    int raw=ui->correct_cloud->currentText().toInt()-1;
    float xa;
    float ya;
    float za;
    bool line=ui->correct_line->isChecked();
    if(line){
        xa=res[raw][1][0];
        ya=res[raw][1][1];
        za=res[raw][1][2];
    }else{
        double x,y,z;
        x=ui->correct_x->text().toDouble();
        y=ui->correct_y->text().toDouble();
        z=ui->correct_z->text().toDouble();
        xa=x/180*M_PI;
        ya=y/180*M_PI;
        za=z/180*M_PI;
    }
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Transformation* transformation = NULL;
    YZVision::RotatePointCloud* p_rotatePointCloud = new YZVision::RotatePointCloud();
    transformation = p_rotatePointCloud;
    YZVision::Transformation::InputParam input_Param;
    YZVision::Transformation::OutputParam output_Param;
    input_Param.input_cloud=&cloudarrary[raw];
    input_Param.angle_xyz[0] = xa;
    input_Param.angle_xyz[1] = ya;
    input_Param.angle_xyz[2] = za;
    result = transformation->transform(input_Param, &output_Param);
    cloudarrary[c_row]=output_Param.trans_point_cloud;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();

}

void VGRibbonWindow::correct_setting_change()
{
    QString line;
    if(ui->correct_line->isChecked())
        line="1";
    else
        line="0";
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->correct_cloud->currentText()+","+
                  "line="+line);
    ui->ordertable->setItem(c_row,4,item->clone());
    QTableWidgetItem *roi = new QTableWidgetItem;
    roi->setText(ui->correct_x->text()+","+
                 ui->correct_y->text()+","+
                 ui->correct_z->text());
    ui->ordertable->setItem(c_row,9,roi->clone());
}

void VGRibbonWindow::on_correct_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        int raw_cloud=ui->correct_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        on_correct_general_clicked();
        if(ui->ordertable->item(raw_cloud,3)->text()=="找线")
            ui->correct_line->show();
        else{
            ui->correct_line->setChecked(false);
            ui->correct_line->close();
        }
        correct_setting_change();
    }
}

void VGRibbonWindow::on_correct_line_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    if(ui->correct_line->isChecked()){
        ui->correct_x->setEnabled(false);
        ui->correct_y->setEnabled(false);
        ui->correct_z->setEnabled(false);
    }else{
        ui->correct_x->setEnabled(true);
        ui->correct_y->setEnabled(true);
        ui->correct_z->setEnabled(true);
    }
    correct_setting_change();
}

void VGRibbonWindow::on_correct_x_editingFinished()
{
    if(ui->correct_x->text()=="")
        ui->correct_x->setText("0");
    correct_setting_change();
}

void VGRibbonWindow::on_correct_y_editingFinished()
{
    if(ui->correct_y->text()=="")
        ui->correct_y->setText("0");
    correct_setting_change();
}

void VGRibbonWindow::on_correct_z_editingFinished()
{
    if(ui->correct_z->text()=="")
        ui->correct_z->setText("0");
    correct_setting_change();
}

//零平面
void VGRibbonWindow::on_zeroplane_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->zeroplane_cloud->count()>0){
        int raw_cloud=ui->zeroplane_cloud->currentText().toInt()-1;
        if(cloudarrary[raw_cloud].size()>0){
            openrawcloud(cloudarrary[raw_cloud]);
            int raw1=0,raw2=0;
            raw1=ui->zeroplane_cloud_plane_1->currentText().toInt()-1;
            raw2=ui->zeroplane_cloud_plane_2->currentText().toInt()-1;
            if(ui->ordertable->item(raw1,3)->text()=="裁切"&&
                    ui->ordertable->item(raw2,3)->text()=="裁切"){
                int r1,r2;
                QStringList order_s1=ui->ordertable->item(raw1,4)->text().split(",");
                QStringList s_data1=order_s1.at(0).split("=");
                r1=s_data1.at(1).toInt()-1;
                QStringList order_s2=ui->ordertable->item(raw2,4)->text().split(",");
                QStringList s_data2=order_s2.at(0).split("=");
                r2=s_data2.at(1).toInt()-1;
                if(r1==raw_cloud&&r2==raw_cloud){
                    highLight(cloudarrary[raw1]);
                    highLight(cloudarrary[raw2]);
                    ui->zeroplane_preview->setEnabled(true);
                    ui->zeroplane_cloud_plane_1->setEnabled(true);
                    ui->zeroplane_cloud_plane_2->setEnabled(true);
                }else{
                    ui->zeroplane_preview->setEnabled(false);
                    ui->zeroplane_cloud_plane_1->setEnabled(true);
                    ui->zeroplane_cloud_plane_2->setEnabled(true);
                }
            }else{
                ui->zeroplane_preview->setEnabled(false);
                ui->zeroplane_cloud_plane_1->setEnabled(true);
                ui->zeroplane_cloud_plane_2->setEnabled(true);
            }
        }else{
            ui->zeroplane_preview->setEnabled(false);
            ui->zeroplane_cloud_plane_1->setEnabled(false);
            ui->zeroplane_cloud_plane_2->setEnabled(false);
        }
    }else{
        ui->zeroplane_preview->setEnabled(false);
        ui->zeroplane_cloud_plane_1->setEnabled(false);
        ui->zeroplane_cloud_plane_2->setEnabled(false);
    }
}

void VGRibbonWindow::on_zeroplane_preview_clicked()
{
    int raw_cloud=ui->zeroplane_cloud->currentText().toInt()-1;
    int raw1,raw2;
    raw1=ui->zeroplane_cloud_plane_1->currentText().toInt()-1;
    raw2=ui->zeroplane_cloud_plane_2->currentText().toInt()-1;
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Cloudzeroplane_3D zeroplane;
    YZVision::Cloudzeroplane_3D::InputParam input= YZVision::Cloudzeroplane_3D::InputParam();
    YZVision::Cloudzeroplane_3D::OutputParam output= YZVision::Cloudzeroplane_3D::OutputParam();
    input.inputcloud=&cloudarrary[raw_cloud];
    input.inputcloud_1=&cloudarrary[raw1];
    input.inputcloud_2=&cloudarrary[raw2];
    result=zeroplane.cloudzeroplane(input,&output);
    cloudarrary[c_row]=output.outputcloud;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);

    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::zeroplane_settingchange()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->zeroplane_cloud->currentText()+","+
                  "plane1="+ui->zeroplane_cloud_plane_1->currentText()+","+
                  "plane2="+ui->zeroplane_cloud_plane_2->currentText());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_zeroplane_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_zeroplane_general_clicked();
        zeroplane_settingchange();
        int raw_cloud=ui->zeroplane_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());

    }
}

void VGRibbonWindow::on_zeroplane_cloud_plane_1_currentIndexChanged(int index)
{
    if(index>=0){
        on_zeroplane_general_clicked();
        zeroplane_settingchange();
    }
}

void VGRibbonWindow::on_zeroplane_cloud_plane_2_currentIndexChanged(int index)
{
    if(index>=0){
        on_zeroplane_general_clicked();
        zeroplane_settingchange();
    }
}

//轮廓点云
void VGRibbonWindow::on_Cloudoutline_general_clicked()
{
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->Cloudoutline_cloud->count()>0){
        int raw_cloud=ui->Cloudoutline_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->Cloudoutline_preview->setEnabled(false);
            }else{
                ui->Cloudoutline_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
                opencloud();
                if(ui->ordertable->item(raw_cloud,3)->text()=="找线"){
                    if(res[raw_cloud].size()>0){
                        highLightline(raw_cloud);
                    }
                }
            }
        }else
            ui->Cloudoutline_preview->setEnabled(false);
    }else{
        ui->Cloudoutline_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_Cloudoutline_preview_clicked()
{
    int raw=ui->Cloudoutline_cloud->currentText().toInt()-1;
    double y=ui->Cloudoutline_y->text().toDouble();
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Cloudoutline_3D Cloudoutline;
    YZVision::Cloudoutline_3D::InputParam input= YZVision::Cloudoutline_3D::InputParam();
    YZVision::Cloudoutline_3D::OutputParam output= YZVision::Cloudoutline_3D::OutputParam();

    input.inputcloud=&cloudarrary[raw];
    input.y_0=y;
    result=Cloudoutline.outlinearea(input,&output);

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);

    cloudarrary[c_row]=output.outputcloud;
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::Cloudoutline_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->Cloudoutline_cloud->currentText()+","+
                  "y="+ui->Cloudoutline_y->text());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_Cloudoutline_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        int raw_cloud=ui->Cloudoutline_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        on_Cloudoutline_general_clicked();
        Cloudoutline_setting_change();
    }
}

void VGRibbonWindow::on_Cloudoutline_y_editingFinished()
{
    Cloudoutline_setting_change();
}

//点到点
void VGRibbonWindow::on_point_point_general_clicked()
{
    ui->point_point_result->setText("");
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->point_point_cloud->count()>0){
        int raw_cloud=ui->point_point_cloud->currentText().toInt()-1;
        int raw_cloud2=ui->point_point_cloud_2->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->point_point_preview->setEnabled(false);
            }else{
                openrawcloud(cloudarrary[raw_cloud]);
                if((ui->ordertable->item(raw_cloud,3)->text()=="找边缘点"||
                   ui->ordertable->item(raw_cloud,3)->text()=="找拐点"||
                   ui->ordertable->item(raw_cloud,3)->text()=="找质心")&&
                   (ui->ordertable->item(raw_cloud2,3)->text()=="找边缘点"||
                   ui->ordertable->item(raw_cloud2,3)->text()=="找拐点"||
                   ui->ordertable->item(raw_cloud2,3)->text()=="找质心")){
                    ui->point_point_preview->setEnabled(true);
                    YZVision::PointXYZ a,b;
                    double cx=0,cy=0,cz=0;
                    YZVision::vPointsXYZ p1;
                    YZVision::vPointsXYZ p2;
                    for(long z=0;z<res[raw_cloud].size();z++){
                        cx+=res[raw_cloud][z][0];
                        cy+=res[raw_cloud][z][1];
                        cz+=res[raw_cloud][z][2];
                        YZVision::PointXYZ p;
                        p.setPoint(res[raw_cloud][z][0],res[raw_cloud][z][1],res[raw_cloud][z][2]);
                        p1.push_back(p);
                    }
                    cx=cx/res[raw_cloud].size();
                    cy=cy/res[raw_cloud].size();
                    cz=cz/res[raw_cloud].size();
                    a.setPoint(cx,cy,cz);
                    highLight(p1);

                    for(long x=0;x<res[raw_cloud2].size();x++){
                        cx+=res[raw_cloud2][x][0];
                        cy+=res[raw_cloud2][x][1];
                        cz+=res[raw_cloud2][x][2];
                        YZVision::PointXYZ p;
                        p.setPoint(res[raw_cloud2][x][0],res[raw_cloud2][x][1],res[raw_cloud2][x][2]);
                        p2.push_back(p);
                    }
                    cx=cx/res[raw_cloud2].size();
                    cy=cy/res[raw_cloud2].size();
                    cz=cz/res[raw_cloud2].size();

                    b.setPoint(cx,cy,cz);
                    highLight(p2);
                }else{
                    ui->point_point_preview->setEnabled(false);
                }
            }
        }else
            ui->point_point_preview->setEnabled(false);
    }else{
        ui->point_point_preview->setEnabled(false);
    }

}

void VGRibbonWindow::on_point_point_preview_clicked()
{
    int raw_cloud1=ui->point_point_cloud->currentText().toInt()-1;
    int raw_cloud2=ui->point_point_cloud_2->currentText().toInt()-1;
    YZVision::PointXYZ a,b;
    double cx=0,cy=0,cz=0;
    std::vector <float> ra,rb;
    for(long z=0;z<res[raw_cloud1].size();z++){
        cx+=res[raw_cloud1][z][0];
        cy+=res[raw_cloud1][z][1];
        cz+=res[raw_cloud1][z][2];
        ra.push_back(res[raw_cloud1][z][0]);
        ra.push_back(res[raw_cloud1][z][1]);
        ra.push_back(res[raw_cloud1][z][2]);
    }
    cx=cx/res[raw_cloud1].size();
    cy=cy/res[raw_cloud1].size();
    cz=cz/res[raw_cloud1].size();
    a.setPoint(cx,cy,cz);

    for(long x=0;x<res[raw_cloud2].size();x++){
        cx+=res[raw_cloud2][x][0];
        cy+=res[raw_cloud2][x][1];
        cz+=res[raw_cloud2][x][2];
        rb.push_back(res[raw_cloud2][x][0]);
        rb.push_back(res[raw_cloud2][x][1]);
        rb.push_back(res[raw_cloud2][x][2]);
    }
    cx=cx/res[raw_cloud2].size();
    cy=cy/res[raw_cloud2].size();
    cz=cz/res[raw_cloud2].size();

    b.setPoint(cx,cy,cz);
    QElapsedTimer  mstimer;
    mstimer.start();
    double result=0;
    int resu;
    YZVision::Measurement* measurement = NULL;
    YZVision::PointToPointDis_3D* p_p2pDis = new YZVision::PointToPointDis_3D();
    measurement = p_p2pDis;
    YZVision::Measurement::InputParam input_Param;
    YZVision::Measurement::OutputParam output_Param;
    input_Param.pt1=a;
    input_Param.pt2=b;
    resu=measurement->measure(input_Param, &output_Param);
    result=output_Param.distance;
    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);

    ui->point_point_result->setText("距离为"+QString::number(result));
    setVtkLine(a,b);

    std::vector<std::vector <float>> t;

    t.push_back(ra);

    t.push_back(rb);

    std::vector <float> t_a;
    t_a.push_back(a.x);
    t_a.push_back(a.y);
    t_a.push_back(a.z);
    t.push_back(t_a);

    std::vector <float> t_b;
    t_b.push_back(b.x);
    t_b.push_back(b.y);
    t_b.push_back(b.z);
    t.push_back(t_b);

    res[c_row]=t;
}

void VGRibbonWindow::point_point_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud1="+ui->point_point_cloud->currentText()+","+
                  "raw_cloud2="+ui->point_point_cloud_2->currentText());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_point_point_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_point_point_general_clicked();
        int raw_cloud=ui->point_point_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        point_point_setting_change();
    }
}

void VGRibbonWindow::on_point_point_cloud_2_currentIndexChanged(int index)
{
    if(index>=0){
        on_point_point_general_clicked();
        point_point_setting_change();
    }
}

//点到线
void VGRibbonWindow::on_point_line_general_clicked()
{
    ui->point_line_result->setText("");
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->point_line_cloud->count()>0){
        int raw_cloud=ui->point_line_cloud->currentText().toInt()-1;
        int raw_cloud2=ui->point_line_cloud_2->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->point_line_preview->setEnabled(false);
            }else{
                openrawcloud(cloudarrary[raw_cloud]);
                if((ui->ordertable->item(raw_cloud,3)->text()=="找边缘点"||
                   ui->ordertable->item(raw_cloud,3)->text()=="找拐点"||
                   ui->ordertable->item(raw_cloud,3)->text()=="找质心")&&
                   (ui->ordertable->item(raw_cloud2,3)->text()=="找线")){
                    ui->point_line_preview->setEnabled(true);
                    YZVision::PointXYZ a;
                    double cx=0,cy=0,cz=0;
                    YZVision::vPointsXYZ p1;
                    for(long z=0;z<res[raw_cloud].size();z++){
                        cx+=res[raw_cloud][z][0];
                        cy+=res[raw_cloud][z][1];
                        cz+=res[raw_cloud][z][2];
                        YZVision::PointXYZ p;
                        p.setPoint(res[raw_cloud][z][0],res[raw_cloud][z][1],res[raw_cloud][z][2]);
                        p1.push_back(p);
                    }
                    cx=cx/res[raw_cloud].size();
                    cy=cy/res[raw_cloud].size();
                    cz=cz/res[raw_cloud].size();
                    a.setPoint(cx,cy,cz);
                    highLight(p1);

                    highLightline(raw_cloud2);
                }else{
                    ui->point_line_preview->setEnabled(false);
                }
            }
        }else
            ui->point_line_preview->setEnabled(false);
    }else{
        ui->point_line_preview->setEnabled(false);
    }

}

void VGRibbonWindow::on_point_line_preview_clicked()
{
    int raw_cloud1=ui->point_line_cloud->currentText().toInt()-1;
    int raw_cloud2=ui->point_line_cloud_2->currentText().toInt()-1;
    YZVision::PointXYZ a;
    std::vector<float> b;
    std::vector <float> ra;
    for(int i=0;i<res[raw_cloud2][0].size();i++)
        b.push_back(res[raw_cloud2][0][i]);
    double cx=0,cy=0,cz=0;
    for(long z=0;z<res[raw_cloud1].size();z++){
        cx+=res[raw_cloud1][z][0];
        cy+=res[raw_cloud1][z][1];
        cz+=res[raw_cloud1][z][2];
        ra.push_back(res[raw_cloud1][z][0]);
        ra.push_back(res[raw_cloud1][z][1]);
        ra.push_back(res[raw_cloud1][z][2]);
    }
    cx=cx/res[raw_cloud1].size();
    cy=cy/res[raw_cloud1].size();
    cz=cz/res[raw_cloud1].size();
    a.setPoint(cx,cy,cz);

    QElapsedTimer  mstimer;
    mstimer.start();

    double result=0;
    int resu;
    YZVision::Measurement* measurement = NULL;
    YZVision::PointToLineDis_3D* p_p2lDis = new YZVision::PointToLineDis_3D();
    measurement = p_p2lDis;
    YZVision::Measurement::InputParam input_Param;
    YZVision::Measurement::OutputParam output_Param;
    input_Param.pt_out_line=a;
    input_Param.modelCoeffients=b;
    resu=measurement->measure(input_Param, &output_Param);
    result=output_Param.distance;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);

    ui->point_line_result->setText("距离为"+QString::number(result));

    std::vector<std::vector <float>> t;

    t.push_back(ra);

    std::vector <float> r_b;
    r_b.push_back(raw_cloud2);
    t.push_back(r_b);

    std::vector <float> t_a;
    t_a.push_back(a.x);
    t_a.push_back(a.y);
    t_a.push_back(a.z);
    t.push_back(t_a);

//    std::vector <float> t_b;
//    t_b.push_back(bp.x);
//    t_b.push_back(bp.y);
//    t_b.push_back(bp.z);
//    t.push_back(t_b);

    res[c_row]=t;
}

void VGRibbonWindow::point_line_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud1="+ui->point_line_cloud->currentText()+","+
                  "raw_cloud2="+ui->point_line_cloud_2->currentText());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_point_line_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_point_line_general_clicked();
        int raw_cloud=ui->point_line_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        point_line_setting_change();
    }
}

void VGRibbonWindow::on_point_line_cloud_2_currentIndexChanged(int index)
{
    if(index>=0){
        on_point_line_general_clicked();
        point_line_setting_change();
    }
}

//点到面
void VGRibbonWindow::on_point_plane_general_clicked()
{
    ui->point_plane_result->setText("");
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->point_plane_cloud->count()>0){
        int raw_cloud=ui->point_plane_cloud->currentText().toInt()-1;
        int raw_cloud2=ui->point_plane_cloud_2->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->point_plane_preview->setEnabled(false);
            }else{
                if((ui->ordertable->item(raw_cloud,3)->text()=="找边缘点"||
                   ui->ordertable->item(raw_cloud,3)->text()=="找拐点"||
                   ui->ordertable->item(raw_cloud,3)->text()=="找质心")&&
                   (ui->ordertable->item(raw_cloud2,3)->text()=="找面")){
                    ui->point_plane_preview->setEnabled(true);

                    YZVision::PointXYZ a;
                    YZVision::vPointsXYZ p1;
                    double cx=0,cy=0,cz=0;
                    for(long z=0;z<res[raw_cloud].size();z++){
                        cx+=res[raw_cloud][z][0];
                        cy+=res[raw_cloud][z][1];
                        cz+=res[raw_cloud][z][2];
                        YZVision::PointXYZ p;
                        p.setPoint(res[raw_cloud][z][0],res[raw_cloud][z][1],res[raw_cloud][z][2]);
                        p1.push_back(p);
                    }
                    cx=cx/res[raw_cloud].size();
                    cy=cy/res[raw_cloud].size();
                    cz=cz/res[raw_cloud].size();
                    a.setPoint(cx,cy,cz);

                    highLight(p1);

                    highLightplane(raw_cloud2);
                }else
                    ui->point_plane_preview->setEnabled(false);

            }
        }else
            ui->point_plane_preview->setEnabled(false);
    }else{
        ui->point_plane_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_point_plane_preview_clicked()
{
    int raw_cloud1=ui->point_plane_cloud->currentText().toInt()-1;
    int raw_cloud2=ui->point_plane_cloud_2->currentText().toInt()-1;
    YZVision::PointXYZ a;
    std::vector<float> b;
    std::vector <float> ra;
    for(int i=0;i<res[raw_cloud2][0].size();i++)
        b.push_back(res[raw_cloud2][0][i]);
    double cx=0,cy=0,cz=0;
    for(long z=0;z<res[raw_cloud1].size();z++){
        cx+=res[raw_cloud1][z][0];
        cy+=res[raw_cloud1][z][1];
        cz+=res[raw_cloud1][z][2];
        ra.push_back(res[raw_cloud1][z][0]);
        ra.push_back(res[raw_cloud1][z][1]);
        ra.push_back(res[raw_cloud1][z][2]);
    }
    cx=cx/res[raw_cloud1].size();
    cy=cy/res[raw_cloud1].size();
    cz=cz/res[raw_cloud1].size();
    a.setPoint(cx,cy,cz);

    QElapsedTimer  mstimer;
    mstimer.start();

    double result=0;
    int resu;
    YZVision::Measurement* measurement = NULL;
    YZVision::PointToPlaneDis_3D* p_p2planeDis = new YZVision::PointToPlaneDis_3D();
    measurement = p_p2planeDis;
    YZVision::Measurement::InputParam input_Param;
    YZVision::Measurement::OutputParam output_Param;
    input_Param.pt_out_line=a;
    input_Param.modelCoeffients=b;
    resu=measurement->measure(input_Param, &output_Param);
    result=output_Param.distance;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);

    ui->point_plane_result->setText("距离为"+QString::number(result));

    std::vector<std::vector <float>> t;

    t.push_back(ra);

    std::vector <float> r_b;
    r_b.push_back(raw_cloud2);
    t.push_back(r_b);

    std::vector <float> t_a;
    t_a.push_back(a.x);
    t_a.push_back(a.y);
    t_a.push_back(a.z);
    t.push_back(t_a);

//    std::vector <float> t_b;
//    t_b.push_back(bp.x);
//    t_b.push_back(bp.y);
//    t_b.push_back(bp.z);
//    t.push_back(t_b);

    res[c_row]=t;
}

void VGRibbonWindow::point_plane_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud1="+ui->point_plane_cloud->currentText()+","+
                  "raw_cloud2="+ui->point_plane_cloud_2->currentText());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_point_plane_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_point_plane_general_clicked();
        int raw_cloud=ui->point_plane_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        point_plane_setting_change();
    }
}

void VGRibbonWindow::on_point_plane_cloud_2_currentIndexChanged(int index)
{
    if(index>=0){
        on_point_plane_general_clicked();
        point_plane_setting_change();
    }
}

//线到线
void VGRibbonWindow::on_line_line_general_clicked()
{
    ui->line_line_result->setText("");
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->line_line_cloud->count()>0){
        int raw_cloud=ui->line_line_cloud->currentText().toInt()-1;
        int raw_cloud2=ui->line_line_cloud_2->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->line_line_preview->setEnabled(false);
            }else{
                openrawcloud(cloudarrary[raw_cloud]);
                if((ui->ordertable->item(raw_cloud,3)->text()=="找线")&&
                   (ui->ordertable->item(raw_cloud2,3)->text()=="找线")){
                    ui->line_line_preview->setEnabled(true);
                    openrawcloud(cloudarrary[raw_cloud]);
                    highLightline(raw_cloud);
                    highLightline(raw_cloud2);
                }else{
                    ui->line_line_preview->setEnabled(false);
                }

            }
        }else
            ui->line_line_preview->setEnabled(false);
    }else{
        ui->line_line_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_line_line_preview_clicked()
{
    int raw_cloud1=ui->line_line_cloud->currentText().toInt()-1;
    int raw_cloud2=ui->line_line_cloud_2->currentText().toInt()-1;
    std::vector<float> a,b;
    YZVision::PointXYZ ap,bp;
    for(int i=0;i<res[raw_cloud1][0].size();i++)
        a.push_back(res[raw_cloud1][0][i]);

    for(int i=0;i<res[raw_cloud2][0].size();i++)
        b.push_back(res[raw_cloud2][0][i]);

    QElapsedTimer  mstimer;
    mstimer.start();

    double result=0;
    int resu;
    YZVision::Measurement* measurement = NULL;
    YZVision::LineToLineDis_3D* p_l2lDis = new YZVision::LineToLineDis_3D();
    measurement = p_l2lDis;
    YZVision::Measurement::InputParam input_Param;
    YZVision::Measurement::OutputParam output_Param;
    input_Param.line1Coeffients=a;
    input_Param.line2Coeffients=b;
    resu=measurement->measure(input_Param, &output_Param);
    result=output_Param.distance;
    ap=output_Param.pt1_on_line;
    bp=output_Param.pt2_on_line;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);

    ui->line_line_result->setText("距离为"+QString::number(result));

    setVtkLine(ap,bp);
    std::vector<std::vector <float>> t;

    std::vector <float> r_a;
    r_a.push_back(raw_cloud1);
    t.push_back(r_a);

    std::vector <float> r_b;
    r_b.push_back(raw_cloud2);
    t.push_back(r_b);

    std::vector <float> t_a;
    t_a.push_back(ap.x);
    t_a.push_back(ap.y);
    t_a.push_back(ap.z);
    t.push_back(t_a);

    std::vector <float> t_b;
    t_b.push_back(bp.x);
    t_b.push_back(bp.y);
    t_b.push_back(bp.z);
    t.push_back(t_b);

    res[c_row]=t;
}

void VGRibbonWindow::line_line_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud1="+ui->line_line_cloud->currentText()+","+
                  "raw_cloud2="+ui->line_line_cloud_2->currentText());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::on_line_line_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_line_line_general_clicked();
        int raw_cloud=ui->line_line_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        line_line_setting_change();
    }
}

void VGRibbonWindow::on_line_line_cloud_2_currentIndexChanged(int index)
{
    if(index>=0){
        on_line_line_general_clicked();
        line_line_setting_change();
    }
}

//线到面
void VGRibbonWindow::on_line_plane_general_clicked()
{
    ui->line_plane_result->setText("");
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->line_plane_cloud->count()>0){
        int raw_cloud=ui->line_plane_cloud->currentText().toInt()-1;
        int raw_cloud2=ui->line_plane_cloud_2->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->line_plane_preview->setEnabled(false);
            }else{
                openrawcloud(cloudarrary[raw_cloud]);
                if((ui->ordertable->item(raw_cloud,3)->text()=="找线")&&
                   (ui->ordertable->item(raw_cloud2,3)->text()=="找面")){
                    ui->line_plane_preview->setEnabled(true);
                    openrawcloud(cloudarrary[raw_cloud]);
                    highLightline(raw_cloud);
                    highLightplane(raw_cloud2);

                    double x,y,z;
                    x=ui->line_plane_x->text().toDouble();
                    y=ui->line_plane_y->text().toDouble();
                    z=ui->line_plane_z->text().toDouble();
                    origin_add_3D(x,y,z);

                }else{
                    ui->line_plane_preview->setEnabled(false);
                }

            }
        }else
            ui->line_plane_preview->setEnabled(false);
    }else{
        ui->line_plane_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_line_plane_preview_clicked()
{
    on_line_plane_general_clicked();
    int raw_cloud1=ui->line_plane_cloud->currentText().toInt()-1;
    int raw_cloud2=ui->line_plane_cloud_2->currentText().toInt()-1;
    std::vector<float> a,b;
    for(int i=0;i<res[raw_cloud1][0].size();i++)
        a.push_back(res[raw_cloud1][0][i]);

    for(int i=0;i<res[raw_cloud2][0].size();i++)
        b.push_back(res[raw_cloud2][0][i]);

    YZVision::PointXYZ point;
    double x,y,z;
    x=ui->line_plane_x->text().toDouble();
    y=ui->line_plane_y->text().toDouble();
    z=ui->line_plane_z->text().toDouble();
    point.setPoint(x,y,z);

    YZVision::Measurement::MeasureDirection d;
    if(ui->line_plane_direction->currentIndex()==0){
        d=YZVision::Measurement::MeasureDirection::PARALLEL_TO_Z_AXIS;
    }
    YZVision::PointXYZ ap,bp;
    QElapsedTimer  mstimer;
    mstimer.start();

    double result=0;
    int resu;
    YZVision::Measurement* measurement = NULL;
    YZVision::LineToPlaneDis_3D* p_l2planeDis = new YZVision::LineToPlaneDis_3D();
    measurement = p_l2planeDis;
    YZVision::Measurement::InputParam input_Param;
    YZVision::Measurement::OutputParam output_Param;
    input_Param.line_out_plane=a;
    input_Param.plane1Coeffients=b;
    input_Param.ref_pt=point;
    input_Param.measure_dir=d;
    resu=measurement->measure(input_Param, &output_Param);
    result=output_Param.distance;
    ap=output_Param.pt3_on_line;
    bp=output_Param.pt4_on_plane;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);

    ui->line_plane_result->setText("距离为"+QString::number(result));

    setVtkLine(ap,bp);
    std::vector<std::vector <float>> t;

    std::vector <float> r_a;
    r_a.push_back(raw_cloud1);
    t.push_back(r_a);

    std::vector <float> r_b;
    r_b.push_back(raw_cloud2);
    t.push_back(r_b);

    std::vector <float> t_a;
    t_a.push_back(ap.x);
    t_a.push_back(ap.y);
    t_a.push_back(ap.z);
    t.push_back(t_a);

    std::vector <float> t_b;
    t_b.push_back(bp.x);
    t_b.push_back(bp.y);
    t_b.push_back(bp.z);
    t.push_back(t_b);

    res[c_row]=t;
}

void VGRibbonWindow::line_plane_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud1="+ui->line_plane_cloud->currentText()+","+
                  "raw_cloud2="+ui->line_plane_cloud_2->currentText()+","+
                  "direction="+QString::number(ui->line_plane_direction->currentIndex()));
    ui->ordertable->setItem(c_row,4,item->clone());
    QTableWidgetItem *roi = new QTableWidgetItem;
    roi->setText(ui->line_plane_x->text()+","+
                 ui->line_plane_y->text()+","+
                 ui->line_plane_z->text());
    ui->ordertable->setItem(c_row,9,roi->clone());
}

void VGRibbonWindow::on_line_plane_cloud_2_currentIndexChanged(int index)
{
    if(index>=0){
        on_line_plane_general_clicked();
        int raw_cloud=ui->line_plane_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        line_plane_setting_change();
    }
}

void VGRibbonWindow::on_line_plane_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_line_plane_general_clicked();
        line_plane_setting_change();
    }
}

void VGRibbonWindow::on_line_plane_direction_currentIndexChanged(int index)
{
    if(index>=0){
        line_plane_setting_change();
    }
}

void VGRibbonWindow::on_line_plane_x_editingFinished()
{
    on_line_plane_general_clicked();
    line_plane_setting_change();
}

void VGRibbonWindow::on_line_plane_y_editingFinished()
{
    on_line_plane_general_clicked();
    line_plane_setting_change();
}

void VGRibbonWindow::on_line_plane_z_editingFinished()
{
    on_line_plane_general_clicked();
    line_plane_setting_change();
}

//面到面
void VGRibbonWindow::on_plane_plane_general_clicked()
{
    ui->plane_plane_result->setText("");
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    opencloud();
    if(ui->plane_plane_cloud->count()>0){
        int raw_cloud=ui->plane_plane_cloud->currentText().toInt()-1;
        int raw_cloud2=ui->plane_plane_cloud_2->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->plane_plane_preview->setEnabled(false);
            }else{
                openrawcloud(cloudarrary[raw_cloud]);
                if((ui->ordertable->item(raw_cloud,3)->text()=="找面")&&
                   (ui->ordertable->item(raw_cloud2,3)->text()=="找面")){
                    ui->plane_plane_preview->setEnabled(true);
                    openrawcloud(cloudarrary[raw_cloud]);
                    highLightplane(raw_cloud);
                    highLightplane(raw_cloud2);

                    double x,y,z;
                    x=ui->plane_plane_x->text().toDouble();
                    y=ui->plane_plane_y->text().toDouble();
                    z=ui->plane_plane_z->text().toDouble();
                    origin_add_3D(x,y,z);
                }else{
                    ui->plane_plane_preview->setEnabled(false);
                }

            }
        }else
            ui->plane_plane_preview->setEnabled(false);
    }else{
        ui->plane_plane_preview->setEnabled(false);
    }
}

void VGRibbonWindow::on_plane_plane_preview_clicked()
{
    on_plane_plane_general_clicked();

    int raw_cloud1=ui->plane_plane_cloud->currentText().toInt()-1;
    int raw_cloud2=ui->plane_plane_cloud_2->currentText().toInt()-1;
    std::vector<float> a,b;
    for(int i=0;i<res[raw_cloud1][0].size();i++)
        a.push_back(res[raw_cloud1][0][i]);

    for(int i=0;i<res[raw_cloud2][0].size();i++)
        b.push_back(res[raw_cloud2][0][i]);


    YZVision::PointXYZ point;
    double x,y,z;
    x=ui->plane_plane_x->text().toDouble();
    y=ui->plane_plane_y->text().toDouble();
    z=ui->plane_plane_z->text().toDouble();
    point.setPoint(x,y,z);
    YZVision::Measurement::MeasureDirection d;
    if(ui->plane_plane_direction->currentIndex()==0){
        d=YZVision::Measurement::MeasureDirection::PARALLEL_TO_Z_AXIS;
    }

    YZVision::PointXYZ ap,bp;

    QElapsedTimer  mstimer;
    mstimer.start();

    double result=0;
    int resu;
    YZVision::Measurement* measurement = NULL;
    YZVision::PlaneToPlaneDis_3D* p_plane2planeDis = new YZVision::PlaneToPlaneDis_3D();
    measurement = p_plane2planeDis;
    YZVision::Measurement::InputParam input_Param;
    YZVision::Measurement::OutputParam output_Param;
    input_Param.plane1Coeffients=a;
    input_Param.plane2Coeffients=b;
    input_Param.ref_pt=point;
    input_Param.measure_dir=d;
    resu=measurement->measure(input_Param, &output_Param);
    result=output_Param.distance;
    ap=output_Param.pt5_on_plane;
    bp=output_Param.pt6_on_plane;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *timei = new QTableWidgetItem;
    timei->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,timei);

    ui->plane_plane_result->setText("距离为"+QString::number(result));

    setVtkLine(ap,bp);
    std::vector<std::vector <float>> t;

    std::vector <float> r_a;
    r_a.push_back(raw_cloud1);
    t.push_back(r_a);

    std::vector <float> r_b;
    r_b.push_back(raw_cloud2);
    t.push_back(r_b);

    std::vector <float> t_a;
    t_a.push_back(ap.x);
    t_a.push_back(ap.y);
    t_a.push_back(ap.z);
    t.push_back(t_a);

    std::vector <float> t_b;
    t_b.push_back(bp.x);
    t_b.push_back(bp.y);
    t_b.push_back(bp.z);
    t.push_back(t_b);

    res[c_row]=t;
}

void VGRibbonWindow::plane_plane_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud1="+ui->plane_plane_cloud->currentText()+","+
                  "raw_cloud2="+ui->plane_plane_cloud_2->currentText()+","+
                  "direction="+QString::number(ui->plane_plane_direction->currentIndex()));
    ui->ordertable->setItem(c_row,4,item->clone());
    QTableWidgetItem *roi = new QTableWidgetItem;
    roi->setText(ui->plane_plane_x->text()+","+
                 ui->plane_plane_y->text()+","+
                 ui->plane_plane_z->text());
    ui->ordertable->setItem(c_row,9,roi->clone());
}

void VGRibbonWindow::on_plane_plane_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_plane_plane_general_clicked();
        int raw_cloud=ui->plane_plane_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        plane_plane_setting_change();
    }
}

void VGRibbonWindow::on_plane_plane_cloud_2_currentIndexChanged(int index)
{
    if(index>=0){
        on_plane_plane_general_clicked();
        plane_plane_setting_change();
    }
}

void VGRibbonWindow::on_plane_plane_direction_currentIndexChanged(int index)
{
    Q_UNUSED(index);
    plane_plane_setting_change();
}

void VGRibbonWindow::on_plane_plane_x_editingFinished()
{
    on_plane_plane_general_clicked();
    plane_plane_setting_change();
}

void VGRibbonWindow::on_plane_plane_y_editingFinished()
{
    on_plane_plane_general_clicked();
    plane_plane_setting_change();
}

void VGRibbonWindow::on_plane_plane_z_editingFinished()
{
    on_plane_plane_general_clicked();
    plane_plane_setting_change();
}

//平整度
void VGRibbonWindow::on_planeness_general_clicked()
{
    ui->planeness_setting->setCurrentIndex(0);
    ui->planeness_result->setText("");
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->planeness_cloud->count()>0){
        int raw_cloud=ui->planeness_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->planeness_ROI->setEnabled(false);
                ui->planeness_preview->setEnabled(false);
            }else{
                ui->planeness_ROI->setEnabled(true);
                ui->planeness_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
            }
        }else
            ui->planeness_preview->setEnabled(false);
    }else{
        ui->planeness_preview->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_planeness_ROI_clicked()
{
    on_planeness_general_clicked();
    ui->planeness_ROI->setEnabled(false);
    ui->planeness_ROI_setting->show();
    double p_x=ui->planeness_x->text().toDouble();
    double p_y=ui->planeness_y->text().toDouble();
    double p_z=ui->planeness_z->text().toDouble();
    double l=ui->planeness_l->text().toDouble();
    double w=ui->planeness_w->text().toDouble();
    double h=ui->planeness_h->text().toDouble();
    if(l==0||w==0||h==0){
        p_x=0;
        p_y=0;
        p_z=0;
        l=20;
        w=20;
        h=20;
        ui->planeness_x->setText("0");
        ui->planeness_y->setText("0");
        ui->planeness_z->setText("0");
        ui->planeness_l->setText("20");
        ui->planeness_w->setText("20");
        ui->planeness_h->setText("20");
        start.setPoint(0,0,0);
        end.setPoint(20,20,20);
    }
    ROI_add_3D(p_x,p_y,p_z,l,w,h);
    planeness_ROI_change();
}

void VGRibbonWindow::on_planeness_preview_clicked()
{
    ui->planeness_ROI->setEnabled(true);
    ui->planeness_setting->setCurrentIndex(0);
    int raw_cloud=ui->planeness_cloud->currentText().toInt()-1;
    double threshold=ui->planeness_threshold->text().toDouble();
    YZVision::vPointsXYZ cloud;
    float min,max,sum;
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Planenesscloud_3D *planeness=new YZVision::Planenesscloud_3D();
    YZVision::Planenesscloud_3D::InputParam input= YZVision::Planenesscloud_3D::InputParam();
    YZVision::Planenesscloud_3D::OutputParam output= YZVision::Planenesscloud_3D::OutputParam();
    input.inputcloud=&cloudarrary[raw_cloud];
    input.r_0=threshold;
    input.m_StartPoint=start;
    input.m_EndPoint=end;
    result=planeness->planenesscloud(input,&output);
    cloud=output.outputcloud;
    min=output.min_p;
    max=output.max_p;
    sum=output.sum_p;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);

    cloudarrary[c_row]=cloud;
    ui->planeness_result->setText("平整度为"+QString::number(min)+","+QString::number(max)+","+QString::number(sum));

    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    z_min=10000;
    z_max=0;
    for(unsigned long long z=0;z<cloudarrary[c_row].size();z++ ){
        points->InsertPoint(z,cloudarrary[c_row][z].x,cloudarrary[c_row][z].y,cloudarrary[c_row][z].z);
        vertices->InsertNextCell(1);
        vertices->InsertCellPoint(z);
        if (cloudarrary[c_row][z].z < z_min)
        {
            z_min = cloudarrary[c_row][z].z;
        }

        if (cloudarrary[c_row][z].z > z_max)
        {
            z_max = cloudarrary[c_row][z].z;
        }
    }
    opencloud();
}

void VGRibbonWindow::planeness_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->planeness_cloud->currentText()+","+
                  "threshold="+ui->planeness_threshold->text());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::planeness_ROI_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    double* xrange = mouseStyle->a->GetXRange();
    double* yrange = mouseStyle->a->GetYRange();
    double* zrange = mouseStyle->a->GetZRange();
    start.setPoint(xrange[0],yrange[0],zrange[0]);
    end.setPoint(xrange[1],yrange[1],zrange[1]);
    item->setText(ui->planeness_x->text()+","+
                  ui->planeness_y->text()+","+
                  ui->planeness_z->text()+","+
                  ui->planeness_l->text()+","+
                  ui->planeness_w->text()+","+
                  ui->planeness_h->text()+","+
                  QString::number(xrange[0])+","+
                  QString::number(yrange[0])+","+
                  QString::number(zrange[0])+","+
                  QString::number(xrange[1])+","+
                  QString::number(yrange[1])+","+
                  QString::number(zrange[1]));
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_planeness_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_planeness_general_clicked();
        int raw_cloud=ui->planeness_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        planeness_setting_change();
    }
}

void VGRibbonWindow::on_planeness_threshold_editingFinished()
{
    planeness_setting_change();
}

void VGRibbonWindow::on_planeness_x_editingFinished()
{
    on_planeness_ROI_clicked();
    planeness_ROI_change();
}

void VGRibbonWindow::on_planeness_y_editingFinished()
{
    on_planeness_ROI_clicked();
    planeness_ROI_change();
}

void VGRibbonWindow::on_planeness_z_editingFinished()
{
    on_planeness_ROI_clicked();
    planeness_ROI_change();
}

void VGRibbonWindow::on_planeness_l_editingFinished()
{
    on_planeness_ROI_clicked();
    planeness_ROI_change();
}

void VGRibbonWindow::on_planeness_w_editingFinished()
{
    on_planeness_ROI_clicked();
    planeness_ROI_change();
}

void VGRibbonWindow::on_planeness_h_editingFinished()
{
    on_planeness_ROI_clicked();
    planeness_ROI_change();
}

//截面积
void VGRibbonWindow::on_outline_general_clicked()
{
    ui->outline_setting->setCurrentIndex(0);
    ui->outline_result->setText("");
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->outline_cloud->count()>0){
        int raw_cloud=ui->outline_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,3)->text()=="轮廓点云"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->outline_ROI->setEnabled(false);
                ui->outline_preview->setEnabled(false);
            }else{
                ui->outline_ROI->setEnabled(true);
                ui->outline_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }

                if(ui->outline_custom->isChecked()){
                    ui->outline_ROI->setEnabled(false);
                    ui->outline_custom_min->show();
                    ui->outline_custom_l->show();
                    ui->outline_custom_max->show();
                    if(ui->outline_custom_min->currentText().toInt()>0&&ui->outline_custom_max->currentText().toInt()){
                        if((ui->ordertable->item(ui->outline_custom_min->currentText().toInt()-1,3)->text()=="找边缘点"
                                ||ui->ordertable->item(ui->outline_custom_min->currentText().toInt()-1,3)->text()=="找拐点")&&
                                (ui->ordertable->item(ui->outline_custom_max->currentText().toInt()-1,3)->text()=="找边缘点"
                                ||ui->ordertable->item(ui->outline_custom_max->currentText().toInt()-1,3)->text()=="找拐点")){
                            if(cloudarrary[ui->outline_custom_min->currentText().toInt()-1].size()>0&&
                                   cloudarrary[ui->outline_custom_max->currentText().toInt()-1].size()>0 )
                                ui->outline_preview->setEnabled(true);
                            else
                                ui->outline_preview->setEnabled(false);
                        }else{
                            ui->outline_preview->setEnabled(false);
                        }
                    }else{
                        ui->outline_preview->setEnabled(false);
                    }

                }else{
                    ui->outline_ROI->setEnabled(true);
                    ui->outline_custom_min->close();
                    ui->outline_custom_l->close();
                    ui->outline_custom_max->close();
                }
            }
        }else{
            ui->outline_ROI->setEnabled(false);
            ui->outline_preview->setEnabled(false);
        }
    }else{
        ui->outline_preview->setEnabled(false);
        ui->outline_ROI->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_outline_ROI_clicked()
{
    on_outline_general_clicked();
    ui->outline_ROI->setEnabled(false);
    ui->outline_ROI_setting->show();
    double p_x=ui->outline_x->text().toDouble();
    double p_y=ui->outline_y->text().toDouble();
    double p_z=ui->outline_z->text().toDouble();
    double l=ui->outline_l->text().toDouble();
    double w=ui->outline_w->text().toDouble();
    double h=ui->outline_h->text().toDouble();
    if(l==0||w==0||h==0){
        p_x=0;
        p_y=0;
        p_z=0;
        l=20;
        w=20;
        h=20;
        ui->outline_x->setText("0");
        ui->outline_y->setText("0");
        ui->outline_z->setText("0");
        ui->outline_l->setText("20");
        ui->outline_w->setText("20");
        ui->outline_h->setText("20");
        start.setPoint(0,0,0);
        end.setPoint(20,20,20);
    }
    ROI_add_3D(p_x,p_y,p_z,l,w,h);
    outline_ROI_change();
}

void VGRibbonWindow::on_outline_preview_clicked()
{
    ui->outline_ROI->setEnabled(true);
    ui->outline_setting->setCurrentIndex(0);
    bool four=ui->outline_four->isChecked();
    bool custom=ui->outline_custom->isChecked();
    int raw_cloud=ui->outline_cloud->currentText().toInt()-1;
//    double y;
    float result=0;
    YZVision::PointsXYZ left;
    YZVision::PointsXYZ right;
    if(custom){
        int raw1=ui->outline_custom_min->currentText().toInt()-1;
        int raw2=ui->outline_custom_max->currentText().toInt()-1;

        YZVision::PointXYZ p1,p2;
        int z=0;

        for(z=0;z<res[raw1].size();z++){
            if(cloudarrary[raw_cloud][0].y==res[raw1][z][1]){
                p1.setPoint(res[raw1][z][0],res[raw1][z][1],res[raw1][z][2]);
                break;
            }
        }
        if(z==res[raw1].size())
            p1.setPoint(res[raw1][0][0],cloudarrary[raw_cloud][0].y,res[raw1][0][2]);


        for(z=0;z<res[raw2].size();z++){
            if(cloudarrary[raw_cloud][0].y==res[raw2][z][1]){
                p2.setPoint(res[raw2][z][0],res[raw2][z][1],res[raw2][z][2]);
                break;
            }
        }
        if(z==res[raw2].size())
            p2.setPoint(res[raw2][0][0],cloudarrary[raw_cloud][0].y,res[raw2][0][2]);

        if(p2.x>p1.x){
            left=p1;
            right=p2;
        }else{
            left=p2;
            right=p1;
        }

    }else{
        left=start;
        right=end;
    }
    if(custom)
        custom=false;
    else
        custom=true;
    int resu;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Outlinearea_3D *Outlinearea=new YZVision::Outlinearea_3D();
    YZVision::Outlinearea_3D::InputParam input= YZVision::Outlinearea_3D::InputParam();
    YZVision::Outlinearea_3D::OutputParam output= YZVision::Outlinearea_3D::OutputParam();
    input.inputcloud=&cloudarrary[raw_cloud];
    input.XXX=four;
    input.x_0=custom;
    input.m_StartPoint=left;
    input.m_EndPoint=right;
    qDebug()<<left.x<<left.y<<left.z;
    qDebug()<<right.x<<right.y<<right.z;
    resu=Outlinearea->outlinearea(input,&output);
    result=output.s_0;
    cloudarrary[c_row]=output.outputcloud_roi;

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item);
    ui->outline_result->setText("截面积为"+QString::number(result));

    openrawcloud(cloudarrary[raw_cloud]);
    highLight(cloudarrary[c_row]);
}

void VGRibbonWindow::outline_setting_change()
{
    QString four;
    if(ui->outline_four->isChecked())
        four="1";
    else
        four="0";
    QString custom;
    if(ui->outline_custom->isChecked())
        custom="1";
    else
        custom="0";
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->outline_cloud->currentText()+","+
                  "four="+four+","+
                  "custom="+custom+","+
                  "custom_min="+ui->outline_custom_min->currentText()+","+
                  "custom_max="+ui->outline_custom_max->currentText()
                  );
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::outline_ROI_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    double* xrange = mouseStyle->a->GetXRange();
    double* yrange = mouseStyle->a->GetYRange();
    double* zrange = mouseStyle->a->GetZRange();
    start.setPoint(xrange[0],yrange[0],zrange[0]);
    end.setPoint(xrange[1],yrange[1],zrange[1]);
    item->setText(ui->outline_x->text()+","+
                  ui->outline_y->text()+","+
                  ui->outline_z->text()+","+
                  ui->outline_l->text()+","+
                  ui->outline_w->text()+","+
                  ui->outline_h->text()+","+
                  QString::number(xrange[0])+","+
                  QString::number(yrange[0])+","+
                  QString::number(zrange[0])+","+
                  QString::number(xrange[1])+","+
                  QString::number(yrange[1])+","+
                  QString::number(zrange[1]));
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_outline_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_outline_general_clicked();
        int raw_cloud=ui->outline_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        outline_setting_change();
    }
}

void VGRibbonWindow::on_outline_four_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    outline_setting_change();
}

void VGRibbonWindow::on_outline_custom_stateChanged(int arg1)
{
    Q_UNUSED(arg1);
    if(ui->outline_custom->isChecked()){
        ui->outline_ROI->setEnabled(false);
        ui->outline_custom_min->show();
        ui->outline_custom_l->show();
        ui->outline_custom_max->show();
        if((ui->ordertable->item(ui->outline_custom_min->currentText().toInt()-1,3)->text()=="找边缘点"
                ||ui->ordertable->item(ui->outline_custom_min->currentText().toInt()-1,3)->text()=="找拐点")&&
                (ui->ordertable->item(ui->outline_custom_max->currentText().toInt()-1,3)->text()=="找边缘点"
                ||ui->ordertable->item(ui->outline_custom_max->currentText().toInt()-1,3)->text()=="找拐点")){
            ui->outline_preview->setEnabled(true);
        }else{
            ui->outline_preview->setEnabled(false);
        }
    }else{
        ui->outline_ROI->setEnabled(true);
        ui->outline_custom_min->close();
        ui->outline_custom_l->close();
        ui->outline_custom_max->close();
    }

    outline_setting_change();
}

void VGRibbonWindow::on_outline_custom_min_currentIndexChanged(int index)
{
    if(index>=0){
        if((ui->ordertable->item(ui->outline_custom_min->currentText().toInt()-1,3)->text()=="找边缘点"
                ||ui->ordertable->item(ui->outline_custom_min->currentText().toInt()-1,3)->text()=="找拐点")&&
                (ui->ordertable->item(ui->outline_custom_max->currentText().toInt()-1,3)->text()=="找边缘点"
                ||ui->ordertable->item(ui->outline_custom_max->currentText().toInt()-1,3)->text()=="找拐点")){
            ui->outline_preview->setEnabled(true);
        }else{
            ui->outline_preview->setEnabled(false);
        }
        outline_setting_change();
    }

}

void VGRibbonWindow::on_outline_custom_max_currentIndexChanged(int index)
{
    if(index>=0){
        if((ui->ordertable->item(ui->outline_custom_min->currentText().toInt()-1,3)->text()=="找边缘点"
                ||ui->ordertable->item(ui->outline_custom_min->currentText().toInt()-1,3)->text()=="找拐点")&&
                (ui->ordertable->item(ui->outline_custom_max->currentText().toInt()-1,3)->text()=="找边缘点"
                ||ui->ordertable->item(ui->outline_custom_max->currentText().toInt()-1,3)->text()=="找拐点")){
            ui->outline_preview->setEnabled(true);
        }else{
            ui->outline_preview->setEnabled(false);
        }
        outline_setting_change();
    }
}

void VGRibbonWindow::on_outline_x_editingFinished()
{
    on_outline_ROI_clicked();
    outline_ROI_change();
}

void VGRibbonWindow::on_outline_y_editingFinished()
{
    on_outline_ROI_clicked();
    outline_ROI_change();
}

void VGRibbonWindow::on_outline_z_editingFinished()
{
    on_outline_ROI_clicked();
    outline_ROI_change();
}

void VGRibbonWindow::on_outline_l_editingFinished()
{
    on_outline_ROI_clicked();
    outline_ROI_change();
}

void VGRibbonWindow::on_outline_w_editingFinished()
{
    on_outline_ROI_clicked();
    outline_ROI_change();
}

void VGRibbonWindow::on_outline_h_editingFinished()
{
    on_outline_ROI_clicked();
    outline_ROI_change();
}

//3D斑点高度
void VGRibbonWindow::on_Blob_3d_general_clicked()
{
    ui->Blob_3d_setting->setCurrentIndex(0);
    points = vtkSmartPointer<vtkPoints>::New();
    vertices = vtkSmartPointer<vtkCellArray>::New();
    if(ui->Blob_3d_cloud->count()>0){
        int raw_cloud=ui->Blob_3d_cloud->currentText().toInt()-1;
        if(ui->ordertable->item(raw_cloud,10)->text()=="3D"){
            if(cloudarrary[raw_cloud].size()==0){
                ui->Blob_3d_ROI->setEnabled(false);
                ui->Blob_3d_preview->setEnabled(false);
            }else{
                ui->Blob_3d_ROI->setEnabled(true);
                ui->Blob_3d_preview->setEnabled(true);
                z_min=10000;
                z_max=0;
                for(unsigned long long z=0;z<cloudarrary[raw_cloud].size();z++ ){
                    points->InsertPoint(z,cloudarrary[raw_cloud][z].x,cloudarrary[raw_cloud][z].y,cloudarrary[raw_cloud][z].z);
                    vertices->InsertNextCell(1);
                    vertices->InsertCellPoint(z);
                    if (cloudarrary[raw_cloud][z].z < z_min)
                    {
                        z_min = cloudarrary[raw_cloud][z].z;
                    }

                    if (cloudarrary[raw_cloud][z].z > z_max)
                    {
                        z_max = cloudarrary[raw_cloud][z].z;
                    }
                }
            }
        }else
            ui->Blob_3d_preview->setEnabled(false);
    }else{
        ui->Blob_3d_preview->setEnabled(false);
    }
    opencloud();
}

void VGRibbonWindow::on_Blob_3d_ROI_clicked()
{
    on_Blob_3d_general_clicked();
    ui->Blob_3d_ROI->setEnabled(false);
    ui->Blob_3d_ROI_setting->show();
    double p_x=ui->Blob_3d_x->text().toDouble();
    double p_y=ui->Blob_3d_y->text().toDouble();
    double p_z=ui->Blob_3d_z->text().toDouble();
    double l=ui->Blob_3d_l->text().toDouble();
    double w=ui->Blob_3d_w->text().toDouble();
    double h=ui->Blob_3d_h->text().toDouble();
    if(l==0||w==0||h==0){
        p_x=0;
        p_y=0;
        p_z=0;
        l=20;
        w=20;
        h=20;
        ui->Blob_3d_x->setText("0");
        ui->Blob_3d_y->setText("0");
        ui->Blob_3d_z->setText("0");
        ui->Blob_3d_l->setText("20");
        ui->Blob_3d_w->setText("20");
        ui->Blob_3d_h->setText("20");
        start.setPoint(0,0,0);
        end.setPoint(20,20,20);
    }
    ROI_add_3D(p_x,p_y,p_z,l,w,h);
    Blob_3d_ROI_change();
}

void VGRibbonWindow::on_Blob_3d_preview_clicked()
{
    ui->Blob_3d_ROI->setEnabled(true);
    int raw_cloud=ui->Blob_3d_cloud->currentText().toInt()-1;
    int number=ui->Blob_3d_number->text().toInt();
    double radius=ui->Blob_3d_radius->text().toDouble();
    int result;
    QElapsedTimer  mstimer;
    mstimer.start();

    YZVision::Cloudseg_3D *blob_3d=new YZVision::Cloudseg_3D();
    YZVision::Cloudseg_3D::InputParam input= YZVision::Cloudseg_3D::InputParam();
    YZVision::Cloudseg_3D::OutputParam output= YZVision::Cloudseg_3D::OutputParam();
    input.inputcloud=&cloudarrary[raw_cloud];
    input.r_0=radius;
    input.num=number;
    input.m_StartPoint=start;
    input.m_EndPoint=end;

    result=blob_3d->cloudseg(input,&output);

    float time = (double)mstimer.nsecsElapsed()/(double)1000000;
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText(QString::number(time));
    ui->ordertable->setItem(c_row,2,item->clone());
    ui->Blob_3d_setting->setCurrentIndex(1);
    cloudarrary[c_row]=cloudarrary[raw_cloud];
    openrawcloud(cloudarrary[c_row]);
    if(result!=0){
        ui->Blob_3d_pass->setText("pass");
        ui->Blob_3d_pass->setStyleSheet("color: rgb(0, 170, 0)");
        ui->Blob_3d_result->show();
        ui->Blob_3d_result->setRowCount(0);

        for(int z=0;z<output.out_seg.size();z++){
            std::vector <float> temp;
            qDebug()<<output.num_0[z];
            temp.push_back(output.num_0[z]);
            for(int x=0;x<output.out_seg[z].size();x++){
                temp.push_back(output.out_seg[z][x].x);
                temp.push_back(output.out_seg[z][x].y);
                temp.push_back(output.out_seg[z][x].z);
            }
            res[c_row].push_back(temp);
            ui->Blob_3d_result->setRowCount(z+1);
            item->setText(QString::number(output.out_seg[z][0].x)+","+
                    QString::number(output.out_seg[z][0].y)+","+
                    QString::number(output.out_seg[z][0].z));
            ui->Blob_3d_result->setItem(z,0,item->clone());
            item->setText(QString::number(output.num_0[z]));
            ui->Blob_3d_result->setItem(z,1,item->clone());
            highLightblob(output.out_seg[z]);

        }
        //设置表格列宽自适应
        ui->Blob_3d_result->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);

    }else{
        ui->Blob_3d_pass->setText("fail");
        ui->Blob_3d_pass->setStyleSheet("color: rgb(170, 0, 0)");
        ui->Blob_3d_result->close();
    }
}

void VGRibbonWindow::Blob_3d_setting_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    item->setText("raw_cloud="+ui->Blob_3d_cloud->currentText()+","+
                  "radius="+ui->Blob_3d_radius->text()+","+
                  "number="+ui->Blob_3d_number->text());
    ui->ordertable->setItem(c_row,4,item->clone());
}

void VGRibbonWindow::Blob_3d_ROI_change()
{
    QTableWidgetItem *item = new QTableWidgetItem;
    double* xrange = mouseStyle->a->GetXRange();
    double* yrange = mouseStyle->a->GetYRange();
    double* zrange = mouseStyle->a->GetZRange();
    start.setPoint(xrange[0],yrange[0],zrange[0]);
    end.setPoint(xrange[1],yrange[1],zrange[1]);
    item->setText(ui->Blob_3d_x->text()+","+
                  ui->Blob_3d_y->text()+","+
                  ui->Blob_3d_z->text()+","+
                  ui->Blob_3d_l->text()+","+
                  ui->Blob_3d_w->text()+","+
                  ui->Blob_3d_h->text()+","+
                  QString::number(xrange[0])+","+
                  QString::number(yrange[0])+","+
                  QString::number(zrange[0])+","+
                  QString::number(xrange[1])+","+
                  QString::number(yrange[1])+","+
                  QString::number(zrange[1]));
    ui->ordertable->setItem(c_row,9,item->clone());
}

void VGRibbonWindow::on_Blob_3d_cloud_currentIndexChanged(int index)
{
    if(index>=0){
        on_Blob_3d_general_clicked();
        int raw_cloud=ui->Blob_3d_cloud->currentText().toInt()-1;
        ui->ordertable->setItem(c_row,5,ui->ordertable->item(raw_cloud,5)->clone());
        ui->ordertable->setItem(c_row,6,ui->ordertable->item(raw_cloud,6)->clone());
        ui->ordertable->setItem(c_row,7,ui->ordertable->item(raw_cloud,7)->clone());
        Blob_3d_setting_change();
    }
}

void VGRibbonWindow::on_Blob_3d_radius_editingFinished()
{
    Blob_3d_setting_change();
}

void VGRibbonWindow::on_Blob_3d_number_editingFinished()
{
    Blob_3d_setting_change();
}

void VGRibbonWindow::on_Blob_3d_x_editingFinished()
{
    on_Blob_3d_ROI_clicked();
    Blob_3d_ROI_change();
}

void VGRibbonWindow::on_Blob_3d_y_editingFinished()
{
    on_Blob_3d_ROI_clicked();
    Blob_3d_ROI_change();
}

void VGRibbonWindow::on_Blob_3d_z_editingFinished()
{
    on_Blob_3d_ROI_clicked();
    Blob_3d_ROI_change();
}

void VGRibbonWindow::on_Blob_3d_l_editingFinished()
{
    on_Blob_3d_ROI_clicked();
    Blob_3d_ROI_change();
}

void VGRibbonWindow::on_Blob_3d_w_editingFinished()
{
    on_Blob_3d_ROI_clicked();
    Blob_3d_ROI_change();
}

void VGRibbonWindow::on_Blob_3d_h_editingFinished()
{
    on_Blob_3d_ROI_clicked();
    Blob_3d_ROI_change();
}
